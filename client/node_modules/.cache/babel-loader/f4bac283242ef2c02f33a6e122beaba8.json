{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { useCallback, useLayoutEffect, useState } from 'react';\nimport { createDispatcher, usePlayerContext as useContext, findPlayer } from '@vime/core';\n\nconst noop = () => {};\n/**\n * Returns the closest ancestor player to the given `ref`.\n */\n\n\nexport const usePlayer = ref => {\n  const [player, setPlayer] = useState(null);\n  useLayoutEffect(() => {\n    function find() {\n      return __awaiter(this, void 0, void 0, function* () {\n        setPlayer(ref.current ? yield findPlayer(ref.current) : null);\n      });\n    }\n\n    find();\n  }, [ref.current]);\n  return player;\n};\n/**\n * Binds the given `prop` to the closest ancestor player of the given `ref`. When the property\n * changes on the player, this hook will trigger a re-render with the new value.\n *\n * @param ref The ref to start searching from.\n * @param prop The property to bind to.\n * @param defaultValue The initial value of the property until the the player context is bound.\n */\n\nexport const usePlayerContext = (ref, prop, defaultValue) => {\n  const [value, setValue] = useState(defaultValue);\n  const dispatch = useCallback(ref.current === null ? noop : createDispatcher(ref.current), [ref.current]);\n  const setter = useCallback( // eslint-disable-next-line @typescript-eslint/no-shadow\n  value => {\n    dispatch(prop, value);\n  }, [dispatch, prop]);\n  useLayoutEffect(() => {\n    if (ref.current === null) return undefined;\n    let cleanup;\n\n    function connect() {\n      return __awaiter(this, void 0, void 0, function* () {\n        cleanup = yield useContext(ref.current, [prop], (_, newValue) => {\n          setValue(newValue);\n        });\n      });\n    }\n\n    connect();\n    return () => {\n      cleanup === null || cleanup === void 0 ? void 0 : cleanup();\n    };\n  }, [ref.current, prop]);\n  return [value, setter];\n};","map":{"version":3,"sources":["../../src/hooks.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SACE,WADF,EAEE,eAFF,EAGE,QAHF,QAIO,OAJP;AAKA,SAEE,gBAFF,EAGE,gBAAgB,IAAI,UAHtB,EAIE,UAJF,QAMO,YANP;;AAQA,MAAM,IAAI,GAAG,MAAK,CAAG,CAArB;AAEA;;AAEG;;;AACH,OAAO,MAAM,SAAS,GAAI,GAAD,IAA6C;AACpE,QAAM,CAAC,MAAD,EAAS,SAAT,IAAsB,QAAQ,CAA6B,IAA7B,CAApC;AAEA,EAAA,eAAe,CAAC,MAAK;AACnB,aAAe,IAAf,GAAmB;;AACjB,QAAA,SAAS,CAAE,GAAG,CAAC,OAAJ,GAAe,MAAM,UAAU,CAAC,GAAG,CAAC,OAAL,CAA/B,GAAgD,IAAlD,CAAT;AACD,O;AAAA;;AAED,IAAA,IAAI;AACL,GANc,EAMZ,CAAC,GAAG,CAAC,OAAL,CANY,CAAf;AAQA,SAAO,MAAP;AACD,CAZM;AAmBP;;;;;;;AAOG;;AACH,OAAO,MAAM,gBAAgB,GAAG,CAC9B,GAD8B,EAE9B,IAF8B,EAG9B,YAH8B,KAIZ;AAClB,QAAM,CAAC,KAAD,EAAQ,QAAR,IAAoB,QAAQ,CAAC,YAAD,CAAlC;AAEA,QAAM,QAAQ,GAAG,WAAW,CACzB,GAAG,CAAC,OAAJ,KAAgB,IAAjB,GAAyB,IAAzB,GAAgC,gBAAgB,CAAC,GAAG,CAAC,OAAL,CADtB,EAE1B,CAAC,GAAG,CAAC,OAAL,CAF0B,CAA5B;AAKA,QAAM,MAAM,GAAG,WAAW,EACxB;AACC,EAAA,KAAD,IAA0B;AAAG,IAAA,QAAQ,CAAC,IAAD,EAAc,KAAd,CAAR;AAA+B,GAFpC,EAGxB,CAAC,QAAD,EAAW,IAAX,CAHwB,CAA1B;AAMA,EAAA,eAAe,CAAC,MAAK;AACnB,QAAI,GAAG,CAAC,OAAJ,KAAgB,IAApB,EAA0B,OAAO,SAAP;AAE1B,QAAI,OAAJ;;AAEA,aAAe,OAAf,GAAsB;;AACpB,QAAA,OAAO,GAAG,MAAM,UAAU,CACxB,GAAG,CAAC,OADoB,EAExB,CAAC,IAAD,CAFwB,EAGxB,CAAC,CAAD,EAAI,QAAJ,KAAgB;AAAG,UAAA,QAAQ,CAAC,QAAD,CAAR;AAA4B,SAHvB,CAA1B;AAKD,O;AAAA;;AAED,IAAA,OAAO;AACP,WAAO,MAAK;AAAG,MAAA,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,EAAP;AAAc,KAA7B;AACD,GAfc,EAeZ,CAAC,GAAG,CAAC,OAAL,EAAc,IAAd,CAfY,CAAf;AAiBA,SAAO,CAAC,KAAD,EAAS,MAAT,CAAP;AACD,CApCM","sourcesContent":["import {\n  useCallback,\n  useLayoutEffect,\n  useState,\n} from 'react';\nimport {\n  PlayerProps,\n  createDispatcher,\n  usePlayerContext as useContext,\n  findPlayer,\n  WritableProps,\n} from '@vime/core';\n\nconst noop = () => {};\n\n/**\n * Returns the closest ancestor player to the given `ref`.\n */\nexport const usePlayer = (ref: React.RefObject<HTMLElement | null>) => {\n  const [player, setPlayer] = useState<HTMLVmPlayerElement | null>(null);\n\n  useLayoutEffect(() => {\n    async function find() {\n      setPlayer((ref.current ? (await findPlayer(ref.current)) : null));\n    }\n\n    find();\n  }, [ref.current]);\n\n  return player;\n};\n\nexport type PropBinding<P extends keyof PlayerProps> = [\n  value: PlayerProps[P],\n  setValue: P extends keyof WritableProps ? ((value: PlayerProps[P]) => void) : undefined,\n];\n\n/**\n * Binds the given `prop` to the closest ancestor player of the given `ref`. When the property\n * changes on the player, this hook will trigger a re-render with the new value.\n *\n * @param ref The ref to start searching from.\n * @param prop The property to bind to.\n * @param defaultValue The initial value of the property until the the player context is bound.\n */\nexport const usePlayerContext = <P extends keyof PlayerProps>(\n  ref: React.RefObject<HTMLElement | null>,\n  prop: P,\n  defaultValue: PlayerProps[P],\n): PropBinding<P> => {\n  const [value, setValue] = useState(defaultValue);\n\n  const dispatch = useCallback(\n    (ref.current === null) ? noop : createDispatcher(ref.current),\n    [ref.current],\n  );\n\n  const setter = useCallback(\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    (value: PlayerProps[P]) => { dispatch(prop as any, value); },\n    [dispatch, prop],\n  );\n\n  useLayoutEffect(() => {\n    if (ref.current === null) return undefined;\n\n    let cleanup: () => void;\n\n    async function connect() {\n      cleanup = await useContext(\n        ref.current!,\n        [prop],\n        (_, newValue) => { setValue(newValue as any); },\n      );\n    }\n\n    connect();\n    return () => { cleanup?.(); };\n  }, [ref.current, prop]);\n\n  return [value, (setter as any)];\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}