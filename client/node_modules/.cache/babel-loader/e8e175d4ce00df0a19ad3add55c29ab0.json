{"ast":null,"code":"const React = require('react');\n/**\n * Checks whether the argument is a valid object i.e (key-value pair).\n * @param {any} o\n */\n\n\nfunction isObject(o) {\n  return o && !Array.isArray(o) && Object(o) === o;\n}\n/**\n * Checks whether media type(audio/video) constraints are valid.\n * @param {MediaStreamConstraints} mediaType\n */\n\n\nfunction validateMediaTrackConstraints(mediaType) {\n  let supportedMediaConstraints = navigator.mediaDevices.getSupportedConstraints();\n  let unSupportedMediaConstraints = Object.keys(mediaType).filter(constraint => !supportedMediaConstraints[constraint]);\n\n  if (unSupportedMediaConstraints.length !== 0) {\n    let toText = unSupportedMediaConstraints.join(',');\n    console.error(`The following constraints ${toText} are not supported on this browser.`);\n  }\n}\n\nconst noop = () => {};\n/**\n * @callback Callback\n * @param {Blob} blob\n *\n * @callback ErrorCallback\n * @param {Error} error\n *\n * @typedef MediaRecorderProps\n * @type {Object}\n * @property {BlobPropertyBag} [blobOptions]\n * @property {Boolean} [recordScreen]\n * @property {Function} [onStart]\n * @property {Callback} [onStop]\n * @property {Callback} [onDataAvailable]\n * @property {ErrorCallback} [onError]\n * @property {Object} [mediaRecorderOptions]\n * @property {MediaStreamConstraints} mediaStreamConstraints\n *\n * @typedef MediaRecorderHookOptions\n * @type {Object}\n * @property {?Error} error\n * @property {('idle'|'acquiring_media'|'ready'|'recording'|'stopping'|'stopped'|'failed')} status\n * @property {?Blob} mediaBlob\n * @property {Boolean} isAudioMuted\n * @property {Function} stopRecording,\n * @property {Function} getMediaStream,\n * @property {Function} clearMediaStream,\n * @property {Function} startRecording,\n * @property {Function} pauseRecording,\n * @property {Function} resumeRecording,\n * @property {Function} muteAudio\n * @property {Function} unMuteAudio\n * @property {?MediaStream} liveStream\n *\n * Creates a custom media recorder object using the MediaRecorder API.\n * @param {MediaRecorderProps}\n * @returns {MediaRecorderHookOptions}\n */\n\n\nfunction useMediaRecorder({\n  blobOptions,\n  recordScreen,\n  onStop = noop,\n  onStart = noop,\n  onError = noop,\n  mediaRecorderOptions,\n  onDataAvailable = noop,\n  mediaStreamConstraints = {}\n}) {\n  let mediaChunks = React.useRef([]);\n  let mediaStream = React.useRef(null);\n  let mediaRecorder = React.useRef(null);\n  let [error, setError] = React.useState(null);\n  let [status, setStatus] = React.useState('idle');\n  let [mediaBlob, setMediaBlob] = React.useState(null);\n  let [isAudioMuted, setIsAudioMuted] = React.useState(false);\n\n  async function getMediaStream() {\n    if (error) {\n      setError(null);\n    }\n\n    setStatus('acquiring_media');\n\n    try {\n      let stream;\n\n      if (recordScreen) {\n        stream = await window.navigator.mediaDevices.getDisplayMedia(mediaStreamConstraints);\n      } else {\n        stream = await window.navigator.mediaDevices.getUserMedia(mediaStreamConstraints);\n      }\n\n      if (recordScreen && mediaStreamConstraints.audio) {\n        let audioStream = await window.navigator.mediaDevices.getUserMedia({\n          audio: mediaStreamConstraints.audio\n        });\n        audioStream.getAudioTracks().forEach(audioTrack => stream.addTrack(audioTrack));\n      }\n\n      mediaStream.current = stream;\n      setStatus('ready');\n    } catch (err) {\n      setError(err);\n      setStatus('failed');\n    }\n  }\n\n  function clearMediaStream() {\n    if (mediaStream.current) {\n      mediaStream.current.getTracks().forEach(track => track.stop());\n      mediaStream.current = null;\n    }\n  }\n\n  async function startRecording(timeSlice) {\n    if (error) {\n      setError(null);\n    }\n\n    if (!mediaStream.current) {\n      await getMediaStream();\n    }\n\n    mediaChunks.current = [];\n\n    if (mediaStream.current) {\n      mediaRecorder.current = new MediaRecorder(mediaStream.current, mediaRecorderOptions);\n      mediaRecorder.current.addEventListener('dataavailable', handleDataAvailable);\n      mediaRecorder.current.addEventListener('stop', handleStop);\n      mediaRecorder.current.addEventListener('error', handleError);\n      mediaRecorder.current.start(timeSlice);\n      setStatus('recording');\n      onStart();\n    }\n  }\n\n  function handleDataAvailable(e) {\n    if (e.data.size) {\n      mediaChunks.current.push(e.data);\n    }\n\n    onDataAvailable(e.data);\n  }\n\n  function handleStop() {\n    let [sampleChunk] = mediaChunks.current;\n    let blobPropertyBag = Object.assign({\n      type: sampleChunk.type\n    }, blobOptions);\n    let blob = new Blob(mediaChunks.current, blobPropertyBag);\n    setMediaBlob(blob);\n    setStatus('stopped');\n    onStop(blob);\n  }\n\n  function handleError(e) {\n    setError(e.error);\n    setStatus('idle');\n    onError(e.error);\n  }\n\n  function muteAudio(mute) {\n    setIsAudioMuted(mute);\n\n    if (mediaStream.current) {\n      mediaStream.current.getAudioTracks().forEach(audioTrack => {\n        audioTrack.enabled = !mute;\n      });\n    }\n  }\n\n  function pauseRecording() {\n    if (mediaRecorder.current && mediaRecorder.current.state === 'recording') {\n      mediaRecorder.current.pause();\n    }\n  }\n\n  function resumeRecording() {\n    if (mediaRecorder.current && mediaRecorder.current.state === 'paused') {\n      mediaRecorder.current.resume();\n    }\n  }\n\n  function stopRecording() {\n    if (mediaRecorder.current) {\n      setStatus('stopping');\n      mediaRecorder.current.stop(); // not sure whether to place clean up in useEffect?\n      // If placed in useEffect the handler functions become dependencies of useEffect\n\n      mediaRecorder.current.removeEventListener('dataavailable', handleDataAvailable);\n      mediaRecorder.current.removeEventListener('stop', handleStop);\n      mediaRecorder.current.removeEventListener('error', handleError);\n      mediaRecorder.current = null;\n      clearMediaStream();\n    }\n  }\n\n  React.useEffect(() => {\n    if (!window.MediaRecorder) {\n      throw new ReferenceError('MediaRecorder is not supported in this browser. Please ensure that you are running the latest version of chrome/firefox/edge.');\n    }\n\n    if (recordScreen && !window.navigator.mediaDevices.getDisplayMedia) {\n      throw new ReferenceError('This browser does not support screen capturing.');\n    }\n\n    if (isObject(mediaStreamConstraints.video)) {\n      validateMediaTrackConstraints(mediaStreamConstraints.video);\n    }\n\n    if (isObject(mediaStreamConstraints.audio)) {\n      validateMediaTrackConstraints(mediaStreamConstraints.audio);\n    }\n\n    if (mediaRecorderOptions && mediaRecorderOptions.mimeType) {\n      if (!MediaRecorder.isTypeSupported(mediaRecorderOptions.mimeType)) {\n        console.error(`The specified MIME type supplied to MediaRecorder is not supported by this browser.`);\n      }\n    }\n  }, [mediaStreamConstraints, mediaRecorderOptions, recordScreen]);\n  return {\n    error,\n    status,\n    mediaBlob,\n    isAudioMuted,\n    stopRecording,\n    getMediaStream,\n    startRecording,\n    pauseRecording,\n    resumeRecording,\n    clearMediaStream,\n    muteAudio: () => muteAudio(true),\n    unMuteAudio: () => muteAudio(false),\n\n    get liveStream() {\n      if (mediaStream.current) {\n        return new MediaStream(mediaStream.current.getVideoTracks());\n      }\n\n      return null;\n    }\n\n  };\n}\n\nmodule.exports = useMediaRecorder;","map":{"version":3,"sources":["C:/Smart-Virtual-Classroom/client/node_modules/@wmik/use-media-recorder/index.js"],"names":["React","require","isObject","o","Array","isArray","Object","validateMediaTrackConstraints","mediaType","supportedMediaConstraints","navigator","mediaDevices","getSupportedConstraints","unSupportedMediaConstraints","keys","filter","constraint","length","toText","join","console","error","noop","useMediaRecorder","blobOptions","recordScreen","onStop","onStart","onError","mediaRecorderOptions","onDataAvailable","mediaStreamConstraints","mediaChunks","useRef","mediaStream","mediaRecorder","setError","useState","status","setStatus","mediaBlob","setMediaBlob","isAudioMuted","setIsAudioMuted","getMediaStream","stream","window","getDisplayMedia","getUserMedia","audio","audioStream","getAudioTracks","forEach","audioTrack","addTrack","current","err","clearMediaStream","getTracks","track","stop","startRecording","timeSlice","MediaRecorder","addEventListener","handleDataAvailable","handleStop","handleError","start","e","data","size","push","sampleChunk","blobPropertyBag","assign","type","blob","Blob","muteAudio","mute","enabled","pauseRecording","state","pause","resumeRecording","resume","stopRecording","removeEventListener","useEffect","ReferenceError","video","mimeType","isTypeSupported","unMuteAudio","liveStream","MediaStream","getVideoTracks","module","exports"],"mappings":"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","sourcesContent":["const React = require('react');\n\n/**\n * Checks whether the argument is a valid object i.e (key-value pair).\n * @param {any} o\n */\nfunction isObject(o) {\n  return o && !Array.isArray(o) && Object(o) === o;\n}\n\n/**\n * Checks whether media type(audio/video) constraints are valid.\n * @param {MediaStreamConstraints} mediaType\n */\nfunction validateMediaTrackConstraints(mediaType) {\n  let supportedMediaConstraints = navigator.mediaDevices.getSupportedConstraints();\n  let unSupportedMediaConstraints = Object.keys(mediaType).filter(\n    constraint => !supportedMediaConstraints[constraint]\n  );\n\n  if (unSupportedMediaConstraints.length !== 0) {\n    let toText = unSupportedMediaConstraints.join(',');\n    console.error(\n      `The following constraints ${toText} are not supported on this browser.`\n    );\n  }\n}\n\nconst noop = () => {};\n\n/**\n * @callback Callback\n * @param {Blob} blob\n *\n * @callback ErrorCallback\n * @param {Error} error\n *\n * @typedef MediaRecorderProps\n * @type {Object}\n * @property {BlobPropertyBag} [blobOptions]\n * @property {Boolean} [recordScreen]\n * @property {Function} [onStart]\n * @property {Callback} [onStop]\n * @property {Callback} [onDataAvailable]\n * @property {ErrorCallback} [onError]\n * @property {Object} [mediaRecorderOptions]\n * @property {MediaStreamConstraints} mediaStreamConstraints\n *\n * @typedef MediaRecorderHookOptions\n * @type {Object}\n * @property {?Error} error\n * @property {('idle'|'acquiring_media'|'ready'|'recording'|'stopping'|'stopped'|'failed')} status\n * @property {?Blob} mediaBlob\n * @property {Boolean} isAudioMuted\n * @property {Function} stopRecording,\n * @property {Function} getMediaStream,\n * @property {Function} clearMediaStream,\n * @property {Function} startRecording,\n * @property {Function} pauseRecording,\n * @property {Function} resumeRecording,\n * @property {Function} muteAudio\n * @property {Function} unMuteAudio\n * @property {?MediaStream} liveStream\n *\n * Creates a custom media recorder object using the MediaRecorder API.\n * @param {MediaRecorderProps}\n * @returns {MediaRecorderHookOptions}\n */\nfunction useMediaRecorder({\n  blobOptions,\n  recordScreen,\n  onStop = noop,\n  onStart = noop,\n  onError = noop,\n  mediaRecorderOptions,\n  onDataAvailable = noop,\n  mediaStreamConstraints = {}\n}) {\n  let mediaChunks = React.useRef([]);\n  let mediaStream = React.useRef(null);\n  let mediaRecorder = React.useRef(null);\n  let [error, setError] = React.useState(null);\n  let [status, setStatus] = React.useState('idle');\n  let [mediaBlob, setMediaBlob] = React.useState(null);\n  let [isAudioMuted, setIsAudioMuted] = React.useState(false);\n\n  async function getMediaStream() {\n    if (error) {\n      setError(null);\n    }\n\n    setStatus('acquiring_media');\n\n    try {\n      let stream;\n\n      if (recordScreen) {\n        stream = await window.navigator.mediaDevices.getDisplayMedia(\n          mediaStreamConstraints\n        );\n      } else {\n        stream = await window.navigator.mediaDevices.getUserMedia(\n          mediaStreamConstraints\n        );\n      }\n\n      if (recordScreen && mediaStreamConstraints.audio) {\n        let audioStream = await window.navigator.mediaDevices.getUserMedia({\n          audio: mediaStreamConstraints.audio\n        });\n\n        audioStream\n          .getAudioTracks()\n          .forEach(audioTrack => stream.addTrack(audioTrack));\n      }\n\n      mediaStream.current = stream;\n      setStatus('ready');\n    } catch (err) {\n      setError(err);\n      setStatus('failed');\n    }\n  }\n\n  function clearMediaStream() {\n    if (mediaStream.current) {\n      mediaStream.current.getTracks().forEach(track => track.stop());\n      mediaStream.current = null;\n    }\n  }\n\n  async function startRecording(timeSlice) {\n    if (error) {\n      setError(null);\n    }\n\n    if (!mediaStream.current) {\n      await getMediaStream();\n    }\n    \n    mediaChunks.current = []\n\n    if (mediaStream.current) {\n      mediaRecorder.current = new MediaRecorder(\n        mediaStream.current,\n        mediaRecorderOptions\n      );\n      mediaRecorder.current.addEventListener(\n        'dataavailable',\n        handleDataAvailable\n      );\n      mediaRecorder.current.addEventListener('stop', handleStop);\n      mediaRecorder.current.addEventListener('error', handleError);\n      mediaRecorder.current.start(timeSlice);\n      setStatus('recording');\n      onStart();\n    }\n  }\n\n  function handleDataAvailable(e) {\n    if (e.data.size) {\n      mediaChunks.current.push(e.data);\n    }\n    onDataAvailable(e.data);\n  }\n\n  function handleStop() {\n    let [sampleChunk] = mediaChunks.current;\n    let blobPropertyBag = Object.assign(\n      { type: sampleChunk.type },\n      blobOptions\n    );\n    let blob = new Blob(mediaChunks.current, blobPropertyBag);\n\n    setMediaBlob(blob);\n    setStatus('stopped');\n    onStop(blob);\n  }\n\n  function handleError(e) {\n    setError(e.error);\n    setStatus('idle');\n    onError(e.error);\n  }\n\n  function muteAudio(mute) {\n    setIsAudioMuted(mute);\n\n    if (mediaStream.current) {\n      mediaStream.current.getAudioTracks().forEach(audioTrack => {\n        audioTrack.enabled = !mute;\n      });\n    }\n  }\n\n  function pauseRecording() {\n    if (mediaRecorder.current && mediaRecorder.current.state === 'recording') {\n      mediaRecorder.current.pause();\n    }\n  }\n\n  function resumeRecording() {\n    if (mediaRecorder.current && mediaRecorder.current.state === 'paused') {\n      mediaRecorder.current.resume();\n    }\n  }\n\n  function stopRecording() {\n    if (mediaRecorder.current) {\n      setStatus('stopping');\n      mediaRecorder.current.stop();\n      // not sure whether to place clean up in useEffect?\n      // If placed in useEffect the handler functions become dependencies of useEffect\n      mediaRecorder.current.removeEventListener(\n        'dataavailable',\n        handleDataAvailable\n      );\n      mediaRecorder.current.removeEventListener('stop', handleStop);\n      mediaRecorder.current.removeEventListener('error', handleError);\n      mediaRecorder.current = null;\n      clearMediaStream();\n    }\n  }\n\n  React.useEffect(() => {\n    if (!window.MediaRecorder) {\n      throw new ReferenceError(\n        'MediaRecorder is not supported in this browser. Please ensure that you are running the latest version of chrome/firefox/edge.'\n      );\n    }\n\n    if (recordScreen && !window.navigator.mediaDevices.getDisplayMedia) {\n      throw new ReferenceError(\n        'This browser does not support screen capturing.'\n      );\n    }\n\n    if (isObject(mediaStreamConstraints.video)) {\n      validateMediaTrackConstraints(mediaStreamConstraints.video);\n    }\n\n    if (isObject(mediaStreamConstraints.audio)) {\n      validateMediaTrackConstraints(mediaStreamConstraints.audio);\n    }\n\n    if (mediaRecorderOptions && mediaRecorderOptions.mimeType) {\n      if (!MediaRecorder.isTypeSupported(mediaRecorderOptions.mimeType)) {\n        console.error(\n          `The specified MIME type supplied to MediaRecorder is not supported by this browser.`\n        );\n      }\n    }\n  }, [mediaStreamConstraints, mediaRecorderOptions, recordScreen]);\n\n  return {\n    error,\n    status,\n    mediaBlob,\n    isAudioMuted,\n    stopRecording,\n    getMediaStream,\n    startRecording,\n    pauseRecording,\n    resumeRecording,\n    clearMediaStream,\n    muteAudio: () => muteAudio(true),\n    unMuteAudio: () => muteAudio(false),\n    get liveStream() {\n      if (mediaStream.current) {\n        return new MediaStream(mediaStream.current.getVideoTracks());\n      }\n      return null;\n    }\n  };\n}\n\nmodule.exports = useMediaRecorder;\n"]},"metadata":{},"sourceType":"script"}