"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getComponentFromRegistry = getComponentFromRegistry;
exports.getPlayerFromRegistry = getPlayerFromRegistry;
exports.isComponentRegistered = isComponentRegistered;
exports.watchComponentRegistry = watchComponentRegistry;
exports.withComponentRegistry = withComponentRegistry;
Object.defineProperty(exports, "setAssetPath", {
  enumerable: true,
  get: function get() {
    return _client.setAssetPath;
  }
});
exports.withPlayerContext = exports.usePlayerContext = exports.isWritableProp = exports.initialState = exports.findPlayer = exports.defineCustomElements = exports.createDispatcher = exports.VmYoutube = exports.VmVolumeControl = exports.VmVimeo = exports.VmVideo = exports.VmUi = exports.VmTooltip = exports.VmTimeProgress = exports.VmTime = exports.VmSubmenu = exports.VmSpinner = exports.VmSlider = exports.VmSkeleton = exports.VmSettingsControl = exports.VmSettings = exports.VmScrubberControl = exports.VmScrim = exports.VmPoster = exports.VmPlayer = exports.VmPlaybackControl = exports.VmPipControl = exports.VmMuteControl = exports.VmMenuRadioGroup = exports.VmMenuRadio = exports.VmMenuItem = exports.VmMenu = exports.VmLoadingScreen = exports.VmLiveIndicator = exports.VmIconLibrary = exports.VmIcon = exports.VmHls = exports.VmFullscreenControl = exports.VmFile = exports.VmEndTime = exports.VmEmbed = exports.VmDefaultUi = exports.VmDefaultSettings = exports.VmDefaultControls = exports.VmDblClickFullscreen = exports.VmDash = exports.VmDailymotion = exports.VmCurrentTime = exports.VmControls = exports.VmControlSpacer = exports.VmControlGroup = exports.VmControl = exports.VmClickToPlay = exports.VmCaptions = exports.VmCaptionControl = exports.VmAudio = exports.ViewType = exports.REGISTRY_KEY = exports.REGISTRATION_KEY = exports.Provider = exports.PLAYER_KEY = exports.MediaType = exports.COMPONENT_NAME_KEY = void 0;

var _client = require("@stencil/core/internal/client");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var en = {
  play: 'Play',
  pause: 'Pause',
  playback: 'Playback',
  scrubber: 'Scrubber',
  scrubberLabel: '{currentTime} of {duration}',
  played: 'Played',
  duration: 'Duration',
  buffered: 'Buffered',
  close: 'Close',
  currentTime: 'Current time',
  live: 'LIVE',
  volume: 'Volume',
  mute: 'Mute',
  unmute: 'Unmute',
  audio: 'Audio',
  default: 'Default',
  captions: 'Captions',
  subtitlesOrCc: 'Subtitles/CC',
  enableCaptions: 'Enable subtitles/captions',
  disableCaptions: 'Disable subtitles/captions',
  auto: 'Auto',
  fullscreen: 'Fullscreen',
  enterFullscreen: 'Enter fullscreen',
  exitFullscreen: 'Exit fullscreen',
  settings: 'Settings',
  seekForward: 'Seek forward',
  seekBackward: 'Seek backward',
  seekTotal: 'Seek total',
  normal: 'Normal',
  none: 'None',
  playbackRate: 'Playback Rate',
  playbackQuality: 'Playback Quality',
  loop: 'Loop',
  disabled: 'Disabled',
  off: 'Off',
  enabled: 'Enabled',
  pip: 'Picture-in-Picture',
  enterPiP: 'Miniplayer',
  exitPiP: 'Expand'
};
var initialState = {
  theme: undefined,
  paused: true,
  playing: false,
  duration: -1,
  currentProvider: undefined,
  mediaTitle: undefined,
  currentSrc: undefined,
  currentPoster: undefined,
  textTracks: [],
  currentTextTrack: -1,
  audioTracks: [],
  currentAudioTrack: -1,
  isTextTrackVisible: true,
  shouldRenderNativeTextTracks: true,
  icons: 'vime',
  currentTime: 0,
  autoplay: false,
  ready: false,
  playbackReady: false,
  loop: false,
  muted: false,
  buffered: 0,
  playbackRate: 1,
  playbackRates: [1],
  playbackQuality: undefined,
  playbackQualities: [],
  seeking: false,
  debug: false,
  playbackStarted: false,
  playbackEnded: false,
  buffering: false,
  controls: false,
  isControlsActive: false,
  volume: 50,
  isFullscreenActive: false,
  aspectRatio: '16:9',
  viewType: undefined,
  isAudioView: false,
  isVideoView: false,
  mediaType: undefined,
  isAudio: false,
  isVideo: false,
  isMobile: false,
  isTouch: false,
  isSettingsActive: false,
  isLive: false,
  isPiPActive: false,
  autopause: true,
  playsinline: false,
  language: 'en',
  languages: ['en'],
  translations: {
    en
  },
  i18n: en
};
exports.initialState = initialState;
var writableProps = new Set(['autoplay', 'autopause', 'aspectRatio', 'controls', 'theme', 'debug', 'paused', 'currentTime', 'language', 'loop', 'translations', 'playbackQuality', 'muted', 'playbackRate', 'playsinline', 'volume', 'isSettingsActive', 'isControlsActive', 'shouldRenderNativeTextTracks']);

var isWritableProp = prop => writableProps.has(prop);
/**
 * Player properties that should be reset when the media is changed.
 */


exports.isWritableProp = isWritableProp;
var resetableProps = new Set(['paused', 'currentTime', 'duration', 'buffered', 'seeking', 'playing', 'buffering', 'playbackReady', 'textTracks', 'currentTextTrack', 'audioTracks', 'currentAudioTrack', 'mediaTitle', 'currentSrc', 'currentPoster', 'playbackRate', 'playbackRates', 'playbackStarted', 'playbackEnded', 'playbackQuality', 'playbackQualities', 'mediaType']);

var shouldPropResetOnMediaChange = prop => resetableProps.has(prop);

var isNull = input => input === null;

var isUndefined = input => typeof input === 'undefined';

var isNullOrUndefined = input => isNull(input) || isUndefined(input);

var getConstructor = input => !isNullOrUndefined(input) ? input.constructor : undefined;

var isObject = input => getConstructor(input) === Object;

var isNumber = input => getConstructor(input) === Number && !Number.isNaN(input);

var isString = input => getConstructor(input) === String;

var isBoolean = input => getConstructor(input) === Boolean;

var isFunction = input => getConstructor(input) === Function;

var isArray = input => Array.isArray(input);

var isInstanceOf = (input, constructor) => Boolean(input && constructor && input instanceof constructor);

var STATE_CHANGE_EVENT = 'vmStateChange';
/**
 * Creates a dispatcher on the given `ref`, to send updates to the closest ancestor player via
 * the custom `vmStateChange` event.
 *
 * @param ref An element to dispatch the state change events from.
 */

var createDispatcher = ref => (prop, value) => {
  var el = isInstanceOf(ref, HTMLElement) ? ref : (0, _client.getElement)(ref);
  var event = new CustomEvent(STATE_CHANGE_EVENT, {
    bubbles: true,
    composed: true,
    detail: {
      by: el,
      prop,
      value
    }
  });
  el.dispatchEvent(event);
};

exports.createDispatcher = createDispatcher;

var createDeferredPromise = function createDeferredPromise() {
  var resolve;
  var promise = new Promise(function (res) {
    resolve = res;
  });
  return {
    promise: promise,
    resolve: resolve
  };
};

var openWormhole = function openWormhole(Component, props, isBlocking) {
  if (isBlocking === void 0) {
    isBlocking = true;
  }

  var isConstructor = Component.constructor.name === 'Function';
  var Proto = isConstructor ? Component.prototype : Component;
  var componentWillLoad = Proto.componentWillLoad;

  Proto.componentWillLoad = function () {
    var _this = this;

    var el = (0, _client.getElement)(this);
    var onOpen = createDeferredPromise();
    var event = new CustomEvent('openWormhole', {
      bubbles: true,
      composed: true,
      detail: {
        consumer: this,
        fields: props,
        updater: function updater(prop, value) {
          _this[prop] = value;
        },
        onOpen: onOpen
      }
    });
    el.dispatchEvent(event);

    var willLoad = function willLoad() {
      if (componentWillLoad) {
        return componentWillLoad.call(_this);
      }
    };

    return isBlocking ? onOpen.promise.then(function () {
      return willLoad();
    }) : willLoad();
  };
};

var multiverse = new Map();

var updateConsumer = function updateConsumer(_a, state) {
  var fields = _a.fields,
      updater = _a.updater;
  fields.forEach(function (field) {
    updater(field, state[field]);
  });
};

var Universe = {
  create: function create(creator, initialState) {
    var el = (0, _client.getElement)(creator);
    var wormholes = new Map();
    var universe = {
      wormholes: wormholes,
      state: initialState
    };
    multiverse.set(creator, universe);
    var connectedCallback = creator.connectedCallback;

    creator.connectedCallback = function () {
      multiverse.set(creator, universe);

      if (connectedCallback) {
        connectedCallback.call(creator);
      }
    };

    var disconnectedCallback = creator.disconnectedCallback;

    creator.disconnectedCallback = function () {
      multiverse.delete(creator);

      if (disconnectedCallback) {
        disconnectedCallback.call(creator);
      }
    };

    el.addEventListener('openWormhole', function (event) {
      event.stopPropagation();
      var _a = event.detail,
          consumer = _a.consumer,
          onOpen = _a.onOpen;
      if (wormholes.has(consumer)) return;

      if (typeof consumer !== 'symbol') {
        var connectedCallback_1 = consumer.connectedCallback,
            disconnectedCallback_1 = consumer.disconnectedCallback;

        consumer.connectedCallback = function () {
          wormholes.set(consumer, event.detail);

          if (connectedCallback_1) {
            connectedCallback_1.call(consumer);
          }
        };

        consumer.disconnectedCallback = function () {
          wormholes.delete(consumer);

          if (disconnectedCallback_1) {
            disconnectedCallback_1.call(consumer);
          }
        };
      }

      wormholes.set(consumer, event.detail);
      updateConsumer(event.detail, universe.state);
      onOpen === null || onOpen === void 0 ? void 0 : onOpen.resolve(function () {
        wormholes.delete(consumer);
      });
    });
    el.addEventListener('closeWormhole', function (event) {
      var consumer = event.detail;
      wormholes.delete(consumer);
    });
  },
  Provider: function Provider(_a, children) {
    var state = _a.state;
    var creator = (0, _client.getRenderingRef)();

    if (multiverse.has(creator)) {
      var universe = multiverse.get(creator);
      universe.state = state;
      universe.wormholes.forEach(function (opening) {
        updateConsumer(opening, state);
      });
    }

    return children;
  }
};
/**
 * Listen to an event on the given DOM node. Returns a callback to remove the event listener.
 */

function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}

function fireEventAndRetry(el, event, onFail) {
  var interval = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 300;
  var maxRetries = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 10;
  var timeout;
  var attempt = 0;
  var found = false;

  function retry() {
    if (found) return;
    timeout = setTimeout(() => {
      if (attempt === maxRetries) {
        onFail === null || onFail === void 0 ? void 0 : onFail();
        return;
      }

      el.dispatchEvent(event);
      attempt += 1;
      retry();
    }, interval);
  }

  retry();
  return () => {
    window.clearTimeout(timeout);
    found = true;
  };
}

var isColliding = function isColliding(a, b) {
  var translateAx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var translateAy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var translateBx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var translateBy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
  var aRect = a.getBoundingClientRect();
  var bRect = b.getBoundingClientRect();
  return aRect.left + translateAx < bRect.right + translateBx && aRect.right + translateAx > bRect.left + translateBx && aRect.top + translateAy < bRect.bottom + translateBy && aRect.bottom + translateAy > bRect.top + translateBy;
};

var deferredPromise = () => {
  var resolve;
  var reject;
  var promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  }); // @ts-ignore

  return {
    promise,
    resolve,
    reject
  };
};

function wrapStencilHook(component, lifecycle, hook) {
  var prevHook = component[lifecycle]; // eslint-disable-next-line func-names

  component[lifecycle] = function () {
    hook();
    return prevHook ? prevHook.call(component) : undefined;
  };
}

function createStencilHook(component, onConnect, onDisconnect) {
  var hasLoaded = false;

  if (!isUndefined(onConnect)) {
    wrapStencilHook(component, 'componentWillLoad', () => {
      onConnect();
      hasLoaded = true;
    });
    wrapStencilHook(component, 'connectedCallback', () => {
      if (hasLoaded) onConnect();
    });
  }

  if (!isUndefined(onDisconnect)) {
    wrapStencilHook(component, 'disconnectedCallback', () => {
      onDisconnect();
    });
  }
}

var FIND_PLAYER_EVENT = 'vmFindPlayer';

function withFindPlayer(player) {
  var el = (0, _client.getElement)(player);
  var off;
  createStencilHook(player, () => {
    off = listen(el, FIND_PLAYER_EVENT, event => {
      event.stopPropagation();
      event.detail(el);
    });
  }, () => {
    var _off;

    (_off = off) === null || _off === void 0 ? void 0 : _off();
  });
}
/**
 * Finds the closest ancestor player element by firing the `vmFindPlayer` event, and waiting
 * for the player to catch it. This function retries finding the player (`maxRetries`) until it
 * gives up and fails.
 *
 * @param ref - A HTMLElement that is within the player's subtree.
 * @param interval - The length of the timeout before trying again in milliseconds.
 * @param maxRetries - The number of times to retry firing the event.
 */


var findPlayer = function findPlayer(ref) {
  var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;
  var maxRetries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
  var el = isInstanceOf(ref, HTMLElement) ? ref : (0, _client.getElement)(ref);
  var search = deferredPromise();
  var stopFiring;
  var event = new CustomEvent(FIND_PLAYER_EVENT, {
    bubbles: true,
    composed: true,
    detail: player => {
      search.resolve(player);
      stopFiring();
    }
  });
  stopFiring = fireEventAndRetry(el, event, () => {
    search.reject("Could not find player for ".concat(el.nodeName));
  }, interval, maxRetries);
  return search.promise;
};

exports.findPlayer = findPlayer;
var LOAD_START_EVENT = 'vmLoadStart'; // Events that toggle state and the prop is named `is{PropName}...`.

var isToggleStateEvent = new Set(['isFullscreenActive', 'isControlsActive', 'isTextTrackVisible', 'isPiPActive', 'isLive', 'isTouch', 'isAudio', 'isVideo', 'isAudioView', 'isVideoView']); // Events that are emitted without the 'Change' postfix.

var hasShortenedEventName = new Set(['ready', 'playbackStarted', 'playbackEnded', 'playbackReady']);

var getEventName = prop => {
  // Example: isFullscreenActive -> vmFullscreenChange
  if (isToggleStateEvent.has(prop)) {
    return "vm".concat(prop.replace('is', '').replace('Active', ''), "Change");
  } // Example: playbackStarted -> vmPlaybackStarted


  if (hasShortenedEventName.has(prop)) {
    return "vm".concat(prop.charAt(0).toUpperCase()).concat(prop.slice(1));
  } // Example: currentTime -> vmCurrentTimeChange


  return "vm".concat(prop.charAt(0).toUpperCase()).concat(prop.slice(1), "Change");
};

function firePlayerEvent(el, prop, newValue, oldValue) {
  var events = [];
  events.push(new CustomEvent(getEventName(prop), {
    detail: newValue
  }));
  if (prop === 'paused' && !newValue) events.push(new CustomEvent('vmPlay'));
  if (prop === 'seeking' && oldValue && !newValue) events.push(new CustomEvent('vmSeeked'));
  events.forEach(event => {
    el.dispatchEvent(event);
  });
}
/**
 * Binds props between an instance of a given component class and it's closest ancestor player.
 *
 * @param component A Stencil component instance.
 * @param props A set of props to watch and update on the given component instance.
 */


var withPlayerContext = (component, props) => openWormhole(component, props);
/**
 * Finds the closest ancestor player to the given `ref` and watches the given props for changes. On
 * a prop change the given `updater` fn is called.
 *
 * @param ref A element within any player's subtree.
 * @param props A set of props to watch and call the `updater` fn with.
 * @param updater This function is called with the prop/value of any watched properties.
 */


exports.withPlayerContext = withPlayerContext;

var usePlayerContext = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (ref, props, updater, playerRef) {
    var player = playerRef !== null && playerRef !== void 0 ? playerRef : yield findPlayer(ref);
    var listeners = props.map(prop => {
      var event = getEventName(prop);
      return listen(player, event, () => {
        updater(prop, player[prop]);
      });
    });
    return () => {
      listeners.forEach(off => off());
    };
  });

  return function usePlayerContext(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();

exports.usePlayerContext = usePlayerContext;
var ViewType;
exports.ViewType = ViewType;

(function (ViewType) {
  ViewType["Audio"] = "audio";
  ViewType["Video"] = "video";
})(ViewType || (exports.ViewType = ViewType = {}));

var MediaType;
exports.MediaType = MediaType;

(function (MediaType) {
  MediaType["Audio"] = "audio";
  MediaType["Video"] = "video";
})(MediaType || (exports.MediaType = MediaType = {}));

var Provider;
exports.Provider = Provider;

(function (Provider) {
  Provider["Audio"] = "audio";
  Provider["Video"] = "video";
  Provider["HLS"] = "hls";
  Provider["Dash"] = "dash";
  Provider["YouTube"] = "youtube";
  Provider["Vimeo"] = "vimeo";
  Provider["Dailymotion"] = "dailymotion";
})(Provider || (exports.Provider = Provider = {}));

class Disposal {
  constructor() {
    var dispose = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    this.dispose = dispose;
  }

  add(callback) {
    this.dispose.push(callback);
  }

  empty() {
    this.dispose.forEach(fn => fn());
    this.dispose = [];
  }

}

var PLAYER_KEY = Symbol('vmPlayerKey');
exports.PLAYER_KEY = PLAYER_KEY;
var COMPONENT_NAME_KEY = Symbol('vmNameKey');
exports.COMPONENT_NAME_KEY = COMPONENT_NAME_KEY;
var REGISTRY_KEY = Symbol('vmRegistryKey');
exports.REGISTRY_KEY = REGISTRY_KEY;
var REGISTRATION_KEY = Symbol('vmRegistrationKey');
exports.REGISTRATION_KEY = REGISTRATION_KEY;
var REGISTER_COMPONENT_EVENT = 'vmComponentRegister';
var COMPONENT_REGISTERED_EVENT = 'vmComponentRegistered';
var COMPONENT_DEREGISTERED_EVENT = 'vmComponentDeregistered';

var getRegistrant = ref => isInstanceOf(ref, HTMLElement) ? ref : (0, _client.getElement)(ref);
/**
 * Handles registering/deregistering the given `component` in the player registry. All registries
 * are bound per player subtree.
 *
 * @param ref - A Stencil component instance or HTMLElement.
 */


function withComponentRegistry(ref, name) {
  var registryId = Symbol('vmRegistryId');
  var registrant = getRegistrant(ref);
  registrant[COMPONENT_NAME_KEY] = name !== null && name !== void 0 ? name : registrant.nodeName.toLowerCase();
  registrant[REGISTRATION_KEY] = registryId;

  var buildEvent = eventName => new CustomEvent(eventName, {
    bubbles: true,
    composed: true,
    detail: ref
  });

  var registerEvent = buildEvent(REGISTER_COMPONENT_EVENT);
  createStencilHook(ref, () => {
    registrant.dispatchEvent(registerEvent);
  });
}

function withComponentRegistrar(player) {
  var el = (0, _client.getElement)(player);
  var registry = new Map();
  var disposal = new Disposal(); // TODO properly type this later.

  el[REGISTRY_KEY] = registry;

  function onDeregister(registrant) {
    delete registrant[PLAYER_KEY];
    delete registrant[REGISTRY_KEY];
    registry.delete(registrant[REGISTRATION_KEY]);
    el.dispatchEvent(new CustomEvent(COMPONENT_DEREGISTERED_EVENT, {
      detail: registrant
    }));
  }

  function onRegister(e) {
    var ref = e.detail;
    var registrant = getRegistrant(ref);
    registrant[PLAYER_KEY] = el;
    registrant[REGISTRY_KEY] = registry;
    registry.set(registrant[REGISTRATION_KEY], registrant);
    el.dispatchEvent(new CustomEvent(COMPONENT_REGISTERED_EVENT, {
      detail: registrant
    }));
    createStencilHook(ref, undefined, () => onDeregister(registrant));
  }

  createStencilHook(player, () => {
    disposal.add(listen(el, REGISTER_COMPONENT_EVENT, onRegister));
  }, () => {
    registry.clear();
    disposal.empty();
    delete player[REGISTRY_KEY];
  });
}
/**
 * Checks whether any component with the given `name` exists in the registry. All registries
 * are bound per player subtree.
 *
 * @param ref - A Stencil component instance or HTMLElement.
 * @param name - The name of the component to search for.
 */


function isComponentRegistered(ref, name) {
  var _registry$values;

  var registrant = getRegistrant(ref);
  var registry = registrant[REGISTRY_KEY];
  return Array.from((_registry$values = registry === null || registry === void 0 ? void 0 : registry.values()) !== null && _registry$values !== void 0 ? _registry$values : []).some(r => r[COMPONENT_NAME_KEY] === name);
}
/**
 * Returns the player for the given `ref`. This will only work after the component has been
 * registered, prefer using `findPlayer`.
 *
 * @param ref - A Stencil component instance or HTMLElement.
 */


function getPlayerFromRegistry(ref) {
  var registrant = getRegistrant(ref);
  return registrant[PLAYER_KEY];
}
/**
 * Returns a collection of components from the registry for the given `ref`. All registries
 * are bound per player subtree.
 *
 * @param ref - A Stencil component instance or HTMLElement.
 * @param name - The name of the components to search for in the registry.
 */


function getComponentFromRegistry(ref, name) {
  var _registrant$REGISTRY_, _registrant$REGISTRY_2;

  var registrant = getRegistrant(ref);
  return Array.from((_registrant$REGISTRY_ = (_registrant$REGISTRY_2 = registrant[REGISTRY_KEY]) === null || _registrant$REGISTRY_2 === void 0 ? void 0 : _registrant$REGISTRY_2.values()) !== null && _registrant$REGISTRY_ !== void 0 ? _registrant$REGISTRY_ : []).filter(r => r[COMPONENT_NAME_KEY] === name);
}
/**
 * Watches the current registry on the given `ref` for changes. All registries are bound per
 * player subtree.
 *
 * @param ref - A Stencil component instance or HTMLElement.
 * @param name - The name of the component to watch for.
 * @param onChange - A callback that is called when a component is registered/deregistered.
 */


function watchComponentRegistry(_x5, _x6, _x7) {
  return _watchComponentRegistry.apply(this, arguments);
}

function _watchComponentRegistry() {
  _watchComponentRegistry = _asyncToGenerator(function* (ref, name, onChange) {
    var _registry$values2;

    var player = yield findPlayer(ref);
    var disposal = new Disposal();
    var registry = getRegistrant(ref)[REGISTRY_KEY];

    function listener(e) {
      if (e.detail[COMPONENT_NAME_KEY] === name) onChange === null || onChange === void 0 ? void 0 : onChange(getComponentFromRegistry(player, name));
    } // Hydrate.


    Array.from((_registry$values2 = registry === null || registry === void 0 ? void 0 : registry.values()) !== null && _registry$values2 !== void 0 ? _registry$values2 : []).forEach(reg => listener(new CustomEvent('', {
      detail: reg
    })));
    disposal.add(listen(player, COMPONENT_REGISTERED_EVENT, listener));
    disposal.add(listen(player, COMPONENT_DEREGISTERED_EVENT, listener));
    createStencilHook(ref, () => {}, () => {
      disposal.empty();
    });
    return () => {
      disposal.empty();
    };
  });
  return _watchComponentRegistry.apply(this, arguments);
}

var audioRegex = /\.(m4a|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\?)/i;
var videoRegex = /\.(mp4|og[gv]|webm|mov|m4v)($|\?)/i;
var hlsRegex = /\.(m3u8)($|\?)/i;
var hlsTypeRegex = /^application\/(x-mpegURL|vnd\.apple\.mpegURL)$/i;
var dashRegex = /\.(mpd)($|\?)/i;
var PROVIDER_CHANGE_EVENT = 'vmProviderChange';
/**
 * Creates a dispatcher on the given `ref`, to send updates to the closest ancestor player via
 * the custom `vmProviderChange` event.
 *
 * @param ref A component reference to dispatch the state change events from.
 */

var createProviderDispatcher = ref => (prop, value) => {
  var el = isInstanceOf(ref, HTMLElement) ? ref : (0, _client.getElement)(ref);
  var event = new CustomEvent(PROVIDER_CHANGE_EVENT, {
    bubbles: true,
    composed: true,
    detail: {
      by: el,
      prop,
      value
    }
  });
  el.dispatchEvent(event);
};

var providerWritableProps = new Set(['ready', 'playing', 'playbackReady', 'playbackStarted', 'playbackEnded', 'seeking', 'buffered', 'buffering', 'duration', 'viewType', 'mediaTitle', 'mediaType', 'currentSrc', 'currentPoster', 'playbackRates', 'playbackQualities', 'textTracks', 'currentTextTrack', 'isTextTrackVisible', 'audioTracks', 'currentAudioTrack', 'isPiPActive', 'isFullscreenActive']);

var isProviderWritableProp = prop => isWritableProp(prop) || providerWritableProps.has(prop);

var PROVIDER_CACHE_KEY = Symbol('vmProviderCache');
var PROVIDER_CONNECT_EVENT = 'vmMediaProviderConnect';
var PROVIDER_DISCONNECT_EVENT = 'vmMediaProviderDisconnect';

function buildProviderConnectEvent(name, host) {
  return new CustomEvent(name, {
    bubbles: true,
    composed: true,
    detail: host
  });
}

function withProviderHost(connector) {
  var el = (0, _client.getElement)(connector);
  var disposal = new Disposal();
  var cache = new Map();
  connector[PROVIDER_CACHE_KEY] = cache;

  function initCache() {
    Object.keys(connector).forEach(prop => {
      cache.set(prop, connector[prop]);
    });
  }

  function onDisconnect() {
    (0, _client.writeTask)( /*#__PURE__*/_asyncToGenerator(function* () {
      var _connector$onProvider;

      connector.ready = false;
      connector.provider = undefined;
      cache.clear();
      (_connector$onProvider = connector.onProviderDisconnect) === null || _connector$onProvider === void 0 ? void 0 : _connector$onProvider.call(connector);
      el.dispatchEvent(buildProviderConnectEvent(PROVIDER_DISCONNECT_EVENT));
    }));
  }

  function onConnect(event) {
    event.stopImmediatePropagation();
    initCache();
    var hostRef = event.detail;
    var host = (0, _client.getElement)(event.detail);
    if (connector.provider === host) return;
    var name = host === null || host === void 0 ? void 0 : host.nodeName.toLowerCase().replace('vm-', '');
    (0, _client.writeTask)( /*#__PURE__*/_asyncToGenerator(function* () {
      connector.provider = host;
      connector.currentProvider = Object.values(Provider).find(provider => name === provider);
      createStencilHook(hostRef, undefined, () => onDisconnect());
    }));
  }

  function onChange(event) {
    event.stopImmediatePropagation();
    var {
      by,
      prop,
      value
    } = event.detail;

    if (!isProviderWritableProp(prop)) {
      var _connector$logger;

      (_connector$logger = connector.logger) === null || _connector$logger === void 0 ? void 0 : _connector$logger.warn("".concat(by.nodeName, " tried to change `").concat(prop, "` but it is readonly."));
      return;
    }

    (0, _client.writeTask)(() => {
      cache.set(prop, value);
      connector[prop] = value;
    });
  }

  createStencilHook(connector, () => {
    disposal.add(listen(el, PROVIDER_CONNECT_EVENT, onConnect));
    disposal.add(listen(el, PROVIDER_CHANGE_EVENT, onChange));
  }, () => {
    disposal.empty();
    cache.clear();
  });
}

function withProviderConnect(ref) {
  var connectEvent = buildProviderConnectEvent(PROVIDER_CONNECT_EVENT, ref);
  createStencilHook(ref, () => {
    (0, _client.getElement)(ref).dispatchEvent(connectEvent);
  });
}

var Audio = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();
    /**
     * @internal Whether an external SDK will attach itself to the media player and control it.
     */


    this.willAttach = false;
    /** @inheritdoc */

    this.preload = 'metadata';
    withComponentRegistry(this);
    if (!this.willAttach) withProviderConnect(this);
  }
  /** @internal */


  getAdapter() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this2$filePro, _this2$fileProvider;

      var adapter = (_yield$_this2$filePro = yield (_this2$fileProvider = _this2.fileProvider) === null || _this2$fileProvider === void 0 ? void 0 : _this2$fileProvider.getAdapter()) !== null && _yield$_this2$filePro !== void 0 ? _yield$_this2$filePro : {};

      adapter.canPlay = /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator(function* (type) {
          return isString(type) && audioRegex.test(type);
        });

        return function (_x8) {
          return _ref4.apply(this, arguments);
        };
      }();

      return adapter;
    })();
  }

  render() {
    return (// @ts-ignore
      (0, _client.h)("vm-file", {
        noConnect: true,
        willAttach: this.willAttach,
        crossOrigin: this.crossOrigin,
        preload: this.preload,
        disableRemotePlayback: this.disableRemotePlayback,
        mediaTitle: this.mediaTitle,
        viewType: ViewType.Audio,
        ref: el => {
          this.fileProvider = el;
        }
      }, (0, _client.h)("slot", null))
    );
  }

};
var captionControlCss = ":host([hidden]){display:none}";
var CaptionControl = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.canToggleCaptionVisibility = false;
    /**
     * The URL to an SVG element or fragment to load.
     */

    this.showIcon = 'captions-on';
    /**
     * The URL to an SVG element or fragment to load.
     */

    this.hideIcon = 'captions-off';
    /**
     * Whether the tooltip is positioned above/below the control.
     */

    this.tooltipPosition = 'top';
    /**
     * Whether the tooltip should not be displayed.
     */

    this.hideTooltip = false;
    /** @inheritdoc */

    this.keys = 'c';
    /** @internal */

    this.i18n = {};
    /** @internal */

    this.playbackReady = false;
    /** @internal */

    this.textTracks = [];
    /** @internal */

    this.isTextTrackVisible = false;
    withComponentRegistry(this);
    withPlayerContext(this, ['i18n', 'textTracks', 'isTextTrackVisible', 'playbackReady']);
  }

  onTextTracksChange() {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      var _yield$player$canSetT;

      var player = getPlayerFromRegistry(_this3);
      _this3.canToggleCaptionVisibility = _this3.textTracks.length > 0 && ((_yield$player$canSetT = yield player === null || player === void 0 ? void 0 : player.canSetTextTrackVisibility()) !== null && _yield$player$canSetT !== void 0 ? _yield$player$canSetT : false);
    })();
  }

  componentDidLoad() {
    this.onTextTracksChange();
  }

  onClick() {
    var _player$setTextTrackV;

    var player = getPlayerFromRegistry(this);
    player === null || player === void 0 ? void 0 : (_player$setTextTrackV = player.setTextTrackVisibility) === null || _player$setTextTrackV === void 0 ? void 0 : _player$setTextTrackV.call(player, !this.isTextTrackVisible);
  }

  render() {
    var tooltip = this.isTextTrackVisible ? this.i18n.disableCaptions : this.i18n.enableCaptions;
    var tooltipWithHint = !isUndefined(this.keys) ? "".concat(tooltip, " (").concat(this.keys, ")") : tooltip;
    return (0, _client.h)(_client.Host, {
      hidden: !this.canToggleCaptionVisibility
    }, (0, _client.h)("vm-control", {
      label: this.i18n.captions,
      keys: this.keys,
      hidden: !this.canToggleCaptionVisibility,
      pressed: this.isTextTrackVisible,
      onClick: this.onClick.bind(this)
    }, (0, _client.h)("vm-icon", {
      name: this.isTextTrackVisible ? this.showIcon : this.hideIcon,
      library: this.icons
    }), (0, _client.h)("vm-tooltip", {
      hidden: this.hideTooltip,
      position: this.tooltipPosition,
      direction: this.tooltipDirection
    }, tooltipWithHint)));
  }

  static get watchers() {
    return {
      "textTracks": ["onTextTracksChange"],
      "playbackReady": ["onTextTracksChange"]
    };
  }

  static get style() {
    return captionControlCss;
  }

};
/* eslint-disable func-names */

var watch = new Set();
var controls = new Set(); // watchedEl -> (controlsEl -> controlsHeight) saved on collision. Basically keeps track of
// every collision with all controls for each watched element.

var collisions = new Map();

function update() {
  (0, _client.writeTask)(() => {
    controls.forEach(controlsEl => {
      var controlsHeight = parseFloat(window.getComputedStyle(controlsEl).height);
      watch.forEach(watchedEl => {
        var watchedElCollisions = collisions.get(watchedEl);
        var hasCollided = isColliding(watchedEl, controlsEl);
        var willCollide = isColliding(watchedEl, controlsEl, 0, controlsHeight) || isColliding(watchedEl, controlsEl, 0, -controlsHeight);
        watchedElCollisions.set(controlsEl, hasCollided || willCollide ? controlsHeight : 0);
      });
    }); // Update after assessing all collisions so there are no glitchy movements.

    watch.forEach(watchedEl => {
      var watchedElCollisions = collisions.get(watchedEl);
      watchedEl.style.setProperty('--vm-controls-height', "".concat(Math.max(0, Math.max(...watchedElCollisions.values())), "px"));
    });
  });
}

function registerControlsForCollisionDetection(component) {
  var el = (0, _client.getElement)(component);

  function getInnerEl() {
    return el.shadowRoot.querySelector('.controls');
  }

  createStencilHook(component, () => {
    var innerEl = getInnerEl();

    if (!isNull(innerEl)) {
      controls.add(innerEl);
      update();
    }
  }, () => {
    controls.delete(getInnerEl());
    update();
  });
  wrapStencilHook(component, 'componentDidLoad', () => {
    controls.add(getInnerEl());
    update();
  });
  wrapStencilHook(component, 'componentDidRender', update);
}

function withControlsCollisionDetection(component) {
  var el = (0, _client.getElement)(component);
  createStencilHook(component, () => {
    watch.add(el);
    collisions.set(el, new Map());
    update();
  }, () => {
    watch.delete(el);
    collisions.delete(el);
  });
}

var captionsCss = ":host{position:absolute;left:0;bottom:0;width:100%;pointer-events:none;z-index:var(--vm-captions-z-index)}.captions{width:100%;text-align:center;color:var(--vm-captions-text-color);font-size:var(--vm-captions-font-size);padding:$control-spacing;display:none;pointer-events:none;transition:transform 0.4s ease-in-out, opacity 0.3s ease-in-out}.captions.enabled{display:inline-block}.captions.hidden{display:none !important}.captions.inactive{opacity:0;visibility:hidden}.captions.fontMd{font-size:var(--vm-captions-font-size-medium)}.captions.fontLg{font-size:var(--vm-captions-font-size-large)}.captions.fontXl{font-size:var(--vm-captions-font-size-xlarge)}.cue{display:inline-block;background:var(--vm-captions-cue-bg-color);border-radius:var(--vm-captions-cue-border-radius);box-decoration-break:clone;line-height:185%;padding:var(--vm-captions-cue-padding);white-space:pre-wrap;pointer-events:none}.cue>div{display:inline}.cue:empty{display:none}";
var Captions = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.sizeDisposal = new Disposal();
    this.textDisposal = new Disposal();
    this.isEnabled = false;
    this.fontSize = 'sm';
    /**
     * Whether the captions should be visible or not.
     */

    this.hidden = false;
    /** @internal */

    this.isControlsActive = false;
    /** @internal */

    this.isVideoView = false;
    /** @internal */

    this.playbackStarted = false;
    /** @internal */

    this.textTracks = [];
    /** @internal */

    this.currentTextTrack = -1;
    /** @internal */

    this.isTextTrackVisible = true;
    withComponentRegistry(this);
    withControlsCollisionDetection(this);
    withPlayerContext(this, ['isVideoView', 'playbackStarted', 'isControlsActive', 'textTracks', 'currentTextTrack', 'isTextTrackVisible']);
  }

  onEnabledChange() {
    this.isEnabled = this.playbackStarted && this.isVideoView;
  }

  onTextTracksChange() {
    var textTrack = this.textTracks[this.currentTextTrack];

    var renderCues = () => {
      var _textTrack$activeCues;

      var activeCues = Array.from((_textTrack$activeCues = textTrack.activeCues) !== null && _textTrack$activeCues !== void 0 ? _textTrack$activeCues : []);
      this.renderCurrentCue(activeCues[0]);
    };

    this.textDisposal.empty();

    if (!isNullOrUndefined(textTrack)) {
      renderCues();
      this.textDisposal.add(listen(textTrack, 'cuechange', renderCues));
    }
  }

  connectedCallback() {
    this.dispatch = createDispatcher(this);
    this.dispatch('shouldRenderNativeTextTracks', false);
    this.onTextTracksChange();
    this.onPlayerResize();
  }

  disconnectedCallback() {
    this.textDisposal.empty();
    this.sizeDisposal.empty();
    this.dispatch('shouldRenderNativeTextTracks', true);
  }

  onPlayerResize() {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      var player = yield findPlayer(_this4);
      var container = yield player.getContainer();
      var resizeObs = new ResizeObserver(entries => {
        var entry = entries[0];
        var {
          width
        } = entry.contentRect;

        if (width >= 1360) {
          _this4.fontSize = 'xl';
        } else if (width >= 1024) {
          _this4.fontSize = 'lg';
        } else if (width >= 768) {
          _this4.fontSize = 'md';
        } else {
          _this4.fontSize = 'sm';
        }
      });
      resizeObs.observe(container);
    })();
  }

  renderCurrentCue(cue) {
    if (isNullOrUndefined(cue)) {
      this.cue = '';
      return;
    }

    var div = document.createElement('div');
    div.append(cue.getCueAsHTML());
    this.cue = div.innerHTML.trim();
  }

  render() {
    return (0, _client.h)("div", {
      style: {
        transform: "translateY(calc(".concat(this.isControlsActive ? 'var(--vm-controls-height)' : '24px', " * -1))")
      },
      class: {
        captions: true,
        enabled: this.isEnabled,
        hidden: this.hidden,
        fontMd: this.fontSize === 'md',
        fontLg: this.fontSize === 'lg',
        fontXl: this.fontSize === 'xl',
        inactive: !this.isTextTrackVisible
      }
    }, (0, _client.h)("span", {
      class: "cue"
    }, this.cue));
  }

  static get watchers() {
    return {
      "isVideoView": ["onEnabledChange"],
      "playbackStarted": ["onEnabledChange"],
      "textTracks": ["onTextTracksChange"],
      "currentTextTrack": ["onTextTracksChange"]
    };
  }

  static get style() {
    return captionsCss;
  }

};
var clickToPlayCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--vm-click-to-play-z-index)}.clickToPlay{display:none;width:100%;height:100%;pointer-events:none}.clickToPlay.enabled{display:inline-block;pointer-events:auto}";
var ClickToPlay = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    /**
     * By default this is disabled on mobile to not interfere with playback, set this to `true` to
     * enable it.
     */

    this.useOnMobile = false;
    /** @internal */

    this.paused = true;
    /** @internal */

    this.isVideoView = false;
    /** @internal */

    this.isMobile = false;
    withComponentRegistry(this);
    withPlayerContext(this, ['paused', 'isVideoView', 'isMobile']);
  }

  connectedCallback() {
    this.dispatch = createDispatcher(this);
  }
  /** @internal */


  forceClick() {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      _this5.onClick();
    })();
  }

  onClick() {
    this.dispatch('paused', !this.paused);
  }

  render() {
    return (0, _client.h)("div", {
      class: {
        clickToPlay: true,
        enabled: this.isVideoView && (!this.isMobile || this.useOnMobile)
      },
      onClick: this.onClick.bind(this)
    });
  }

  static get style() {
    return clickToPlayCss;
  }

};
var controlCss = "button{display:flex;align-items:center;flex-direction:row;border:var(--vm-control-border);cursor:pointer;flex-shrink:0;font-size:var(--vm-control-icon-size);color:var(--vm-control-color);background:var(--vm-control-bg, transparent);border-radius:var(--vm-control-border-radius);padding:var(--vm-control-padding);position:relative;pointer-events:auto;transition:all 0.3s ease;transform:scale(var(--vm-control-scale, 1));touch-action:manipulation;box-sizing:border-box}button.hidden{display:none}button:focus{outline:0}button.tapHighlight{background:var(--vm-control-tap-highlight)}button.notTouch:focus,button.notTouch:hover,button.notTouch[aria-expanded='true']{background:var(--vm-control-focus-bg);color:var(--vm-control-focus-color);transform:scale(calc(var(--vm-control-scale, 1) + 0.06))}";
var Control = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.vmInteractionChange = (0, _client.createEvent)(this, "vmInteractionChange", 7);
    this.vmFocus = (0, _client.createEvent)(this, "vmFocus", 7);
    this.vmBlur = (0, _client.createEvent)(this, "vmBlur", 7);
    this.keyboardDisposal = new Disposal();
    this.showTapHighlight = false;
    /**
     * Whether the control should be displayed or not.
     */

    this.hidden = false;
    /** @internal */

    this.isTouch = false;
    withComponentRegistry(this);
    withPlayerContext(this, ['isTouch']);
  }

  onKeysChange() {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      _this6.keyboardDisposal.empty();

      if (isUndefined(_this6.keys)) return;
      var player = yield findPlayer(_this6);

      var codes = _this6.keys.split('/');

      _this6.keyboardDisposal.add(listen(player, 'keydown', event => {
        if (codes.includes(event.key)) {
          _this6.button.click();
        }
      }));
    })();
  }

  connectedCallback() {
    this.findTooltip();
    this.onKeysChange();
  }

  componentWillLoad() {
    this.findTooltip();
  }

  disconnectedCallback() {
    this.keyboardDisposal.empty();
  }
  /**
   * Focuses the control.
   */


  focusControl() {
    var _this7 = this;

    return _asyncToGenerator(function* () {
      var _this7$button;

      (_this7$button = _this7.button) === null || _this7$button === void 0 ? void 0 : _this7$button.focus();
    })();
  }
  /**
   * Removes focus from the control.
   */


  blurControl() {
    var _this8 = this;

    return _asyncToGenerator(function* () {
      var _this8$button;

      (_this8$button = _this8.button) === null || _this8$button === void 0 ? void 0 : _this8$button.blur();
    })();
  }

  onTouchStart() {
    this.showTapHighlight = true;
  }

  onTouchEnd() {
    setTimeout(() => {
      this.showTapHighlight = false;
    }, 100);
  }

  findTooltip() {
    var tooltip = this.host.querySelector('vm-tooltip');
    if (!isNull(tooltip)) this.describedBy = tooltip.id;
    return tooltip;
  }

  onShowTooltip() {
    var tooltip = this.findTooltip();
    if (!isNull(tooltip)) tooltip.active = true;
    this.vmInteractionChange.emit(true);
  }

  onHideTooltip() {
    var tooltip = this.findTooltip();
    if (!isNull(tooltip)) tooltip.active = false;
    this.button.blur();
    this.vmInteractionChange.emit(false);
  }

  onFocus() {
    this.vmFocus.emit();
    this.onShowTooltip();
  }

  onBlur() {
    this.vmBlur.emit();
    this.onHideTooltip();
  }

  onMouseEnter() {
    this.onShowTooltip();
  }

  onMouseLeave() {
    this.onHideTooltip();
  }

  render() {
    var isMenuExpanded = this.expanded ? 'true' : 'false';
    var isPressed = this.pressed ? 'true' : 'false';
    return (0, _client.h)("button", {
      class: {
        hidden: this.hidden,
        notTouch: !this.isTouch,
        tapHighlight: this.showTapHighlight
      },
      id: this.identifier,
      type: "button",
      "aria-label": this.label,
      "aria-haspopup": !isUndefined(this.menu) ? 'true' : undefined,
      "aria-controls": this.menu,
      "aria-expanded": !isUndefined(this.menu) ? isMenuExpanded : undefined,
      "aria-pressed": !isUndefined(this.pressed) ? isPressed : undefined,
      "aria-hidden": this.hidden ? 'true' : 'false',
      "aria-describedby": this.describedBy,
      onTouchStart: this.onTouchStart.bind(this),
      onTouchEnd: this.onTouchEnd.bind(this),
      onFocus: this.onFocus.bind(this),
      onBlur: this.onBlur.bind(this),
      onMouseEnter: this.onMouseEnter.bind(this),
      onMouseLeave: this.onMouseLeave.bind(this),
      ref: el => {
        this.button = el;
      }
    }, (0, _client.h)("slot", null));
  }

  get host() {
    return this;
  }

  static get watchers() {
    return {
      "keys": ["onKeysChange"]
    };
  }

  static get style() {
    return controlCss;
  }

};
var controlGroupCss = ":host{width:100%}.controlGroup{position:relative;width:100%;display:flex;flex-wrap:wrap;flex-direction:inherit;align-items:inherit;justify-content:inherit;box-sizing:border-box}.controlGroup.spaceTop{margin-top:var(--vm-control-group-spacing)}.controlGroup.spaceBottom{margin-bottom:var(--vm-control-group-spacing)}::slotted(*){margin-left:var(--vm-controls-spacing)}::slotted(*:first-child){margin-left:0}";
var ControlNewLine = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    /**
     * Determines where to add spacing/margin. The amount of spacing is determined by the CSS variable
     * `--control-group-spacing`.
     */

    this.space = 'none';
    withComponentRegistry(this);
  }

  render() {
    return (0, _client.h)("div", {
      class: {
        controlGroup: true,
        spaceTop: this.space !== 'none' && this.space !== 'bottom',
        spaceBottom: this.space !== 'none' && this.space !== 'top'
      }
    }, (0, _client.h)("slot", null));
  }

  get host() {
    return this;
  }

  static get style() {
    return controlGroupCss;
  }

};
var controlSpacerCss = ":host{flex:1}";
var ControlSpacer = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    withComponentRegistry(this);
  }

  static get style() {
    return controlSpacerCss;
  }

};

var debounce = function debounce(func) {
  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
  var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var timeout;
  return function executedFunction() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var context = this;

    var later = function delayedFunctionCall() {
      timeout = undefined;
      if (!immediate) func.apply(context, args);
    };

    var callNow = immediate && isUndefined(timeout);
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
};

var controlsCss = ":host{position:relative;width:100%;z-index:var(--vm-controls-z-index)}:host([video]){position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}.controls{display:flex;width:100%;position:absolute;flex-wrap:wrap;pointer-events:auto;box-sizing:border-box;background:var(--vm-controls-bg);padding:var(--vm-controls-padding);border-radius:var(--vm-controls-border-radius);opacity:0;visibility:hidden;transition:var(--vm-fade-transition)}.controls.audio{position:relative}.controls.hidden{display:none}.controls.active{opacity:1;visibility:visible}.controls.fullWidth{width:100%}.controls.fullHeight{height:100%}::slotted(*:not(vm-control-group)){margin-left:var(--vm-controls-spacing)}::slotted(*:not(vm-control-group):first-child){margin-left:0}";
/**
 * We want to keep the controls active state in-sync per player.
 */

var playerRef = {};
var hideControlsTimeout = {};
var Controls = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.disposal = new Disposal();
    this.isInteracting = false;
    /**
     * Whether the controls are visible or not.
     */

    this.hidden = false;
    /**
     * Whether the controls container should be 100% width. This has no effect if the view is of
     * type `audio`.
     */

    this.fullWidth = false;
    /**
     * Whether the controls container should be 100% height. This has no effect if the view is of
     * type `audio`.
     */

    this.fullHeight = false;
    /**
     * Sets the `flex-direction` property that manages the direction in which the controls are layed
     * out.
     */

    this.direction = 'row';
    /**
     * Sets the `align-items` flex property that aligns the individual controls on the cross-axis.
     */

    this.align = 'center';
    /**
     * Sets the `justify-content` flex property that aligns the individual controls on the main-axis.
     */

    this.justify = 'start';
    /**
     * Pins the controls to the defined position inside the video player. This has no effect when
     * the view is of type `audio`.
     */

    this.pin = 'bottomLeft';
    /**
     * The length in milliseconds that the controls are active for before fading out. Audio players
     * are not effected by this prop.
     */

    this.activeDuration = 2750;
    /**
     * Whether the controls should wait for playback to start before being shown. Audio players
     * are not effected by this prop.
     */

    this.waitForPlaybackStart = false;
    /**
     * Whether the controls should show/hide when paused. Audio players are not effected by this prop.
     */

    this.hideWhenPaused = false;
    /**
     * Whether the controls should hide when the mouse leaves the player. Audio players are not
     * effected by this prop.
     */

    this.hideOnMouseLeave = false;
    /** @internal */

    this.isAudioView = false;
    /** @internal */

    this.isSettingsActive = false;
    /** @internal */

    this.playbackReady = false;
    /** @internal */

    this.isControlsActive = false;
    /** @internal */

    this.paused = true;
    /** @internal */

    this.playbackStarted = false;
    withComponentRegistry(this);
    registerControlsForCollisionDetection(this);
    withPlayerContext(this, ['playbackReady', 'isAudioView', 'isControlsActive', 'isSettingsActive', 'paused', 'playbackStarted']);
  }

  connectedCallback() {
    this.dispatch = createDispatcher(this);
    this.onControlsChange();
    this.setupPlayerListeners();
  }

  componentWillLoad() {
    this.onControlsChange();
  }

  disconnectedCallback() {
    this.disposal.empty();
    delete hideControlsTimeout[playerRef[this]];
    delete playerRef[this];
  }

  setupPlayerListeners() {
    var _this9 = this;

    return _asyncToGenerator(function* () {
      var player = yield findPlayer(_this9);
      var events = ['focus', 'keydown', 'click', 'touchstart', 'mouseleave'];
      events.forEach(event => {
        _this9.disposal.add(listen(player, event, _this9.onControlsChange.bind(_this9)));
      });

      _this9.disposal.add(listen(player, 'mousemove', debounce(_this9.onControlsChange, 50, true).bind(_this9))); // @ts-ignore


      playerRef[_this9] = player;
    })();
  }

  show() {
    this.dispatch('isControlsActive', true);
  }

  hide() {
    this.dispatch('isControlsActive', false);
  }

  hideWithDelay() {
    // @ts-ignore
    clearTimeout(hideControlsTimeout[playerRef[this]]);
    hideControlsTimeout[playerRef[this]] = setTimeout(() => {
      this.hide();
    }, this.activeDuration);
  }

  onControlsChange(event) {
    // @ts-ignore
    clearTimeout(hideControlsTimeout[playerRef[this]]);

    if (this.hidden || !this.playbackReady) {
      this.hide();
      return;
    }

    if (this.isAudioView) {
      this.show();
      return;
    }

    if (this.waitForPlaybackStart && !this.playbackStarted) {
      this.hide();
      return;
    }

    if (this.isInteracting || this.isSettingsActive) {
      this.show();
      return;
    }

    if (this.hideWhenPaused && this.paused) {
      this.hideWithDelay();
      return;
    }

    if (this.hideOnMouseLeave && !this.paused && (event === null || event === void 0 ? void 0 : event.type) === 'mouseleave') {
      this.hide();
      return;
    }

    if (!this.paused) {
      this.show();
      this.hideWithDelay();
      return;
    }

    this.show();
  }

  getPosition() {
    if (this.isAudioView) return {};

    if (this.pin === 'center') {
      return {
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)'
      };
    } // topLeft => { top: 0, left: 0 }


    var pos = this.pin.split(/(?=[L|R])/).map(s => s.toLowerCase());
    return {
      [pos[0]]: 0,
      [pos[1]]: 0
    };
  }

  onStartInteraction() {
    this.isInteracting = true;
  }

  onEndInteraction() {
    this.isInteracting = false;
  }

  render() {
    return (0, _client.h)(_client.Host, {
      video: !this.isAudioView
    }, (0, _client.h)("div", {
      style: _objectSpread(_objectSpread({}, this.getPosition()), {}, {
        flexDirection: this.direction,
        alignItems: this.align === 'center' ? 'center' : "flex-".concat(this.align),
        justifyContent: this.justify
      }),
      class: {
        controls: true,
        audio: this.isAudioView,
        hidden: this.hidden,
        active: this.playbackReady && this.isControlsActive,
        fullWidth: this.isAudioView || this.fullWidth,
        fullHeight: !this.isAudioView && this.fullHeight
      },
      onMouseEnter: this.onStartInteraction.bind(this),
      onMouseLeave: this.onEndInteraction.bind(this),
      onTouchStart: this.onStartInteraction.bind(this),
      onTouchEnd: this.onEndInteraction.bind(this)
    }, (0, _client.h)("slot", null)));
  }

  static get watchers() {
    return {
      "paused": ["onControlsChange"],
      "hidden": ["onControlsChange"],
      "isAudioView": ["onControlsChange"],
      "isInteracting": ["onControlsChange"],
      "isSettingsActive": ["onControlsChange"],
      "hideWhenPaused": ["onControlsChange"],
      "hideOnMouseLeave": ["onControlsChange"],
      "playbackStarted": ["onControlsChange"],
      "waitForPlaybackStart": ["onControlsChange"],
      "playbackReady": ["onControlsChange"]
    };
  }

  static get style() {
    return controlsCss;
  }

};
var currentTimeCss = ":host{display:flex;align-items:center;justify-content:center}";
var CurrentTime = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    /** @internal */

    this.currentTime = 0;
    /** @internal */

    this.i18n = {};
    /**
     * Whether the time should always show the hours unit, even if the time is less than
     * 1 hour (eg: `20:35` -> `00:20:35`).
     */

    this.alwaysShowHours = false;
    withComponentRegistry(this);
    withPlayerContext(this, ['currentTime', 'i18n']);
  }

  render() {
    return (0, _client.h)("vm-time", {
      label: this.i18n.currentTime,
      seconds: this.currentTime,
      alwaysShowHours: this.alwaysShowHours
    });
  }

  static get style() {
    return currentTimeCss;
  }

};
var IS_CLIENT = typeof window !== 'undefined';
var UA = IS_CLIENT ? window.navigator.userAgent.toLowerCase() : '';
var IS_IOS = /iphone|ipad|ipod|ios|CriOS|FxiOS/.test(UA);
var IS_ANDROID = /android/.test(UA);
var IS_MOBILE = IS_IOS || IS_ANDROID;
var IS_IPHONE = IS_CLIENT && /(iPhone|iPod)/gi.test(window.navigator.platform);
var IS_FIREFOX = /firefox/.test(UA);
var IS_SAFARI = IS_CLIENT && (window.safari || IS_IOS || /Apple/.test(UA));

var onMobileChange = callback => {
  if (!IS_CLIENT || isUndefined(window.ResizeObserver)) {
    callback(IS_MOBILE);
    return () => {};
  }

  function onResize() {
    callback(window.innerWidth <= 480 || IS_MOBILE);
  }

  callback(window.innerWidth <= 480 || IS_MOBILE);
  return listen(window, 'resize', onResize);
};

var onTouchInputChange = callback => {
  if (!IS_CLIENT) return () => {};
  var lastTouchTime = 0;
  var offTouchListener = listen(document, 'touchstart', () => {
    lastTouchTime = new Date().getTime();
    callback(true);
  }, true);
  var offMouseListener = listen(document, 'mousemove', () => {
    // Filter emulated events coming from touch events
    if (new Date().getTime() - lastTouchTime < 500) return;
    callback(false);
  }, true);
  return () => {
    offTouchListener();
    offMouseListener();
  };
};
/**
 * Checks if a video player can enter fullscreen.
 *
 * @see https://developer.apple.com/documentation/webkitjs/htmlvideoelement/1633500-webkitenterfullscreen
 */


var canFullscreenVideo = () => {
  if (!IS_CLIENT) return false;
  var video = document.createElement('video'); // @ts-ignore

  return isFunction(video.webkitEnterFullscreen);
};
/**
 * Checks if the screen orientation can be changed.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation
 */


var canRotateScreen = () => IS_CLIENT && window.screen.orientation && window.screen.orientation.lock;
/**
 * Checks if the native HTML5 video player can enter picture-in-picture (PIP) mode when using
 * the Chrome browser.
 *
 * @see  https://developers.google.com/web/updates/2018/10/watch-video-using-picture-in-picture
 */


var canUsePiPInChrome = () => {
  if (!IS_CLIENT) return false;
  var video = document.createElement('video'); // @ts-ignore

  return !!document.pictureInPictureEnabled && !video.disablePictureInPicture;
};
/**
 * Checks if the native HTML5 video player can enter picture-in-picture (PIP) mode when using
 * the desktop Safari browser, iOS Safari appears to "support" PiP through the check, however PiP
 * does not function.
 *
 * @see https://developer.apple.com/documentation/webkitjs/adding_picture_in_picture_to_your_safari_media_controls
 */


var canUsePiPInSafari = () => {
  if (!IS_CLIENT) return false;
  var video = document.createElement('video'); // @ts-ignore

  return isFunction(video.webkitSupportsPresentationMode) && // @ts-ignore
  isFunction(video.webkitSetPresentationMode) && !IS_IPHONE;
}; // Checks if the native HTML5 video player can enter PIP.


var canUsePiP = () => canUsePiPInChrome() || canUsePiPInSafari();
/**
 * To detect autoplay, we create a video element and call play on it, if it is `paused` after
 * a `play()` call, autoplay is supported. Although this unintuitive, it works across browsers
 * and is currently the lightest way to detect autoplay without using a data source.
 *
 * @see https://github.com/ampproject/amphtml/blob/9bc8756536956780e249d895f3e1001acdee0bc0/src/utils/video.js#L25
 */


var canAutoplay = function canAutoplay() {
  var muted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var playsinline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (!IS_CLIENT) return Promise.resolve(false);
  var video = document.createElement('video');

  if (muted) {
    video.setAttribute('muted', '');
    video.muted = true;
  }

  if (playsinline) {
    video.setAttribute('playsinline', '');
    video.setAttribute('webkit-playsinline', '');
  }

  video.setAttribute('height', '0');
  video.setAttribute('width', '0');
  video.style.position = 'fixed';
  video.style.top = '0';
  video.style.width = '0';
  video.style.height = '0';
  video.style.opacity = '0'; // Promise wrapped this way to catch both sync throws and async rejections.
  // More info: https://github.com/tc39/proposal-promise-try

  new Promise(resolve => resolve(video.play())).catch(() => {});
  return Promise.resolve(!video.paused);
};
/**
 * Attempt to parse json into a POJO.
 */


function tryParseJSON(json) {
  if (!isString(json)) return undefined;

  try {
    return JSON.parse(json);
  } catch (e) {
    return undefined;
  }
}
/**
 * Check if the given input is json or a plain object.
 */


var isObjOrJSON = input => !isNullOrUndefined(input) && (isObject(input) || isString(input) && input.startsWith('{'));
/**
 * If an object return otherwise try to parse it as json.
 */


var objOrParseJSON = input => isObject(input) ? input : tryParseJSON(input);
/**
 * Load image avoiding xhr/fetch CORS issues. Server status can't be obtained this way
 * unfortunately, so this uses "naturalWidth" to determine if the image has been loaded. By
 * default it checks if it is at least 1px.
 */


var loadImage = function loadImage(src) {
  var minWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  return new Promise((resolve, reject) => {
    var image = new Image();

    var handler = () => {
      // @ts-ignore
      delete image.onload; // @ts-ignore

      delete image.onerror;
      image.naturalWidth >= minWidth ? resolve(image) : reject(image);
    };

    Object.assign(image, {
      onload: handler,
      onerror: handler,
      src
    });
  });
};

var loadScript = function loadScript(src, onLoad) {
  var onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};
  var script = document.createElement('script');
  script.src = src;
  script.onload = onLoad;
  script.onerror = onError;
  var firstScriptTag = document.getElementsByTagName('script')[0];
  firstScriptTag.parentNode.insertBefore(script, firstScriptTag);
};
/**
 * Tries to parse json and return a object.
 */


var decodeJSON = data => {
  if (!isObjOrJSON(data)) return undefined;
  return objOrParseJSON(data);
};
/**
 * Attempts to safely decode a URI component, on failure it returns the given fallback.
 */


var tryDecodeURIComponent = function tryDecodeURIComponent(component) {
  var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  if (!IS_CLIENT) return fallback;

  try {
    return window.decodeURIComponent(component);
  } catch (e) {
    return fallback;
  }
};
/**
 * Returns a simple key/value map and duplicate keys are merged into an array.
 *
 * @see https://github.com/ampproject/amphtml/blob/c7c46cec71bac92f5c5da31dcc6366c18577f566/src/url-parse-query-string.js#L31
 */


var QUERY_STRING_REGEX = /(?:^[#?]?|&)([^=&]+)(?:=([^&]*))?/g;

var parseQueryString = qs => {
  var params = Object.create(null);
  if (isUndefined(qs)) return params;
  var match; // eslint-disable-next-line no-cond-assign

  while (match = QUERY_STRING_REGEX.exec(qs)) {
    var name = tryDecodeURIComponent(match[1], match[1]).replace('[]', '');
    var value = isString(match[2]) ? tryDecodeURIComponent(match[2].replace(/\+/g, ' '), match[2]) : '';
    var currValue = params[name];
    if (currValue && !isArray(currValue)) params[name] = [currValue];
    currValue ? params[name].push(value) : params[name] = value;
  }

  return params;
};
/**
 * Serializes the given params into a query string.
 */


var serializeQueryString = params => {
  var qs = [];

  var appendQueryParam = (param, v) => {
    qs.push("".concat(encodeURIComponent(param), "=").concat(encodeURIComponent(v)));
  };

  Object.keys(params).forEach(param => {
    var value = params[param];
    if (isNullOrUndefined(value)) return;

    if (isArray(value)) {
      value.forEach(v => appendQueryParam(param, v));
    } else {
      appendQueryParam(param, value);
    }
  });
  return qs.join('&');
};
/**
 * Notifies the browser to start establishing a connection with the given URL.
 */


var preconnect = function preconnect(url) {
  var rel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'preconnect';
  var as = arguments.length > 2 ? arguments[2] : undefined;
  if (!IS_CLIENT) return false;
  var link = document.createElement('link');
  link.rel = rel;
  link.href = url;
  if (!isUndefined(as)) link.as = as;
  link.crossOrigin = 'true';
  document.head.append(link);
  return true;
};
/**
 * Safely appends the given query string to the given URL.
 */


var appendQueryStringToURL = (url, qs) => {
  if (isUndefined(qs) || qs.length === 0) return url;
  var mainAndQuery = url.split('?', 2);
  return mainAndQuery[0] + (!isUndefined(mainAndQuery[1]) ? "?".concat(mainAndQuery[1], "&").concat(qs) : "?".concat(qs));
};
/**
 * Serializes the given params into a query string and appends them to the given URL.
 */


var appendParamsToURL = (url, params) => appendQueryStringToURL(url, isObject(params) ? serializeQueryString(params) : params);
/**
 * Tries to convert a query string into a object.
 */


var decodeQueryString = qs => {
  if (!isString(qs)) return undefined;
  return parseQueryString(qs);
};

var pendingSDKRequests = {};

var loadSDK = function loadSDK(url, sdkGlobalVar, sdkReadyVar) {
  var isLoaded = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => true;
  var loadScriptFn = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : loadScript;

  var getGlobal = key => {
    if (!isUndefined(window[key])) return window[key];
    if (window.exports && window.exports[key]) return window.exports[key];

    if (window.module && window.module.exports && window.module.exports[key]) {
      return window.module.exports[key];
    }

    return undefined;
  };

  var existingGlobal = getGlobal(sdkGlobalVar);

  if (existingGlobal && isLoaded(existingGlobal)) {
    return Promise.resolve(existingGlobal);
  }

  return new Promise((resolve, reject) => {
    if (!isUndefined(pendingSDKRequests[url])) {
      pendingSDKRequests[url].push({
        resolve,
        reject
      });
      return;
    }

    pendingSDKRequests[url] = [{
      resolve,
      reject
    }];

    var onLoaded = sdk => {
      pendingSDKRequests[url].forEach(request => request.resolve(sdk));
    };

    if (!isUndefined(sdkReadyVar)) {
      var previousOnReady = window[sdkReadyVar]; // eslint-disable-next-line func-names

      window[sdkReadyVar] = function () {
        if (!isUndefined(previousOnReady)) previousOnReady();
        onLoaded(getGlobal(sdkGlobalVar));
      };
    }

    loadScriptFn(url, () => {
      if (isUndefined(sdkReadyVar)) onLoaded(getGlobal(sdkGlobalVar));
    }, e => {
      pendingSDKRequests[url].forEach(request => {
        request.reject(e);
      });
      delete pendingSDKRequests[url];
    });
  });
};

var withProviderContext = function withProviderContext(provider) {
  var additionalProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return withPlayerContext(provider, ['autoplay', 'controls', 'language', 'muted', 'logger', 'loop', 'aspectRatio', 'playsinline', ...additionalProps]);
};

var dailymotionCss = ":host{z-index:var(--vm-media-z-index)}";
var videoInfoCache = new Map();
var Dailymotion = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.vmLoadStart = (0, _client.createEvent)(this, "vmLoadStart", 7);
    this.vmError = (0, _client.createEvent)(this, "vmError", 7);
    this.defaultInternalState = {};
    this.internalState = {
      currentTime: 0,
      volume: 0,
      muted: false,
      isAdsPlaying: false,
      playbackReady: false
    };
    this.embedSrc = '';
    this.mediaTitle = '';
    /**
     * Whether to automatically play the next video in the queue.
     */

    this.shouldAutoplayQueue = false;
    /**
     * Whether to show the 'Up Next' queue.
     */

    this.showUpNextQueue = false;
    /**
     * Whether to show buttons for sharing the video.
     */

    this.showShareButtons = false;
    /**
     * Whether to display the Dailymotion logo.
     */

    this.showDailymotionLogo = false;
    /**
     * Whether to show video information (title and owner) on the start screen.
     */

    this.showVideoInfo = true;
    /** @internal */

    this.language = 'en';
    /** @internal */

    this.autoplay = false;
    /** @internal */

    this.controls = false;
    /** @internal */

    this.loop = false;
    /** @internal */

    this.muted = false;
    /** @internal */

    this.playsinline = false;
    withComponentRegistry(this);
    withProviderConnect(this);
    withProviderContext(this);
  }

  onVideoIdChange() {
    this.internalState = _objectSpread({}, this.defaultInternalState);

    if (!this.videoId) {
      this.embedSrc = '';
      return;
    }

    this.embedSrc = "".concat(this.getOrigin(), "/embed/video/").concat(this.videoId, "?api=1");
    this.fetchVideoInfo = this.getVideoInfo();
    this.pendingMediaTitleCall = deferredPromise();
  }

  onControlsChange() {
    if (this.internalState.playbackReady) {
      this.remoteControl("controls"
      /* Controls */
      , this.controls);
    }
  }

  onCustomPosterChange() {
    this.dispatch('currentPoster', this.poster);
  }

  connectedCallback() {
    this.dispatch = createProviderDispatcher(this);
    this.dispatch('viewType', ViewType.Video);
    this.onVideoIdChange();
    this.initialMuted = this.muted;
    this.internalState.muted = this.muted;
    this.defaultInternalState = _objectSpread({}, this.internalState);
  }

  getOrigin() {
    return 'https://www.dailymotion.com';
  }

  getPreconnections() {
    return [this.getOrigin(), 'https://static1.dmcdn.net'];
  }

  remoteControl(command, arg) {
    return this.embed.postMessage({
      command,
      parameters: arg ? [arg] : []
    });
  }

  buildParams() {
    return {
      autoplay: this.autoplay,
      mute: this.initialMuted,
      'queue-autoplay-next': this.shouldAutoplayQueue,
      'queue-enable': this.showUpNextQueue,
      'sharing-enable': this.showShareButtons,
      syndication: this.syndication,
      'ui-highlight': this.color,
      'ui-logo': this.showDailymotionLogo,
      'ui-start-screen-info': this.showVideoInfo
    };
  }

  getVideoInfo() {
    var _this10 = this;

    return _asyncToGenerator(function* () {
      if (videoInfoCache.has(_this10.videoId)) return videoInfoCache.get(_this10.videoId);
      var apiEndpoint = 'https://api.dailymotion.com';
      return window.fetch("".concat(apiEndpoint, "/video/").concat(_this10.videoId, "?fields=duration,thumbnail_1080_url")).then(response => response.json()).then(data => {
        var poster = data.thumbnail_1080_url;
        var duration = parseFloat(data.duration);
        videoInfoCache.set(_this10.videoId, {
          poster,
          duration
        });
        return {
          poster,
          duration
        };
      });
    })();
  }

  onEmbedSrcChange() {
    this.vmLoadStart.emit();
    this.dispatch('viewType', ViewType.Video);
  }

  onEmbedMessage(event) {
    var _this$pendingMediaTit, _this$pendingMediaTit2;

    var msg = event.detail;

    switch (msg.event) {
      case "playback_ready"
      /* PlaybackReady */
      :
        this.onControlsChange();
        this.dispatch('currentSrc', this.embedSrc);
        this.dispatch('mediaType', MediaType.Video);
        Promise.all([this.fetchVideoInfo, (_this$pendingMediaTit = this.pendingMediaTitleCall) === null || _this$pendingMediaTit === void 0 ? void 0 : _this$pendingMediaTit.promise]).then((_ref5) => {
          var _info$duration, _this$poster;

          var [info, mediaTitle] = _ref5;
          this.dispatch('duration', (_info$duration = info === null || info === void 0 ? void 0 : info.duration) !== null && _info$duration !== void 0 ? _info$duration : -1);
          this.dispatch('currentPoster', (_this$poster = this.poster) !== null && _this$poster !== void 0 ? _this$poster : info === null || info === void 0 ? void 0 : info.poster);
          this.dispatch('mediaTitle', mediaTitle);
          this.dispatch('playbackReady', true);
        });
        break;

      case "videochange"
      /* VideoChange */
      :
        (_this$pendingMediaTit2 = this.pendingMediaTitleCall) === null || _this$pendingMediaTit2 === void 0 ? void 0 : _this$pendingMediaTit2.resolve(msg.title);
        break;

      case "start"
      /* Start */
      :
        this.dispatch('paused', false);
        this.dispatch('playbackStarted', true);
        this.dispatch('buffering', true);
        break;

      case "video_start"
      /* VideoStart */
      :
        // Commands don't go through until ads have finished, so we store them and then replay them
        // once the video starts.
        this.remoteControl("muted"
        /* Muted */
        , this.internalState.muted);
        this.remoteControl("volume"
        /* Volume */
        , this.internalState.volume);

        if (this.internalState.currentTime > 0) {
          this.remoteControl("seek"
          /* Seek */
          , this.internalState.currentTime);
        }

        break;

      case "play"
      /* Play */
      :
        this.dispatch('paused', false);
        break;

      case "pause"
      /* Pause */
      :
        this.dispatch('paused', true);
        this.dispatch('playing', false);
        this.dispatch('buffering', false);
        break;

      case "playing"
      /* Playing */
      :
        this.dispatch('playing', true);
        this.dispatch('buffering', false);
        break;

      case "video_end"
      /* VideoEnd */
      :
        if (this.loop) {
          setTimeout(() => {
            this.remoteControl("play"
            /* Play */
            );
          }, 300);
        } else {
          this.dispatch('playbackEnded', true);
        }

        break;

      case "timeupdate"
      /* TimeUpdate */
      :
        this.dispatch('currentTime', parseFloat(msg.time));
        break;

      case "volumechange"
      /* VolumeChange */
      :
        this.dispatch('muted', msg.muted === 'true');
        this.dispatch('volume', Math.floor(parseFloat(msg.volume) * 100));
        break;

      case "seeking"
      /* Seeking */
      :
        this.dispatch('currentTime', parseFloat(msg.time));
        this.dispatch('seeking', true);
        break;

      case "seeked"
      /* Seeked */
      :
        this.dispatch('currentTime', parseFloat(msg.time));
        this.dispatch('seeking', false);
        break;

      case "waiting"
      /* Waiting */
      :
        this.dispatch('buffering', true);
        break;

      case "progress"
      /* Progress */
      :
        this.dispatch('buffered', parseFloat(msg.time));
        break;

      case "durationchange"
      /* DurationChange */
      :
        this.dispatch('duration', parseFloat(msg.duration));
        break;

      case "qualitiesavailable"
      /* QualitiesAvailable */
      :
        this.dispatch('playbackQualities', msg.qualities.map(q => "".concat(q, "p")));
        break;

      case "qualitychange"
      /* QualityChange */
      :
        this.dispatch('playbackQuality', "".concat(msg.quality, "p"));
        break;

      case "fullscreenchange"
      /* FullscreenChange */
      :
        this.dispatch('isFullscreenActive', msg.fullscreen === 'true');
        break;

      case "error"
      /* Error */
      :
        this.vmError.emit(msg.error);
        break;
    }
  }
  /** @internal */


  getAdapter() {
    var _this11 = this;

    return _asyncToGenerator(function* () {
      var canPlayRegex = /(?:dai\.ly|dailymotion|dailymotion\.com)\/(?:video\/|embed\/|)(?:video\/|)((?:\w)+)/;
      return {
        getInternalPlayer: function () {
          var _getInternalPlayer = _asyncToGenerator(function* () {
            return _this11.embed;
          });

          function getInternalPlayer() {
            return _getInternalPlayer.apply(this, arguments);
          }

          return getInternalPlayer;
        }(),
        play: function () {
          var _play = _asyncToGenerator(function* () {
            _this11.remoteControl("play"
            /* Play */
            );
          });

          function play() {
            return _play.apply(this, arguments);
          }

          return play;
        }(),
        pause: function () {
          var _pause = _asyncToGenerator(function* () {
            _this11.remoteControl("pause"
            /* Pause */
            );
          });

          function pause() {
            return _pause.apply(this, arguments);
          }

          return pause;
        }(),
        canPlay: function () {
          var _canPlay = _asyncToGenerator(function* (type) {
            return isString(type) && canPlayRegex.test(type);
          });

          function canPlay(_x9) {
            return _canPlay.apply(this, arguments);
          }

          return canPlay;
        }(),
        setCurrentTime: function () {
          var _setCurrentTime = _asyncToGenerator(function* (time) {
            _this11.internalState.currentTime = time;

            _this11.remoteControl("seek"
            /* Seek */
            , time);
          });

          function setCurrentTime(_x10) {
            return _setCurrentTime.apply(this, arguments);
          }

          return setCurrentTime;
        }(),
        setMuted: function () {
          var _setMuted = _asyncToGenerator(function* (muted) {
            _this11.internalState.muted = muted;

            _this11.remoteControl("muted"
            /* Muted */
            , muted);
          });

          function setMuted(_x11) {
            return _setMuted.apply(this, arguments);
          }

          return setMuted;
        }(),
        setVolume: function () {
          var _setVolume = _asyncToGenerator(function* (volume) {
            _this11.internalState.volume = volume / 100;

            _this11.dispatch('volume', volume);

            _this11.remoteControl("volume"
            /* Volume */
            , volume / 100);
          });

          function setVolume(_x12) {
            return _setVolume.apply(this, arguments);
          }

          return setVolume;
        }(),
        canSetPlaybackQuality: function () {
          var _canSetPlaybackQuality = _asyncToGenerator(function* () {
            return true;
          });

          function canSetPlaybackQuality() {
            return _canSetPlaybackQuality.apply(this, arguments);
          }

          return canSetPlaybackQuality;
        }(),
        setPlaybackQuality: function () {
          var _setPlaybackQuality = _asyncToGenerator(function* (quality) {
            _this11.remoteControl("quality"
            /* Quality */
            , quality.slice(0, -1));
          });

          function setPlaybackQuality(_x13) {
            return _setPlaybackQuality.apply(this, arguments);
          }

          return setPlaybackQuality;
        }(),
        canSetFullscreen: function () {
          var _canSetFullscreen = _asyncToGenerator(function* () {
            return true;
          });

          function canSetFullscreen() {
            return _canSetFullscreen.apply(this, arguments);
          }

          return canSetFullscreen;
        }(),
        enterFullscreen: function () {
          var _enterFullscreen = _asyncToGenerator(function* () {
            _this11.remoteControl("fullscreen"
            /* Fullscreen */
            , true);
          });

          function enterFullscreen() {
            return _enterFullscreen.apply(this, arguments);
          }

          return enterFullscreen;
        }(),
        exitFullscreen: function () {
          var _exitFullscreen = _asyncToGenerator(function* () {
            _this11.remoteControl("fullscreen"
            /* Fullscreen */
            , false);
          });

          function exitFullscreen() {
            return _exitFullscreen.apply(this, arguments);
          }

          return exitFullscreen;
        }()
      };
    })();
  }

  render() {
    return (0, _client.h)("vm-embed", {
      embedSrc: this.embedSrc,
      mediaTitle: this.mediaTitle,
      origin: this.getOrigin(),
      params: this.buildParams(),
      decoder: decodeQueryString,
      preconnections: this.getPreconnections(),
      onVmEmbedMessage: this.onEmbedMessage.bind(this),
      onVmEmbedSrcChange: this.onEmbedSrcChange.bind(this),
      ref: el => {
        this.embed = el;
      }
    });
  }

  static get watchers() {
    return {
      "videoId": ["onVideoIdChange"],
      "controls": ["onControlsChange"],
      "poster": ["onCustomPosterChange"]
    };
  }

  static get style() {
    return dailymotionCss;
  }

};
var dashCss = ":host{z-index:var(--vm-media-z-index)}";
var Dash = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.vmLoadStart = (0, _client.createEvent)(this, "vmLoadStart", 7);
    this.vmError = (0, _client.createEvent)(this, "vmError", 7);
    this.textTracksDisposal = new Disposal();
    this.hasAttached = false;
    /**
     * The NPM package version of the `dashjs` library to download and use.
     */

    this.version = 'latest';
    /**
     * The `dashjs` configuration.
     */

    this.config = {};
    /** @internal */

    this.autoplay = false;
    /** @inheritdoc */

    this.preload = 'metadata';
    /**
     * Are text tracks enabled by default.
     */

    this.enableTextTracksByDefault = true;
    /** @internal */

    this.shouldRenderNativeTextTracks = true;
    /** @internal */

    this.isTextTrackVisible = true;
    /** @internal */

    this.currentTextTrack = -1;
    withComponentRegistry(this);
    withProviderConnect(this);
    withPlayerContext(this, ['autoplay', 'shouldRenderNativeTextTracks', 'isTextTrackVisible', 'currentTextTrack']);
  }

  onSrcChange() {
    if (!this.hasAttached) return;
    this.vmLoadStart.emit();
    this.dash.attachSource(this.src);
  }

  onShouldRenderNativeTextTracks() {
    var _this$dash;

    if (this.shouldRenderNativeTextTracks) {
      this.textTracksDisposal.empty();
    } else {
      this.hideCurrentTextTrack();
    }

    (_this$dash = this.dash) === null || _this$dash === void 0 ? void 0 : _this$dash.enableForcedTextStreaming(!this.shouldRenderNativeTextTracks);
  }

  onTextTrackChange() {
    if (!this.shouldRenderNativeTextTracks || isUndefined(this.dash)) return;
    this.dash.setTextTrack(!this.isTextTrackVisible ? -1 : this.currentTextTrack);

    if (!this.isTextTrackVisible) {
      var _this$mediaEl$textTra, _this$mediaEl;

      var track = Array.from((_this$mediaEl$textTra = (_this$mediaEl = this.mediaEl) === null || _this$mediaEl === void 0 ? void 0 : _this$mediaEl.textTracks) !== null && _this$mediaEl$textTra !== void 0 ? _this$mediaEl$textTra : [])[this.currentTextTrack];
      if ((track === null || track === void 0 ? void 0 : track.mode) === 'hidden') this.dispatch('currentTextTrack', -1);
    }
  }

  connectedCallback() {
    this.dispatch = createProviderDispatcher(this);
    if (this.mediaEl) this.setupDash();
  }

  disconnectedCallback() {
    this.textTracksDisposal.empty();
    this.destroyDash();
  }

  setupDash() {
    var _this12 = this;

    return _asyncToGenerator(function* () {
      try {
        var url = _this12.libSrc || "https://cdn.jsdelivr.net/npm/dashjs@".concat(_this12.version, "/dist/dash.all.min.js"); // eslint-disable-next-line no-shadow

        var DashSDK = yield loadSDK(url, 'dashjs');
        _this12.dash = DashSDK.MediaPlayer(_this12.config).create();

        _this12.dash.initialize(_this12.mediaEl, null, _this12.autoplay);

        _this12.dash.setTextDefaultEnabled(_this12.enableTextTracksByDefault);

        _this12.dash.enableForcedTextStreaming(!_this12.shouldRenderNativeTextTracks);

        _this12.dash.on(DashSDK.MediaPlayer.events.PLAYBACK_METADATA_LOADED, () => {
          _this12.dispatch('mediaType', MediaType.Video);

          _this12.dispatch('currentSrc', _this12.src);

          _this12.dispatchLevels();

          _this12.listenToTextTracksForChanges();

          _this12.dispatch('playbackReady', true);
        });

        _this12.dash.on(DashSDK.MediaPlayer.events.TRACK_CHANGE_RENDERED, () => {
          if (!_this12.shouldRenderNativeTextTracks) _this12.hideCurrentTextTrack();
        });

        _this12.dash.on(DashSDK.MediaPlayer.events.ERROR, e => {
          _this12.vmError.emit(e);
        });

        _this12.hasAttached = true;
      } catch (e) {
        _this12.vmError.emit(e);
      }
    })();
  }

  destroyDash() {
    var _this13 = this;

    return _asyncToGenerator(function* () {
      var _this13$dash;

      (_this13$dash = _this13.dash) === null || _this13$dash === void 0 ? void 0 : _this13$dash.reset();
      _this13.hasAttached = false;
    })();
  }

  onMediaElChange(event) {
    var _this14 = this;

    return _asyncToGenerator(function* () {
      _this14.destroyDash();

      if (isUndefined(event.detail)) return;
      _this14.mediaEl = event.detail;
      yield _this14.setupDash();
    })();
  }

  levelToPlaybackQuality(level) {
    return level === -1 ? 'Auto' : "".concat(level.height, "p");
  }

  findLevelIndexFromQuality(quality) {
    return this.dash.getBitrateInfoListFor('video').findIndex(level => this.levelToPlaybackQuality(level) === quality);
  }

  dispatchLevels() {
    try {
      var levels = this.dash.getBitrateInfoListFor('video');

      if ((levels === null || levels === void 0 ? void 0 : levels.length) > 0) {
        this.dispatch('playbackQualities', ['Auto', ...levels.map(this.levelToPlaybackQuality)]);
        this.dispatch('playbackQuality', 'Auto');
      }
    } catch (e) {
      this.vmError.emit(e);
    }
  }

  listenToTextTracksForChanges() {
    var _ref6, _this$dash2, _this$dash2$getCurren;

    this.textTracksDisposal.empty();
    if (isUndefined(this.mediaEl) || this.shouldRenderNativeTextTracks) return; // Init current track.

    var currentTrack = (_ref6 = ((_this$dash2 = this.dash) === null || _this$dash2 === void 0 ? void 0 : (_this$dash2$getCurren = _this$dash2.getCurrentTrackFor('text')) === null || _this$dash2$getCurren === void 0 ? void 0 : _this$dash2$getCurren.index) - 1) !== null && _ref6 !== void 0 ? _ref6 : -1;
    this.currentTextTrack = currentTrack;
    this.dispatch('currentTextTrack', currentTrack);
    this.textTracksDisposal.add(listen(this.mediaEl.textTracks, 'change', this.onTextTracksChange.bind(this)));
  }

  getTextTracks() {
    var _this$mediaEl$textTra2, _this$mediaEl2;

    return Array.from((_this$mediaEl$textTra2 = (_this$mediaEl2 = this.mediaEl) === null || _this$mediaEl2 === void 0 ? void 0 : _this$mediaEl2.textTracks) !== null && _this$mediaEl$textTra2 !== void 0 ? _this$mediaEl$textTra2 : []);
  }

  hideCurrentTextTrack() {
    var textTracks = this.getTextTracks();

    if (textTracks[this.currentTextTrack] && this.isTextTrackVisible) {
      textTracks[this.currentTextTrack].mode = 'hidden';
    }
  }

  onTextTracksChange() {
    this.hideCurrentTextTrack();
    this.dispatch('textTracks', this.getTextTracks());
    this.dispatch('isTextTrackVisible', this.isTextTrackVisible);
    this.dispatch('currentTextTrack', this.currentTextTrack);
  }
  /** @internal */


  getAdapter() {
    var _this15 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this15$videoP, _this15$videoProvider;

      var adapter = (_yield$_this15$videoP = yield (_this15$videoProvider = _this15.videoProvider) === null || _this15$videoProvider === void 0 ? void 0 : _this15$videoProvider.getAdapter()) !== null && _yield$_this15$videoP !== void 0 ? _yield$_this15$videoP : {};
      var canVideoProviderPlay = adapter.canPlay;
      return _objectSpread(_objectSpread({}, adapter), {}, {
        getInternalPlayer: function () {
          var _getInternalPlayer2 = _asyncToGenerator(function* () {
            return _this15.dash;
          });

          function getInternalPlayer() {
            return _getInternalPlayer2.apply(this, arguments);
          }

          return getInternalPlayer;
        }(),
        canPlay: function () {
          var _canPlay2 = _asyncToGenerator(function* (type) {
            var _canVideoProviderPlay;

            return isString(type) && dashRegex.test(type) || ((_canVideoProviderPlay = canVideoProviderPlay === null || canVideoProviderPlay === void 0 ? void 0 : canVideoProviderPlay(type)) !== null && _canVideoProviderPlay !== void 0 ? _canVideoProviderPlay : false);
          });

          function canPlay(_x14) {
            return _canPlay2.apply(this, arguments);
          }

          return canPlay;
        }(),
        canSetPlaybackQuality: function () {
          var _canSetPlaybackQuality2 = _asyncToGenerator(function* () {
            try {
              var _this15$dash, _this15$dash$getBitra;

              return ((_this15$dash = _this15.dash) === null || _this15$dash === void 0 ? void 0 : (_this15$dash$getBitra = _this15$dash.getBitrateInfoListFor('video')) === null || _this15$dash$getBitra === void 0 ? void 0 : _this15$dash$getBitra.length) > 0;
            } catch (e) {
              _this15.vmError.emit(e);

              return false;
            }
          });

          function canSetPlaybackQuality() {
            return _canSetPlaybackQuality2.apply(this, arguments);
          }

          return canSetPlaybackQuality;
        }(),
        setPlaybackQuality: function () {
          var _setPlaybackQuality2 = _asyncToGenerator(function* (quality) {
            if (!isUndefined(_this15.dash)) {
              var index = _this15.findLevelIndexFromQuality(quality);

              _this15.dash.updateSettings({
                streaming: {
                  abr: {
                    autoSwitchBitrate: {
                      video: index === -1
                    }
                  }
                }
              });

              if (index >= 0) _this15.dash.setQualityFor('video', index); // Update the provider cache.

              _this15.dispatch('playbackQuality', quality);
            }
          });

          function setPlaybackQuality(_x15) {
            return _setPlaybackQuality2.apply(this, arguments);
          }

          return setPlaybackQuality;
        }(),
        setCurrentTextTrack: function () {
          var _setCurrentTextTrack = _asyncToGenerator(function* (trackId) {
            if (_this15.shouldRenderNativeTextTracks) {
              adapter.setCurrentTextTrack(trackId);
            } else {
              var _this15$dash2;

              _this15.currentTextTrack = trackId;
              (_this15$dash2 = _this15.dash) === null || _this15$dash2 === void 0 ? void 0 : _this15$dash2.setTextTrack(trackId);

              _this15.onTextTracksChange();
            }
          });

          function setCurrentTextTrack(_x16) {
            return _setCurrentTextTrack.apply(this, arguments);
          }

          return setCurrentTextTrack;
        }(),
        setTextTrackVisibility: function () {
          var _setTextTrackVisibility = _asyncToGenerator(function* (isVisible) {
            if (_this15.shouldRenderNativeTextTracks) {
              adapter.setTextTrackVisibility(isVisible);
            } else {
              var _this15$dash3;

              _this15.isTextTrackVisible = isVisible;
              (_this15$dash3 = _this15.dash) === null || _this15$dash3 === void 0 ? void 0 : _this15$dash3.enableText(isVisible);

              _this15.onTextTracksChange();
            }
          });

          function setTextTrackVisibility(_x17) {
            return _setTextTrackVisibility.apply(this, arguments);
          }

          return setTextTrackVisibility;
        }()
      });
    })();
  }

  render() {
    return (0, _client.h)("vm-video", {
      willAttach: true,
      crossOrigin: this.crossOrigin,
      preload: this.preload,
      poster: this.poster,
      controlsList: this.controlsList,
      autoPiP: this.autoPiP,
      disablePiP: this.disablePiP,
      hasCustomTextManager: !this.shouldRenderNativeTextTracks,
      disableRemotePlayback: this.disableRemotePlayback,
      mediaTitle: this.mediaTitle,
      ref: el => {
        this.videoProvider = el;
      }
    });
  }

  static get watchers() {
    return {
      "src": ["onSrcChange"],
      "hasAttached": ["onSrcChange"],
      "shouldRenderNativeTextTracks": ["onShouldRenderNativeTextTracks"],
      "isTextTrackVisible": ["onTextTrackChange"],
      "currentTextTrack": ["onTextTrackChange"]
    };
  }

  static get style() {
    return dashCss;
  }

};
var dblClickFullscreenCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--vm-dbl-click-fullscreen-z-index)}.dblClickFullscreen{display:none;width:100%;height:100%;pointer-events:none}.dblClickFullscreen.enabled{display:inline-block;pointer-events:auto}";
var DblClickFullscreen = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.canSetFullscreen = false;
    /**
     * By default this is disabled on mobile to not interfere with playback, set this to `true` to
     * enable it.
     */

    this.useOnMobile = false;
    /** @internal */

    this.isFullscreenActive = true;
    /** @internal */

    this.isVideoView = false;
    /** @internal */

    this.playbackReady = false;
    /** @internal */

    this.isMobile = false;
    this.clicks = 0;
    withComponentRegistry(this);
    withPlayerContext(this, ['playbackReady', 'isFullscreenActive', 'isVideoView', 'isMobile']);
  }

  onPlaybackReadyChange() {
    var _this16 = this;

    return _asyncToGenerator(function* () {
      var player = yield findPlayer(_this16);
      _this16.canSetFullscreen = yield player.canSetFullscreen();
    })();
  }

  onTriggerClickToPlay() {
    var _this17 = this;

    return _asyncToGenerator(function* () {
      var [clickToPlay] = getComponentFromRegistry(_this17, 'vm-click-to-play');
      yield clickToPlay === null || clickToPlay === void 0 ? void 0 : clickToPlay.forceClick();
    })();
  }

  onToggleFullscreen() {
    var _this18 = this;

    return _asyncToGenerator(function* () {
      var player = yield findPlayer(_this18);
      _this18.isFullscreenActive ? player.exitFullscreen() : player.enterFullscreen();
    })();
  }

  onClick() {
    this.clicks += 1;

    if (this.clicks === 1) {
      setTimeout(() => {
        if (this.clicks === 1) {
          this.onTriggerClickToPlay();
        } else {
          this.onToggleFullscreen();
        }

        this.clicks = 0;
      }, 300);
    }
  }

  render() {
    return (0, _client.h)("div", {
      class: {
        dblClickFullscreen: true,
        enabled: this.playbackReady && this.canSetFullscreen && this.isVideoView && (!this.isMobile || this.useOnMobile)
      },
      onClick: this.onClick.bind(this)
    });
  }

  static get watchers() {
    return {
      "playbackReady": ["onPlaybackReadyChange"]
    };
  }

  static get style() {
    return dblClickFullscreenCss;
  }

};
var defaultControlsCss = ":host{display:contents;pointer-events:none;z-index:var(--vm-controls-z-index)}";
var DefaultControls = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    /**
     * The length in milliseconds that the controls are active for before fading out. Audio players
     * are not effected by this prop.
     */

    this.activeDuration = 2750;
    /**
     * Whether the controls should wait for playback to start before being shown. Audio players
     * are not effected by this prop.
     */

    this.waitForPlaybackStart = false;
    /**
     * Whether the controls should show/hide when paused. Audio players are not effected by this prop.
     */

    this.hideWhenPaused = false;
    /**
     * Whether the controls should hide when the mouse leaves the player. Audio players are not
     * effected by this prop.
     */

    this.hideOnMouseLeave = false;
    /** @internal */

    this.isMobile = false;
    /** @internal */

    this.isLive = false;
    /** @internal */

    this.isAudioView = false;
    /** @internal */

    this.isVideoView = false;
    withComponentRegistry(this);
    withPlayerContext(this, ['theme', 'isMobile', 'isAudioView', 'isVideoView', 'isLive']);
  }

  buildAudioControls() {
    return (0, _client.h)("vm-controls", {
      fullWidth: true
    }, (0, _client.h)("vm-playback-control", {
      tooltipDirection: "right"
    }), (0, _client.h)("vm-volume-control", null), !this.isLive && (0, _client.h)("vm-current-time", null), this.isLive && (0, _client.h)("vm-control-spacer", null), !this.isLive && (0, _client.h)("vm-scrubber-control", null), this.isLive && (0, _client.h)("vm-live-indicator", null), !this.isLive && (0, _client.h)("vm-end-time", null), !this.isLive && (0, _client.h)("vm-settings-control", {
      tooltipDirection: "left"
    }), (0, _client.h)("div", {
      style: {
        marginLeft: '0',
        paddingRight: '2px'
      }
    }));
  }

  buildMobileVideoControls() {
    return (0, _client.h)(_client.Fragment, null, (0, _client.h)("vm-scrim", {
      gradient: "up"
    }), (0, _client.h)("vm-controls", {
      pin: "topLeft",
      fullWidth: true,
      activeDuration: this.activeDuration,
      waitForPlaybackStart: this.waitForPlaybackStart,
      hideWhenPaused: this.hideWhenPaused
    }, (0, _client.h)("vm-control-spacer", null), (0, _client.h)("vm-volume-control", null), !this.isLive && (0, _client.h)("vm-caption-control", null), !this.isLive && (0, _client.h)("vm-settings-control", null), this.isLive && (0, _client.h)("vm-fullscreen-control", null)), (0, _client.h)("vm-controls", {
      pin: "center",
      justify: "center",
      activeDuration: this.activeDuration,
      waitForPlaybackStart: this.waitForPlaybackStart,
      hideWhenPaused: this.hideWhenPaused
    }, (0, _client.h)("vm-playback-control", {
      style: {
        '--vm-control-scale': '1.3'
      }
    })), !this.isLive && (0, _client.h)("vm-controls", {
      pin: "bottomLeft",
      fullWidth: true,
      activeDuration: this.activeDuration,
      waitForPlaybackStart: this.waitForPlaybackStart,
      hideWhenPaused: this.hideWhenPaused
    }, (0, _client.h)("vm-control-group", null, (0, _client.h)("vm-current-time", null), (0, _client.h)("vm-control-spacer", null), (0, _client.h)("vm-end-time", null), (0, _client.h)("vm-fullscreen-control", null)), (0, _client.h)("vm-control-group", {
      space: "top"
    }, (0, _client.h)("vm-scrubber-control", null))));
  }

  buildDesktopVideoControls() {
    return (0, _client.h)(_client.Fragment, null, this.theme !== 'light' && (0, _client.h)("vm-scrim", {
      gradient: "up"
    }), (0, _client.h)("vm-controls", {
      fullWidth: true,
      pin: "bottomRight",
      activeDuration: this.activeDuration,
      waitForPlaybackStart: this.waitForPlaybackStart,
      hideWhenPaused: this.hideWhenPaused,
      hideOnMouseLeave: this.hideOnMouseLeave
    }, !this.isLive && (0, _client.h)("vm-control-group", null, (0, _client.h)("vm-scrubber-control", null)), (0, _client.h)("vm-control-group", {
      space: this.isLive ? 'none' : 'top'
    }, (0, _client.h)("vm-playback-control", {
      tooltipDirection: "right"
    }), (0, _client.h)("vm-volume-control", null), !this.isLive && (0, _client.h)("vm-time-progress", null), (0, _client.h)("vm-control-spacer", null), !this.isLive && (0, _client.h)("vm-caption-control", null), this.isLive && (0, _client.h)("vm-live-indicator", null), (0, _client.h)("vm-pip-control", null), !this.isLive && (0, _client.h)("vm-settings-control", null), (0, _client.h)("vm-fullscreen-control", {
      tooltipDirection: "left"
    }))));
  }

  render() {
    if (this.isAudioView) return this.buildAudioControls();
    if (this.isVideoView && this.isMobile) return this.buildMobileVideoControls();
    if (this.isVideoView) return this.buildDesktopVideoControls();
    return null;
  }

  static get style() {
    return defaultControlsCss;
  }

};
var defaultSettingsCss = ":host{z-index:var(--vm-menu-z-index)}";
var DefaultSettings = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.textTracksDisposal = new Disposal();
    this.canSetPlaybackRate = false;
    this.canSetPlaybackQuality = false;
    this.canSetTextTrack = false;
    this.canSetAudioTrack = false;
    /**
     * Pins the settings to the defined position inside the video player. This has no effect when
     * the view is of type `audio`, it will always be `bottomRight`.
     */

    this.pin = 'bottomRight';
    /** @internal */

    this.i18n = {};
    /** @internal */

    this.playbackReady = false;
    /** @internal */

    this.playbackRate = 1;
    /** @internal */

    this.playbackRates = [1];
    /** @internal */

    this.isVideoView = false;
    /** @internal */

    this.playbackQualities = [];
    /** @internal */

    this.textTracks = [];
    /** @internal */

    this.currentTextTrack = -1;
    /** @internal */

    this.audioTracks = [];
    /** @internal */

    this.currentAudioTrack = -1;
    /** @internal */

    this.isTextTrackVisible = true;
    withComponentRegistry(this);
    withPlayerContext(this, ['i18n', 'playbackReady', 'playbackRate', 'playbackRates', 'playbackQuality', 'playbackQualities', 'isVideoView', 'textTracks', 'currentTextTrack', 'isTextTrackVisible', 'audioTracks', 'currentAudioTrack']);
  }

  onPlaybackReady() {
    var _this19 = this;

    return _asyncToGenerator(function* () {
      var player = yield findPlayer(_this19);
      _this19.canSetPlaybackQuality = yield player.canSetPlaybackQuality();
      _this19.canSetPlaybackRate = yield player.canSetPlaybackRate();
    })();
  }

  onAudioTracksChange() {
    var _this20 = this;

    return _asyncToGenerator(function* () {
      var _yield$player$canSetA;

      var player = getPlayerFromRegistry(_this20);
      _this20.canSetAudioTrack = (_yield$player$canSetA = yield player === null || player === void 0 ? void 0 : player.canSetAudioTrack()) !== null && _yield$player$canSetA !== void 0 ? _yield$player$canSetA : false;
    })();
  }

  onTextTracksChange() {
    var _this21 = this;

    return _asyncToGenerator(function* () {
      var _yield$player$canSetT2;

      var player = getPlayerFromRegistry(_this21);
      _this21.canSetTextTrack = (_yield$player$canSetT2 = yield player === null || player === void 0 ? void 0 : player.canSetTextTrack()) !== null && _yield$player$canSetT2 !== void 0 ? _yield$player$canSetT2 : false;
    })();
  }

  connectedCallback() {
    this.dispatch = createDispatcher(this);
  }

  componentDidLoad() {
    this.onTextTracksChange();
  }

  disconnectedCallback() {
    this.textTracksDisposal.empty();
  }

  onPlaybackRateSelect(event) {
    var radio = event.target;
    this.dispatch('playbackRate', parseFloat(radio.value));
  }

  buildPlaybackRateSubmenu() {
    if (this.playbackRates.length <= 1 || !this.canSetPlaybackRate) {
      return (0, _client.h)("vm-menu-item", {
        label: this.i18n.playbackRate,
        hint: this.i18n.normal
      });
    }

    var formatRate = rate => rate === 1 ? this.i18n.normal : "".concat(rate);

    return (0, _client.h)("vm-submenu", {
      label: this.i18n.playbackRate,
      hint: formatRate(this.playbackRate)
    }, (0, _client.h)("vm-menu-radio-group", {
      value: "".concat(this.playbackRate),
      onVmCheck: this.onPlaybackRateSelect.bind(this)
    }, this.playbackRates.map(rate => (0, _client.h)("vm-menu-radio", {
      label: formatRate(rate),
      value: "".concat(rate)
    }))));
  }

  onPlaybackQualitySelect(event) {
    var radio = event.target;
    this.dispatch('playbackQuality', radio.value);
  }

  buildPlaybackQualitySubmenu() {
    if (this.playbackQualities.length <= 1 || !this.canSetPlaybackQuality) {
      var _this$playbackQuality;

      return (0, _client.h)("vm-menu-item", {
        label: this.i18n.playbackQuality,
        hint: (_this$playbackQuality = this.playbackQuality) !== null && _this$playbackQuality !== void 0 ? _this$playbackQuality : this.i18n.auto
      });
    } // @TODO this doesn't account for audio qualities yet.


    var getBadge = quality => {
      var verticalPixels = parseInt(quality.slice(0, -1), 10);
      if (verticalPixels >= 2160) return 'UHD';
      if (verticalPixels >= 1080) return 'HD';
      return undefined;
    };

    return (0, _client.h)("vm-submenu", {
      label: this.i18n.playbackQuality,
      hint: this.playbackQuality
    }, (0, _client.h)("vm-menu-radio-group", {
      value: this.playbackQuality,
      onVmCheck: this.onPlaybackQualitySelect.bind(this)
    }, this.playbackQualities.map(quality => (0, _client.h)("vm-menu-radio", {
      label: quality,
      value: quality,
      badge: getBadge(quality)
    }))));
  }

  onTextTrackSelect(event) {
    var radio = event.target;
    var trackId = parseInt(radio.value, 10);
    var player = getPlayerFromRegistry(this);

    if (trackId === -1) {
      player === null || player === void 0 ? void 0 : player.setTextTrackVisibility(false);
      return;
    }

    player === null || player === void 0 ? void 0 : player.setTextTrackVisibility(true);
    player === null || player === void 0 ? void 0 : player.setCurrentTextTrack(trackId);
  }

  buildTextTracksSubmenu() {
    var _this$textTracks$this3;

    if (this.textTracks.length <= 1 || !this.canSetTextTrack) {
      var _this$textTracks$this, _this$textTracks$this2;

      return (0, _client.h)("vm-menu-item", {
        label: this.i18n.subtitlesOrCc,
        hint: (_this$textTracks$this = (_this$textTracks$this2 = this.textTracks[this.currentTextTrack]) === null || _this$textTracks$this2 === void 0 ? void 0 : _this$textTracks$this2.label) !== null && _this$textTracks$this !== void 0 ? _this$textTracks$this : this.i18n.none
      });
    }

    return (0, _client.h)("vm-submenu", {
      label: this.i18n.subtitlesOrCc,
      hint: this.isTextTrackVisible ? (_this$textTracks$this3 = this.textTracks[this.currentTextTrack]) === null || _this$textTracks$this3 === void 0 ? void 0 : _this$textTracks$this3.label : this.i18n.off
    }, (0, _client.h)("vm-menu-radio-group", {
      value: "".concat(!this.isTextTrackVisible ? -1 : this.currentTextTrack),
      onVmCheck: this.onTextTrackSelect.bind(this)
    }, [(0, _client.h)("vm-menu-radio", {
      label: this.i18n.off,
      value: "-1"
    })].concat(this.textTracks.map((track, i) => (0, _client.h)("vm-menu-radio", {
      label: track.label,
      value: "".concat(i)
    })))));
  }

  onAudioTrackSelect(event) {
    var radio = event.target;
    var trackId = parseInt(radio.value, 10);
    var player = getPlayerFromRegistry(this);
    player === null || player === void 0 ? void 0 : player.setCurrentAudioTrack(trackId);
  }

  buildAudioTracksMenu() {
    var _this$audioTracks$thi3;

    if (this.audioTracks.length <= 1 || !this.canSetAudioTrack) {
      var _this$audioTracks$thi, _this$audioTracks$thi2;

      return (0, _client.h)("vm-menu-item", {
        label: this.i18n.audio,
        hint: (_this$audioTracks$thi = (_this$audioTracks$thi2 = this.audioTracks[this.currentAudioTrack]) === null || _this$audioTracks$thi2 === void 0 ? void 0 : _this$audioTracks$thi2.label) !== null && _this$audioTracks$thi !== void 0 ? _this$audioTracks$thi : this.i18n.default
      });
    }

    return (0, _client.h)("vm-submenu", {
      label: this.i18n.audio,
      hint: (_this$audioTracks$thi3 = this.audioTracks[this.currentAudioTrack]) === null || _this$audioTracks$thi3 === void 0 ? void 0 : _this$audioTracks$thi3.label
    }, (0, _client.h)("vm-menu-radio-group", {
      value: "".concat(this.currentAudioTrack),
      onVmCheck: this.onAudioTrackSelect.bind(this)
    }, this.audioTracks.map((track, i) => (0, _client.h)("vm-menu-radio", {
      label: track.label,
      value: "".concat(i)
    }))));
  }

  render() {
    return (0, _client.h)("vm-settings", {
      pin: this.pin
    }, this.buildAudioTracksMenu(), this.buildPlaybackRateSubmenu(), this.buildPlaybackQualitySubmenu(), this.isVideoView && this.buildTextTracksSubmenu(), (0, _client.h)("slot", null));
  }

  static get watchers() {
    return {
      "playbackReady": ["onPlaybackReady", "onAudioTracksChange", "onTextTracksChange"],
      "audioTracks": ["onAudioTracksChange"],
      "textTracks": ["onTextTracksChange"]
    };
  }

  static get style() {
    return defaultSettingsCss;
  }

};
var defaultUiCss = ":host{display:contents;pointer-events:none}";
var DefaultUI = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    /**
     * Whether clicking the player should not toggle playback.
     */

    this.noClickToPlay = false;
    /**
     * Whether double clicking the player should not toggle fullscreen mode.
     */

    this.noDblClickFullscreen = false;
    /**
     * Whether the custom captions UI should not be loaded.
     */

    this.noCaptions = false;
    /**
     * Whether the custom poster UI should not be loaded.
     */

    this.noPoster = false;
    /**
     * Whether the custom spinner UI should not be loaded.
     */

    this.noSpinner = false;
    /**
     * Whether the custom default controls should not be loaded.
     */

    this.noControls = false;
    /**
     * Whether the custom default settings menu should not be loaded.
     */

    this.noSettings = false;
    /**
     * Whether the default loading screen should not be loaded.
     */

    this.noLoadingScreen = false;
    withComponentRegistry(this);
  }

  render() {
    return (0, _client.h)("vm-ui", null, !this.noClickToPlay && (0, _client.h)("vm-click-to-play", null), !this.noDblClickFullscreen && (0, _client.h)("vm-dbl-click-fullscreen", null), !this.noCaptions && (0, _client.h)("vm-captions", null), !this.noPoster && (0, _client.h)("vm-poster", null), !this.noSpinner && (0, _client.h)("vm-spinner", null), !this.noLoadingScreen && (0, _client.h)("vm-loading-screen", null), !this.noControls && (0, _client.h)("vm-default-controls", null), !this.noSettings && (0, _client.h)("vm-default-settings", null), (0, _client.h)("slot", null));
  }

  static get style() {
    return defaultUiCss;
  }

};

class LazyLoader {
  constructor(el, attributes, onLoad) {
    var _this$mutationObs;

    this.el = el;
    this.attributes = attributes;
    this.onLoad = onLoad;
    this.hasLoaded = false;
    if (isNullOrUndefined(this.el)) return;
    this.intersectionObs = this.canObserveIntersection() ? new IntersectionObserver(this.onIntersection.bind(this)) : undefined;
    this.mutationObs = this.canObserveMutations() ? new MutationObserver(this.onMutation.bind(this)) : undefined;
    (_this$mutationObs = this.mutationObs) === null || _this$mutationObs === void 0 ? void 0 : _this$mutationObs.observe(this.el, {
      childList: true,
      subtree: true,
      attributeFilter: this.attributes
    });
    this.lazyLoad();
  }

  didLoad() {
    return this.hasLoaded;
  }

  destroy() {
    var _this$intersectionObs, _this$mutationObs2;

    (_this$intersectionObs = this.intersectionObs) === null || _this$intersectionObs === void 0 ? void 0 : _this$intersectionObs.disconnect();
    (_this$mutationObs2 = this.mutationObs) === null || _this$mutationObs2 === void 0 ? void 0 : _this$mutationObs2.disconnect();
  }

  canObserveIntersection() {
    return IS_CLIENT && window.IntersectionObserver;
  }

  canObserveMutations() {
    return IS_CLIENT && window.MutationObserver;
  }

  lazyLoad() {
    if (this.canObserveIntersection()) {
      var _this$intersectionObs2;

      (_this$intersectionObs2 = this.intersectionObs) === null || _this$intersectionObs2 === void 0 ? void 0 : _this$intersectionObs2.observe(this.el);
    } else {
      this.load();
    }
  }

  onIntersection(entries) {
    entries.forEach(entry => {
      if (entry.intersectionRatio > 0 || entry.isIntersecting) {
        this.load();
        this.intersectionObs.unobserve(entry.target);
      }
    });
  }

  onMutation() {
    if (this.hasLoaded) this.load();
  }

  getLazyElements() {
    var root = !isNullOrUndefined(this.el.shadowRoot) ? this.el.shadowRoot : this.el;
    return root.querySelectorAll('.lazy');
  }

  load() {
    window.requestAnimationFrame(() => {
      this.getLazyElements().forEach(this.loadEl.bind(this));
    });
  }

  loadEl(el) {
    var _this$intersectionObs3, _this$onLoad;

    (_this$intersectionObs3 = this.intersectionObs) === null || _this$intersectionObs3 === void 0 ? void 0 : _this$intersectionObs3.unobserve(el);
    this.hasLoaded = true;
    (_this$onLoad = this.onLoad) === null || _this$onLoad === void 0 ? void 0 : _this$onLoad.call(this, el);
  }

}

var embedCss = ":host{z-index:var(--vm-media-z-index)}iframe{position:absolute;top:0;left:0;border:0;width:100%;height:100%;user-select:none}";
var idCount = 0;
var connected = new Set();
var Embed = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.vmEmbedSrcChange = (0, _client.createEvent)(this, "vmEmbedSrcChange", 3);
    this.vmEmbedMessage = (0, _client.createEvent)(this, "vmEmbedMessage", 3);
    this.vmEmbedLoaded = (0, _client.createEvent)(this, "vmEmbedLoaded", 3);
    this.srcWithParams = '';
    this.hasEnteredViewport = false;
    /**
     * A URL that will load the external player and media (Eg: https://www.youtube.com/embed/DyTCOwB0DVw).
     */

    this.embedSrc = '';
    /**
     * The title of the current media so it can be set on the inner `iframe` for screen readers.
     */

    this.mediaTitle = '';
    /**
     * The parameters to pass to the embedded player which are appended to the `embedSrc` prop. These
     * can be passed in as a query string or object.
     */

    this.params = '';
    /**
     * A collection of URLs to that the browser should immediately start establishing a connection
     * with.
     */

    this.preconnections = [];
    withComponentRegistry(this);
  }

  onEmbedSrcChange() {
    this.srcWithParams = isString(this.embedSrc) && this.embedSrc.length > 0 ? appendParamsToURL(this.embedSrc, this.params) : undefined;
  }

  srcWithParamsChange() {
    if (isUndefined(this.srcWithParams)) {
      this.vmEmbedSrcChange.emit(this.srcWithParams);
      return;
    }

    if (!this.hasEnteredViewport && !connected.has(this.embedSrc)) {
      if (preconnect(this.srcWithParams)) connected.add(this.embedSrc);
    }

    this.vmEmbedSrcChange.emit(this.srcWithParams);
  }

  preconnectionsChange() {
    if (this.hasEnteredViewport) {
      return;
    }

    this.preconnections.filter(connection => !connected.has(connection)).forEach(connection => {
      if (preconnect(connection)) connected.add(connection);
    });
  }

  connectedCallback() {
    this.lazyLoader = new LazyLoader(this.host, ['data-src'], el => {
      var src = el.getAttribute('data-src');
      el.removeAttribute('src');
      if (!isNull(src)) el.setAttribute('src', src);
    });
    this.onEmbedSrcChange();
    this.genIframeId();
  }

  disconnectedCallback() {
    this.lazyLoader.destroy();
  }

  onWindowMessage(e) {
    var _this$iframe, _this$decoder, _this$decoder2;

    var originMatches = e.source === ((_this$iframe = this.iframe) === null || _this$iframe === void 0 ? void 0 : _this$iframe.contentWindow) && (!isString(this.origin) || this.origin === e.origin);
    if (!originMatches) return;
    var message = (_this$decoder = (_this$decoder2 = this.decoder) === null || _this$decoder2 === void 0 ? void 0 : _this$decoder2.call(this, e.data)) !== null && _this$decoder !== void 0 ? _this$decoder : e.data;
    if (message) this.vmEmbedMessage.emit(message);
  }
  /**
   * Posts a message to the embedded media player.
   */


  postMessage(message, target) {
    var _this22 = this;

    return _asyncToGenerator(function* () {
      var _this22$iframe, _this22$iframe$conten;

      (_this22$iframe = _this22.iframe) === null || _this22$iframe === void 0 ? void 0 : (_this22$iframe$conten = _this22$iframe.contentWindow) === null || _this22$iframe$conten === void 0 ? void 0 : _this22$iframe$conten.postMessage(JSON.stringify(message), target !== null && target !== void 0 ? target : '*');
    })();
  }

  onLoad() {
    this.vmEmbedLoaded.emit();
  }

  genIframeId() {
    idCount += 1;
    this.id = "vm-iframe-".concat(idCount);
  }

  render() {
    return (0, _client.h)("iframe", {
      id: this.id,
      class: "lazy",
      title: this.mediaTitle,
      "data-src": this.srcWithParams,
      allowFullScreen: true,
      allow: "autoplay; encrypted-media; picture-in-picture;",
      onLoad: this.onLoad.bind(this),
      ref: el => {
        this.iframe = el;
      }
    });
  }

  get host() {
    return this;
  }

  static get watchers() {
    return {
      "embedSrc": ["onEmbedSrcChange"],
      "params": ["onEmbedSrcChange"],
      "srcWithParams": ["srcWithParamsChange"],
      "preconnections": ["preconnectionsChange"]
    };
  }

  static get style() {
    return embedCss;
  }

};
var endTimeCss = ":host{display:flex;align-items:center;justify-content:center}";
var EndTime = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    /** @internal */

    this.duration = -1;
    /** @internal */

    this.i18n = {};
    /**
     * Whether the time should always show the hours unit, even if the time is less than
     * 1 hour (eg: `20:35` -> `00:20:35`).
     */

    this.alwaysShowHours = false;
    withComponentRegistry(this);
    withPlayerContext(this, ['duration', 'i18n']);
  }

  render() {
    return (0, _client.h)("vm-time", {
      label: this.i18n.duration,
      seconds: Math.max(0, this.duration),
      alwaysShowHours: this.alwaysShowHours
    });
  }

  static get style() {
    return endTimeCss;
  }

};
var fileCss = "audio.sc-vm-file,video.sc-vm-file{border-radius:inherit;vertical-align:middle;width:100%;outline:0}video.sc-vm-file{position:absolute;top:0;left:0;border:0;height:100%;user-select:none}";
var File = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    this.vmLoadStart = (0, _client.createEvent)(this, "vmLoadStart", 7);
    this.vmError = (0, _client.createEvent)(this, "vmError", 7);
    this.vmMediaElChange = (0, _client.createEvent)(this, "vmMediaElChange", 7);
    this.vmSrcSetChange = (0, _client.createEvent)(this, "vmSrcSetChange", 7);
    this.textTracksDisposal = new Disposal();
    this.wasPausedBeforeSeeking = true;
    this.currentSrcSet = [];
    this.mediaQueryDisposal = new Disposal();
    /** @internal Whether an external SDK will attach itself to the media player and control it. */

    this.willAttach = false;
    /** @inheritdoc */

    this.preload = 'metadata';
    /**
     * The playback rates that are available for this media.
     */

    this.playbackRates = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 2];
    /** @internal */

    this.language = 'en';
    /** @internal */

    this.autoplay = false;
    /** @internal */

    this.controls = false;
    /** @internal */

    this.loop = false;
    /** @internal */

    this.muted = false;
    /** @internal */

    this.playsinline = false;
    /** @internal */

    this.noConnect = false;
    /** @internal */

    this.paused = true;
    /** @internal */

    this.currentTime = 0;
    /** @internal */

    this.volume = 0;
    /** @internal */

    this.playbackReady = false;
    /** @internal */

    this.playbackStarted = false;
    /** @internal */

    this.currentTextTrack = -1;
    /** @internal */

    this.hasCustomTextManager = false;
    /** @internal */

    this.isTextTrackVisible = true;
    /** @internal */

    this.shouldRenderNativeTextTracks = true;
    withComponentRegistry(this);
    withProviderConnect(this);
    withProviderContext(this, ['playbackReady', 'playbackStarted', 'currentTime', 'volume', 'paused', 'currentTextTrack', 'isTextTrackVisible', 'shouldRenderNativeTextTracks']);
    watchComponentRegistry(this, 'vm-poster', regs => {
      [this.vmPoster] = regs;
    });
  }

  onMediaTitleChange() {
    this.dispatch('mediaTitle', this.mediaTitle);
  }

  onPosterChange() {
    var _this$mediaEl3;

    if (!this.playbackStarted) (_this$mediaEl3 = this.mediaEl) === null || _this$mediaEl3 === void 0 ? void 0 : _this$mediaEl3.load();
  }

  onViewTypeChange() {
    this.dispatch('viewType', this.viewType);
  }

  connectedCallback() {
    this.initLazyLoader();
    this.dispatch = createProviderDispatcher(this);
    this.onViewTypeChange();
    this.onPosterChange();
    this.onMediaTitleChange();
  }

  componentDidRender() {
    if (this.prevMediaEl !== this.mediaEl) {
      this.prevMediaEl = this.mediaEl;
      this.vmMediaElChange.emit(this.mediaEl);
    }
  }

  componentDidLoad() {
    this.onViewTypeChange();
  }

  disconnectedCallback() {
    var _this$lazyLoader;

    this.mediaQueryDisposal.empty();
    this.textTracksDisposal.empty();
    this.cancelTimeUpdates();
    (_this$lazyLoader = this.lazyLoader) === null || _this$lazyLoader === void 0 ? void 0 : _this$lazyLoader.destroy();
    this.wasPausedBeforeSeeking = true;
  }

  initLazyLoader() {
    this.lazyLoader = new LazyLoader(this.host, ['data-src', 'data-poster'], () => {
      if (isNullOrUndefined(this.mediaEl)) return;
      var poster = this.mediaEl.getAttribute('data-poster');
      if (!isNull(poster)) this.mediaEl.setAttribute('poster', poster);
      this.refresh();
      this.didSrcSetChange();
    });
  }

  refresh() {
    if (isNullOrUndefined(this.mediaEl)) return;
    var {
      children
    } = this.mediaEl;

    for (var i = 0; i <= children.length - 1; i += 1) {
      var child = children[i];
      var src = child.getAttribute('data-src') || child.getAttribute('src') || child.getAttribute('data-vs');
      child.removeAttribute('src');
      if (isNull(src)) continue;
      child.setAttribute('data-vs', src);
      child.setAttribute('src', src);
    }
  }

  didSrcSetChange() {
    if (isNullOrUndefined(this.mediaEl)) return;
    var sources = Array.from(this.mediaEl.querySelectorAll('source'));
    var srcSet = sources.map(source => {
      var _source$getAttribute;

      return {
        src: source.getAttribute('data-vs'),
        media: (_source$getAttribute = source.getAttribute('data-media')) !== null && _source$getAttribute !== void 0 ? _source$getAttribute : undefined,
        ref: source
      };
    });
    var didChange = this.currentSrcSet.length !== srcSet.length || srcSet.some((resource, i) => this.currentSrcSet[i].src !== resource.src);

    if (didChange) {
      this.currentSrcSet = srcSet;
      this.onSrcSetChange();
    }
  }

  onSrcSetChange() {
    var _this$mediaEl4;

    this.textTracksDisposal.empty();
    this.mediaQueryDisposal.empty();
    this.vmLoadStart.emit();
    this.vmSrcSetChange.emit(this.currentSrcSet);
    if (!this.willAttach) (_this$mediaEl4 = this.mediaEl) === null || _this$mediaEl4 === void 0 ? void 0 : _this$mediaEl4.load();
  }

  hasCustomPoster() {
    return !IS_IOS && !isUndefined(this.vmPoster);
  }

  cancelTimeUpdates() {
    if (isNumber(this.timeRAF)) window.cancelAnimationFrame(this.timeRAF);
    this.timeRAF = undefined;
  }

  requestTimeUpdates() {
    var _this$mediaEl$current, _this$mediaEl5;

    this.dispatch('currentTime', (_this$mediaEl$current = (_this$mediaEl5 = this.mediaEl) === null || _this$mediaEl5 === void 0 ? void 0 : _this$mediaEl5.currentTime) !== null && _this$mediaEl$current !== void 0 ? _this$mediaEl$current : 0);
    this.timeRAF = window.requestAnimationFrame(() => {
      this.requestTimeUpdates();
    });
  }

  getMediaType() {
    var {
      currentSrc
    } = this.mediaEl;
    if (audioRegex.test(currentSrc)) return MediaType.Audio;
    if (videoRegex.test(currentSrc) || hlsRegex.test(currentSrc)) return MediaType.Video;
    return undefined;
  }

  onLoadedMetadata() {
    this.mediaEl.volume = this.volume / 100;
    this.listenToTextTracksForChanges();
    this.onTextTracksChange();
    this.onProgress();
    this.dispatch('currentPoster', this.poster);
    this.dispatch('duration', this.mediaEl.duration);
    this.dispatch('playbackRates', this.playbackRates);

    if (!this.willAttach) {
      this.dispatch('currentSrc', this.mediaEl.currentSrc);
      this.dispatch('mediaType', this.getMediaType());
      this.dispatch('playbackReady', true);
    }
  }

  onProgress() {
    var {
      buffered,
      duration
    } = this.mediaEl;
    var end = buffered.length === 0 ? 0 : buffered.end(buffered.length - 1);
    this.dispatch('buffered', end > duration ? duration : end);
  }

  onPlay() {
    this.requestTimeUpdates();
    this.dispatch('paused', false);
    if (!this.playbackStarted) this.dispatch('playbackStarted', true);
  }

  onPause() {
    this.cancelTimeUpdates();
    this.dispatch('paused', true);
    this.dispatch('buffering', false);
  }

  onPlaying() {
    this.dispatch('playing', true);
    this.dispatch('buffering', false);
  }

  onSeeking() {
    if (!this.wasPausedBeforeSeeking) this.wasPausedBeforeSeeking = this.mediaEl.paused;
    this.dispatch('currentTime', this.mediaEl.currentTime);
    this.dispatch('seeking', true);
  }

  onSeeked() {
    // Avoid calling `attemptToPlay` if seeking to 0 on 0.
    if (this.currentTime === 0 && !this.playbackStarted) return;
    this.dispatch('seeking', false);
    if (!this.playbackStarted || !this.wasPausedBeforeSeeking) this.attemptToPlay();
    this.wasPausedBeforeSeeking = true;
  }

  onRateChange() {
    this.dispatch('playbackRate', this.mediaEl.playbackRate);
  }

  onVolumeChange() {
    this.dispatch('muted', this.mediaEl.muted);
    this.dispatch('volume', this.mediaEl.volume * 100);
  }

  onDurationChange() {
    this.dispatch('duration', this.mediaEl.duration);
  }

  onWaiting() {
    this.dispatch('buffering', true);
  }

  onSuspend() {
    this.dispatch('buffering', false);
  }

  onEnded() {
    if (!this.loop) this.dispatch('playbackEnded', true);
  }

  onError() {
    this.vmError.emit(this.mediaEl.error);
  }

  attemptToPlay() {
    try {
      var _this$mediaEl6;

      (_this$mediaEl6 = this.mediaEl) === null || _this$mediaEl6 === void 0 ? void 0 : _this$mediaEl6.play();
    } catch (e) {
      this.vmError.emit(e);
    }
  }

  togglePiPInChrome(toggle) {
    var _this$mediaEl7;

    return toggle ? (_this$mediaEl7 = this.mediaEl) === null || _this$mediaEl7 === void 0 ? void 0 : _this$mediaEl7.requestPictureInPicture() : document.exitPictureInPicture();
  }

  togglePiPInSafari(toggle) {
    var _this$mediaEl8, _this$mediaEl9;

    var mode = toggle ? "picture-in-picture"
    /* PiP */
    : "inline"
    /* Inline */
    ;

    if (!((_this$mediaEl8 = this.mediaEl) !== null && _this$mediaEl8 !== void 0 && _this$mediaEl8.webkitSupportsPresentationMode(mode))) {
      throw new Error('PiP API is not available.');
    }

    return (_this$mediaEl9 = this.mediaEl) === null || _this$mediaEl9 === void 0 ? void 0 : _this$mediaEl9.webkitSetPresentationMode(mode);
  }

  togglePiP(toggle) {
    var _this23 = this;

    return _asyncToGenerator(function* () {
      if (canUsePiPInChrome()) return _this23.togglePiPInChrome(toggle);
      if (canUsePiPInSafari()) return _this23.togglePiPInSafari(toggle);
      throw new Error('PiP API is not available.');
    })();
  }

  toggleFullscreen(toggle) {
    var _this24 = this;

    return _asyncToGenerator(function* () {
      var _this24$mediaEl, _this24$mediaEl2, _this24$mediaEl3;

      if (!((_this24$mediaEl = _this24.mediaEl) !== null && _this24$mediaEl !== void 0 && _this24$mediaEl.webkitSupportsFullscreen)) {
        throw new Error('Fullscreen API is not available.');
      }

      return toggle ? (_this24$mediaEl2 = _this24.mediaEl) === null || _this24$mediaEl2 === void 0 ? void 0 : _this24$mediaEl2.webkitEnterFullscreen() : (_this24$mediaEl3 = _this24.mediaEl) === null || _this24$mediaEl3 === void 0 ? void 0 : _this24$mediaEl3.webkitExitFullscreen();
    })();
  }

  onPresentationModeChange() {
    var _this$mediaEl10;

    var mode = (_this$mediaEl10 = this.mediaEl) === null || _this$mediaEl10 === void 0 ? void 0 : _this$mediaEl10.webkitPresentationMode;
    this.dispatch('isPiPActive', mode === "picture-in-picture"
    /* PiP */
    );
    this.dispatch('isFullscreenActive', mode === "fullscreen"
    /* Fullscreen */
    );
  }

  onEnterPiP() {
    this.dispatch('isPiPActive', true);
  }

  onLeavePiP() {
    this.dispatch('isPiPActive', false);
  }
  /** @internal */


  getAdapter() {
    var _this25 = this;

    return _asyncToGenerator(function* () {
      return {
        getInternalPlayer: function () {
          var _getInternalPlayer3 = _asyncToGenerator(function* () {
            return _this25.mediaEl;
          });

          function getInternalPlayer() {
            return _getInternalPlayer3.apply(this, arguments);
          }

          return getInternalPlayer;
        }(),
        play: function () {
          var _play2 = _asyncToGenerator(function* () {
            var _this25$mediaEl;

            return (_this25$mediaEl = _this25.mediaEl) === null || _this25$mediaEl === void 0 ? void 0 : _this25$mediaEl.play();
          });

          function play() {
            return _play2.apply(this, arguments);
          }

          return play;
        }(),
        pause: function () {
          var _pause2 = _asyncToGenerator(function* () {
            var _this25$mediaEl2;

            return (_this25$mediaEl2 = _this25.mediaEl) === null || _this25$mediaEl2 === void 0 ? void 0 : _this25$mediaEl2.pause();
          });

          function pause() {
            return _pause2.apply(this, arguments);
          }

          return pause;
        }(),
        canPlay: function () {
          var _canPlay3 = _asyncToGenerator(function* (type) {
            return isString(type) && (audioRegex.test(type) || videoRegex.test(type));
          });

          function canPlay(_x18) {
            return _canPlay3.apply(this, arguments);
          }

          return canPlay;
        }(),
        setCurrentTime: function () {
          var _setCurrentTime2 = _asyncToGenerator(function* (time) {
            if (_this25.mediaEl) _this25.mediaEl.currentTime = time;
          });

          function setCurrentTime(_x19) {
            return _setCurrentTime2.apply(this, arguments);
          }

          return setCurrentTime;
        }(),
        setMuted: function () {
          var _setMuted2 = _asyncToGenerator(function* (muted) {
            if (_this25.mediaEl) _this25.mediaEl.muted = muted;
          });

          function setMuted(_x20) {
            return _setMuted2.apply(this, arguments);
          }

          return setMuted;
        }(),
        setVolume: function () {
          var _setVolume2 = _asyncToGenerator(function* (volume) {
            if (_this25.mediaEl) _this25.mediaEl.volume = volume / 100;
          });

          function setVolume(_x21) {
            return _setVolume2.apply(this, arguments);
          }

          return setVolume;
        }(),
        canSetPlaybackRate: function () {
          var _canSetPlaybackRate = _asyncToGenerator(function* () {
            return true;
          });

          function canSetPlaybackRate() {
            return _canSetPlaybackRate.apply(this, arguments);
          }

          return canSetPlaybackRate;
        }(),
        setPlaybackRate: function () {
          var _setPlaybackRate = _asyncToGenerator(function* (rate) {
            if (_this25.mediaEl) _this25.mediaEl.playbackRate = rate;
          });

          function setPlaybackRate(_x22) {
            return _setPlaybackRate.apply(this, arguments);
          }

          return setPlaybackRate;
        }(),
        canSetPiP: function () {
          var _canSetPiP = _asyncToGenerator(function* () {
            return canUsePiP();
          });

          function canSetPiP() {
            return _canSetPiP.apply(this, arguments);
          }

          return canSetPiP;
        }(),
        enterPiP: () => _this25.togglePiP(true),
        exitPiP: () => _this25.togglePiP(false),
        canSetFullscreen: function () {
          var _canSetFullscreen2 = _asyncToGenerator(function* () {
            return canFullscreenVideo();
          });

          function canSetFullscreen() {
            return _canSetFullscreen2.apply(this, arguments);
          }

          return canSetFullscreen;
        }(),
        enterFullscreen: () => _this25.toggleFullscreen(true),
        exitFullscreen: () => _this25.toggleFullscreen(false),
        setCurrentTextTrack: function () {
          var _setCurrentTextTrack2 = _asyncToGenerator(function* (trackId) {
            if (trackId !== _this25.currentTextTrack) _this25.toggleTextTrackModes(trackId);
          });

          function setCurrentTextTrack(_x23) {
            return _setCurrentTextTrack2.apply(this, arguments);
          }

          return setCurrentTextTrack;
        }(),
        setTextTrackVisibility: function () {
          var _setTextTrackVisibility2 = _asyncToGenerator(function* (isVisible) {
            _this25.isTextTrackVisible = isVisible;

            _this25.toggleTextTrackModes(_this25.currentTextTrack);
          });

          function setTextTrackVisibility(_x24) {
            return _setTextTrackVisibility2.apply(this, arguments);
          }

          return setTextTrackVisibility;
        }()
      };
    })();
  }

  onHasCustomTextManagerChange() {
    if (this.hasCustomTextManager) {
      this.textTracksDisposal.empty();
    } else if (this.playbackReady) {
      this.listenToTextTracksForChanges();
    }
  }

  onShouldRenderNativeTextTracksChange() {
    if (this.hasCustomTextManager) return;
    this.toggleTextTrackModes(this.currentTextTrack);
  }

  onProviderConnect(event) {
    if (this.noConnect) event.stopImmediatePropagation();
  }

  onProviderDisconnect(event) {
    if (this.noConnect) event.stopImmediatePropagation();
  }

  getFilteredTextTracks() {
    var tracks = [];
    var textTrackList = Array.from(this.mediaEl.textTracks);

    for (var i = 0; i < textTrackList.length; i += 1) {
      var track = textTrackList[i]; // Edge adds a track without a label; we don't want to use it.

      if ((track.kind === 'subtitles' || track.kind === 'captions') && track.label) {
        tracks.push(textTrackList[i]);
      }
    }

    return tracks;
  }

  listenToTextTracksForChanges() {
    if (this.hasCustomTextManager) return;
    this.textTracksDisposal.empty();
    if (isUndefined(this.mediaEl)) return;
    this.textTracksDisposal.add(listen(this.mediaEl.textTracks, 'change', this.onTextTracksChange.bind(this)));
  }

  onTextTracksChange() {
    var _tracks$trackId;

    var tracks = this.getFilteredTextTracks();
    var trackId = -1;

    for (var id = 0; id < tracks.length; id += 1) {
      if (tracks[id].mode === 'hidden') {
        // Do not break in case there is a following track with showing.
        trackId = id;
      } else if (tracks[id].mode === 'showing') {
        trackId = id;
        break;
      }
    }

    if (!this.shouldRenderNativeTextTracks && ((_tracks$trackId = tracks[trackId]) === null || _tracks$trackId === void 0 ? void 0 : _tracks$trackId.mode) === 'showing') {
      tracks[trackId].mode = 'hidden';
      return;
    }

    if (this.shouldRenderNativeTextTracks) {
      this.isTextTrackVisible = trackId !== -1 && tracks[trackId].mode === 'showing';
      this.dispatch('isTextTrackVisible', this.isTextTrackVisible);
    }

    this.dispatch('textTracks', tracks);
    this.dispatch('currentTextTrack', this.shouldRenderNativeTextTracks && !this.isTextTrackVisible ? -1 : trackId);
  }

  toggleTextTrackModes(newTrackId) {
    if (isNullOrUndefined(this.mediaEl)) return;
    var {
      textTracks
    } = this.mediaEl;

    if (newTrackId === -1) {
      Array.from(textTracks).forEach(track => {
        track.mode = 'disabled';
      });
    } else {
      var oldTrack = textTracks[this.currentTextTrack];
      if (oldTrack) oldTrack.mode = 'disabled';
    }

    var nextTrack = textTracks[newTrackId];

    if (nextTrack) {
      nextTrack.mode = this.isTextTrackVisible && this.shouldRenderNativeTextTracks ? 'showing' : 'hidden';
    }

    this.dispatch('currentTextTrack', this.shouldRenderNativeTextTracks && !this.isTextTrackVisible ? -1 : newTrackId);
    this.dispatch('isTextTrackVisible', this.isTextTrackVisible);
  }

  render() {
    var mediaProps = {
      autoplay: this.autoplay,
      muted: this.muted,
      playsinline: this.playsinline,
      playsInline: this.playsinline,
      'x5-playsinline': this.playsinline,
      'webkit-playsinline': this.playsinline,
      controls: this.controls,
      crossorigin: this.crossOrigin === '' ? 'anonymous' : this.crossOrigin,
      controlslist: this.controlsList,
      'data-poster': !this.hasCustomPoster() ? this.poster : undefined,
      loop: this.loop,
      preload: this.preload,
      disablePictureInPicture: this.disablePiP,
      autoPictureInPicture: this.autoPiP,
      disableRemotePlayback: this.disableRemotePlayback,
      'x-webkit-airplay': this.disableRemotePlayback ? 'deny' : 'allow',
      ref: el => {
        this.mediaEl = el;
      },
      onLoadedMetadata: this.onLoadedMetadata.bind(this),
      onProgress: this.onProgress.bind(this),
      onPlay: this.onPlay.bind(this),
      onPause: this.onPause.bind(this),
      onPlaying: this.onPlaying.bind(this),
      onSeeking: this.onSeeking.bind(this),
      onSeeked: this.onSeeked.bind(this),
      onRateChange: this.onRateChange.bind(this),
      onVolumeChange: this.onVolumeChange.bind(this),
      onDurationChange: this.onDurationChange.bind(this),
      onWaiting: this.onWaiting.bind(this),
      onSuspend: this.onSuspend.bind(this),
      onEnded: this.onEnded.bind(this),
      onError: this.onError.bind(this)
    };
    var audio = (0, _client.h)("audio", Object.assign({
      class: "lazy"
    }, mediaProps), (0, _client.h)("slot", null), "Your browser does not support the", (0, _client.h)("code", null, "audio"), "element.");
    var video = (0, _client.h)("video", Object.assign({
      class: "lazy"
    }, mediaProps, {
      // @ts-ignore
      onwebkitpresentationmodechanged: this.onPresentationModeChange.bind(this),
      onenterpictureinpicture: this.onEnterPiP.bind(this),
      onleavepictureinpicture: this.onLeavePiP.bind(this)
    }), (0, _client.h)("slot", null), "Your browser does not support the", (0, _client.h)("code", null, "video"), "element.");
    return this.viewType === ViewType.Audio ? audio : video;
  }

  get host() {
    return this;
  }

  static get watchers() {
    return {
      "mediaTitle": ["onMediaTitleChange"],
      "poster": ["onPosterChange"],
      "viewType": ["onViewTypeChange"],
      "hasCustomTextManager": ["onHasCustomTextManagerChange"],
      "shouldRenderNativeTextTracks": ["onShouldRenderNativeTextTracksChange"]
    };
  }

  static get style() {
    return fileCss;
  }

};
var fullscreenControlCss = ":host([hidden]){display:none}";
var FullscreenControl = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.canSetFullscreen = false;
    /**
     * The name of the enter fullscreen icon to resolve from the icon library.
     */

    this.enterIcon = 'fullscreen-enter';
    /**
     * The name of the exit fullscreen icon to resolve from the icon library.
     */

    this.exitIcon = 'fullscreen-exit';
    /**
     * Whether the tooltip is positioned above/below the control.
     */

    this.tooltipPosition = 'top';
    /**
     * Whether the tooltip should not be displayed.
     */

    this.hideTooltip = false;
    /** @inheritdoc */

    this.keys = 'f';
    /** @internal */

    this.isFullscreenActive = false;
    /** @internal */

    this.i18n = {};
    /** @internal */

    this.playbackReady = false;
    withComponentRegistry(this);
    withPlayerContext(this, ['isFullscreenActive', 'playbackReady', 'i18n']);
  }

  onPlaybackReadyChange() {
    var _this26 = this;

    return _asyncToGenerator(function* () {
      var _yield$player$canSetF;

      var player = getPlayerFromRegistry(_this26);
      _this26.canSetFullscreen = (_yield$player$canSetF = yield player === null || player === void 0 ? void 0 : player.canSetFullscreen()) !== null && _yield$player$canSetF !== void 0 ? _yield$player$canSetF : false;
    })();
  }

  componentDidLoad() {
    this.onPlaybackReadyChange();
  }

  onClick() {
    var player = getPlayerFromRegistry(this);
    !this.isFullscreenActive ? player === null || player === void 0 ? void 0 : player.enterFullscreen() : player === null || player === void 0 ? void 0 : player.exitFullscreen();
  }

  render() {
    var tooltip = this.isFullscreenActive ? this.i18n.exitFullscreen : this.i18n.enterFullscreen;
    var tooltipWithHint = !isUndefined(this.keys) ? "".concat(tooltip, " (").concat(this.keys, ")") : tooltip;
    return (0, _client.h)(_client.Host, {
      hidden: !this.canSetFullscreen
    }, (0, _client.h)("vm-control", {
      label: this.i18n.fullscreen,
      keys: this.keys,
      pressed: this.isFullscreenActive,
      hidden: !this.canSetFullscreen,
      onClick: this.onClick.bind(this)
    }, (0, _client.h)("vm-icon", {
      name: this.isFullscreenActive ? this.exitIcon : this.enterIcon,
      library: this.icons
    }), (0, _client.h)("vm-tooltip", {
      hidden: this.hideTooltip,
      position: this.tooltipPosition,
      direction: this.tooltipDirection
    }, tooltipWithHint)));
  }

  static get watchers() {
    return {
      "playbackReady": ["onPlaybackReadyChange"]
    };
  }

  static get style() {
    return fullscreenControlCss;
  }

};
var HLS = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    this.vmLoadStart = (0, _client.createEvent)(this, "vmLoadStart", 7);
    this.vmError = (0, _client.createEvent)(this, "vmError", 7);
    this.hasAttached = false;
    /**
     * The NPM package version of the `hls.js` library to download and use if HLS is not natively
     * supported.
     */

    this.version = 'latest';
    /** @inheritdoc */

    this.preload = 'metadata';
    /** @internal */

    this.playbackReady = false;
    withComponentRegistry(this);
    withProviderConnect(this);
    withPlayerContext(this, ['playbackReady']);
  }

  connectedCallback() {
    this.dispatch = createProviderDispatcher(this);
    if (this.mediaEl) this.setupHls();
  }

  disconnectedCallback() {
    this.destroyHls();
  }

  get src() {
    if (isNullOrUndefined(this.videoProvider)) return undefined;
    var sources = this.videoProvider.querySelectorAll('source');
    var currSource = Array.from(sources).find(source => hlsRegex.test(source.src) || hlsTypeRegex.test(source.type));
    return currSource === null || currSource === void 0 ? void 0 : currSource.src;
  }

  setupHls() {
    var _this27 = this;

    return _asyncToGenerator(function* () {
      if (!isUndefined(_this27.hls)) return;

      try {
        var url = _this27.libSrc || "https://cdn.jsdelivr.net/npm/hls.js@".concat(_this27.version, "/dist/hls.min.js");
        var Hls = yield loadSDK(url, 'Hls');

        if (!Hls.isSupported()) {
          _this27.vmError.emit('hls.js is not supported');

          return;
        }

        _this27.hls = new Hls(_this27.config);

        _this27.hls.on(Hls.Events.MEDIA_ATTACHED, () => {
          _this27.hasAttached = true;

          _this27.onSrcChange();
        });

        _this27.hls.on(Hls.Events.AUDIO_TRACKS_UPDATED, () => {
          _this27.dispatch('audioTracks', _this27.hls.audioTracks);

          _this27.dispatch('currentAudioTrack', _this27.hls.audioTrack);
        });

        _this27.hls.on(Hls.Events.AUDIO_TRACK_SWITCHED, () => {
          _this27.dispatch('currentAudioTrack', _this27.hls.audioTrack);
        });

        _this27.hls.on(Hls.Events.ERROR, (event, data) => {
          if (data.fatal) {
            switch (data.type) {
              case Hls.ErrorTypes.NETWORK_ERROR:
                _this27.hls.startLoad();

                break;

              case Hls.ErrorTypes.MEDIA_ERROR:
                _this27.hls.recoverMediaError();

                break;

              default:
                _this27.destroyHls();

                break;
            }
          }

          _this27.vmError.emit({
            event,
            data
          });
        });

        _this27.hls.on(Hls.Events.MANIFEST_PARSED, () => {
          _this27.dispatch('mediaType', MediaType.Video);

          _this27.dispatch('currentSrc', _this27.src);

          _this27.dispatchLevels();
        });

        _this27.hls.on(Hls.Events.LEVEL_LOADED, (_, data) => {
          if (!_this27.playbackReady) {
            _this27.dispatch('duration', data.details.totalduration);

            _this27.dispatch('playbackReady', true);
          }
        });

        _this27.hls.attachMedia(_this27.mediaEl);
      } catch (e) {
        _this27.vmError.emit(e);
      }
    })();
  }

  dispatchLevels() {
    if (!this.hls.levels || this.hls.levels.length === 0) return;
    this.dispatch('playbackQualities', ['Auto', ...this.hls.levels.map(this.levelToPlaybackQuality)]);
    this.dispatch('playbackQuality', 'Auto');
  }

  levelToPlaybackQuality(level) {
    return level === -1 ? 'Auto' : "".concat(level.height, "p");
  }

  findLevelIndexFromQuality(quality) {
    return this.hls.levels.findIndex(level => this.levelToPlaybackQuality(level) === quality);
  }

  destroyHls() {
    var _this$hls;

    (_this$hls = this.hls) === null || _this$hls === void 0 ? void 0 : _this$hls.destroy();
    this.hasAttached = false;
  }

  onMediaElChange(event) {
    var _this28 = this;

    return _asyncToGenerator(function* () {
      _this28.destroyHls();

      if (isUndefined(event.detail)) return;
      _this28.mediaEl = event.detail; // Need a small delay incase the media element changes rapidly and Hls.js can't reattach.

      setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {
        yield _this28.setupHls();
      }), 50);
    })();
  }

  onSrcChange() {
    var _this29 = this;

    return _asyncToGenerator(function* () {
      if (_this29.hasAttached && _this29.hls.url !== _this29.src) {
        _this29.vmLoadStart.emit();

        _this29.hls.loadSource(_this29.src);
      }
    })();
  }
  /** @internal */


  getAdapter() {
    var _this30 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this30$videoP, _this30$videoProvider;

      var adapter = (_yield$_this30$videoP = yield (_this30$videoProvider = _this30.videoProvider) === null || _this30$videoProvider === void 0 ? void 0 : _this30$videoProvider.getAdapter()) !== null && _yield$_this30$videoP !== void 0 ? _yield$_this30$videoP : {};
      var canVideoProviderPlay = adapter.canPlay;
      return _objectSpread(_objectSpread({}, adapter), {}, {
        getInternalPlayer: function () {
          var _getInternalPlayer4 = _asyncToGenerator(function* () {
            return _this30.hls;
          });

          function getInternalPlayer() {
            return _getInternalPlayer4.apply(this, arguments);
          }

          return getInternalPlayer;
        }(),
        canPlay: function () {
          var _canPlay4 = _asyncToGenerator(function* (type) {
            var _canVideoProviderPlay2;

            return isString(type) && hlsRegex.test(type) || ((_canVideoProviderPlay2 = canVideoProviderPlay === null || canVideoProviderPlay === void 0 ? void 0 : canVideoProviderPlay(type)) !== null && _canVideoProviderPlay2 !== void 0 ? _canVideoProviderPlay2 : false);
          });

          function canPlay(_x25) {
            return _canPlay4.apply(this, arguments);
          }

          return canPlay;
        }(),
        canSetPlaybackQuality: function () {
          var _canSetPlaybackQuality3 = _asyncToGenerator(function* () {
            var _this30$hls, _this30$hls$levels;

            return ((_this30$hls = _this30.hls) === null || _this30$hls === void 0 ? void 0 : (_this30$hls$levels = _this30$hls.levels) === null || _this30$hls$levels === void 0 ? void 0 : _this30$hls$levels.length) > 0;
          });

          function canSetPlaybackQuality() {
            return _canSetPlaybackQuality3.apply(this, arguments);
          }

          return canSetPlaybackQuality;
        }(),
        setPlaybackQuality: function () {
          var _setPlaybackQuality3 = _asyncToGenerator(function* (quality) {
            if (!isUndefined(_this30.hls)) {
              _this30.hls.currentLevel = _this30.findLevelIndexFromQuality(quality); // Update the provider cache.

              _this30.dispatch('playbackQuality', quality);
            }
          });

          function setPlaybackQuality(_x26) {
            return _setPlaybackQuality3.apply(this, arguments);
          }

          return setPlaybackQuality;
        }(),
        setCurrentAudioTrack: function () {
          var _setCurrentAudioTrack = _asyncToGenerator(function* (trackId) {
            if (!isUndefined(_this30.hls)) {
              _this30.hls.audioTrack = trackId;
            }
          });

          function setCurrentAudioTrack(_x27) {
            return _setCurrentAudioTrack.apply(this, arguments);
          }

          return setCurrentAudioTrack;
        }()
      });
    })();
  }

  render() {
    return (0, _client.h)("vm-video", {
      willAttach: true,
      crossOrigin: this.crossOrigin,
      preload: this.preload,
      poster: this.poster,
      controlsList: this.controlsList,
      autoPiP: this.autoPiP,
      disablePiP: this.disablePiP,
      disableRemotePlayback: this.disableRemotePlayback,
      mediaTitle: this.mediaTitle,
      ref: el => {
        this.videoProvider = el;
      }
    }, (0, _client.h)("slot", null));
  }

};
/**
 * INSPIRED BY: https://github.com/shoelace-style/shoelace/blob/next/src/components/icon-library/icon-library-registry.ts
 */

var ICONS_BASE_CDN_URL = 'https://cdn.jsdelivr.net/npm/@vime/core@latest/icons';
var registry = new Map(Object.entries({
  vime: iconName => "".concat(ICONS_BASE_CDN_URL, "/vime/vm-").concat(iconName, ".svg"),
  material: iconName => "".concat(ICONS_BASE_CDN_URL, "/material/md-").concat(iconName, ".svg")
}));
var watch$1 = new Set();

function withIconRegistry(component) {
  var el = (0, _client.getElement)(component);
  createStencilHook(component, () => {
    watch$1.add(el);
  }, () => {
    watch$1.delete(el);
  });
}

var getIconLibraryResolver = name => registry.get(name);

function registerIconLibrary(name, resolver) {
  if (!isUndefined(resolver)) {
    registry.set(name, resolver);
  } // Redraw watched icons.


  watch$1.forEach(iconEl => {
    if (iconEl.library === name) iconEl.redraw();
  });
}

function deregisterIconLibrary(name) {
  registry.delete(name);
}
/**
 * INSPIRED BY: https://github.com/shoelace-style/shoelace/blob/next/src/components/icon/request.ts
 */


var iconFiles = new Map();

var requestIcon = url => {
  if (iconFiles.has(url)) return iconFiles.get(url);
  var request = fetch(url).then( /*#__PURE__*/function () {
    var _ref8 = _asyncToGenerator(function* (response) {
      if (response.ok) {
        var div = document.createElement('div');
        div.innerHTML = yield response.text();
        var svg = div.firstElementChild;
        return {
          ok: response.ok,
          status: response.status,
          svg: svg && svg.tagName.toLowerCase() === 'svg' ? svg.outerHTML : ''
        };
      }

      return {
        ok: response.ok,
        status: response.status
      };
    });

    return function (_x28) {
      return _ref8.apply(this, arguments);
    };
  }());
  iconFiles.set(url, request);
  return request;
};

var iconCss = ":host{display:inline-block;width:1em;height:1em;contain:strict;box-sizing:content-box !important}.icon,svg{display:block;height:100%;width:100%;transition:var(--vm-icon-transition);transform:var(--vm-icon-transform);fill:var(--vm-icon-fill, currentColor);stroke:var(--vm-icon-stroke)}";
var parser = new DOMParser();
var Icon = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.vmLoad = (0, _client.createEvent)(this, "vmLoad", 7);
    this.vmError = (0, _client.createEvent)(this, "vmError", 7);
    /** @internal */

    this.icons = 'material';
    withComponentRegistry(this);
    withIconRegistry(this);
  }

  handleChange() {
    this.setIcon();
  }

  connectedCallback() {
    withPlayerContext(this, ['icons']);
  }

  componentDidLoad() {
    this.setIcon();
  }
  /**
   * @internal Fetches the icon and redraws it. Used to handle library registrations.
   */


  redraw() {
    var _this31 = this;

    return _asyncToGenerator(function* () {
      _this31.setIcon();
    })();
  }

  getLabel() {
    var label = '';

    if (this.label) {
      label = this.label;
    } else if (this.name) {
      label = this.name.replace(/-/g, ' ');
    } else if (this.src) {
      label = this.src.replace(/.*\//, '').replace(/-/g, ' ').replace(/\.svg/i, '');
    }

    return label;
  }

  setIcon() {
    var _this32 = this;

    return _asyncToGenerator(function* () {
      var _this32$library;

      var resolver = getIconLibraryResolver((_this32$library = _this32.library) !== null && _this32$library !== void 0 ? _this32$library : _this32.icons);
      var url = _this32.src;

      if (_this32.name && resolver) {
        url = resolver(_this32.name);
      }

      if (url) {
        try {
          var file = yield requestIcon(url);

          if (file.ok) {
            var doc = parser.parseFromString(file.svg, 'text/html');
            var svg = doc.body.querySelector('svg');

            if (svg) {
              _this32.svg = svg.outerHTML;

              _this32.vmLoad.emit();
            } else {
              _this32.svg = '';

              _this32.vmError.emit({
                status: file.status
              });
            }
          }
        } catch (_unused) {
          _this32.vmError.emit();
        }
      }
    })();
  }

  render() {
    return (0, _client.h)("div", {
      class: "icon",
      role: "img",
      "aria-label": this.getLabel(),
      innerHTML: this.svg
    });
  }

  static get watchers() {
    return {
      "name": ["handleChange"],
      "src": ["handleChange"],
      "library": ["handleChange"],
      "icons": ["handleChange"]
    };
  }

  static get style() {
    return iconCss;
  }

};
var IconLibrary = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    /** @internal */

    this.icons = 'material';
    withComponentRegistry(this);
    withPlayerContext(this, ['icons']);
  }

  handleUpdate() {
    this.register();
  }

  connectedCallback() {
    this.register();
  }

  disconnectedCallback() {
    if (!isUndefined(this.name)) deregisterIconLibrary(this.name);
  }

  register() {
    var _this$name;

    registerIconLibrary((_this$name = this.name) !== null && _this$name !== void 0 ? _this$name : this.icons, this.name ? this.resolver : undefined);
  }

  get host() {
    return this;
  }

  static get watchers() {
    return {
      "name": ["handleUpdate"],
      "resolver": ["handleUpdate"],
      "icons": ["handleUpdate"]
    };
  }

};
var liveIndicatorCss = ".liveIndicator{display:flex;align-items:center;font-size:13px;font-weight:bold;letter-spacing:0.6px;color:var(--vm-control-color)}.liveIndicator.hidden{display:none}.indicator{display:inline-block;width:8px;height:8px;border-radius:50%;margin-right:4px;background-color:var(--vm-live-indicator-color, red)}";
var LiveIndicator = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    /** @internal */

    this.isLive = false;
    /** @internal */

    this.i18n = {};
    withComponentRegistry(this);
    withPlayerContext(this, ['isLive', 'i18n']);
  }

  render() {
    return (0, _client.h)("div", {
      class: {
        liveIndicator: true,
        hidden: !this.isLive
      }
    }, (0, _client.h)("div", {
      class: "indicator"
    }), this.i18n.live);
  }

  static get style() {
    return liveIndicatorCss;
  }

};
var loadingScreenCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--vm-loading-screen-z-index);display:flex;align-items:center;justify-content:center}.loadingScreen{opacity:100;transition:var(--vm-fade-transition)}.loadingScreen.inactive{opacity:0}.dotPulse{position:relative;left:-9999px;width:var(--vm-loading-screen-dot-size);height:var(--vm-loading-screen-dot-size);border-radius:calc(var(--vm-loading-screen-dot-size) / 2);background-color:var(--vm-loading-screen-dot-color);color:var(--vm-loading-screen-dot-color);box-shadow:9999px 0 0 calc(calc(var(--vm-loading-screen-dot-size) / 2) * -1) var(--vm-loading-screen-dot-color);animation:dotPulse var(--vm-loading-screen-pulse-duration) infinite linear;animation-delay:calc(var(--vm-loading-screen-pulse-duration) / 6)}.dotPulse::before,.dotPulse::after{content:'';display:inline-block;position:absolute;top:0;width:var(--vm-loading-screen-dot-size);height:var(--vm-loading-screen-dot-size);border-radius:calc(var(--vm-loading-screen-dot-size) / 2);background-color:var(--vm-loading-screen-dot-color);color:var(--vm-loading-screen-dot-color)}.dotPulse::before{box-shadow:9984px 0 0 calc(calc(var(--vm-loading-screen-dot-size) / 2) * -1) var(--vm-loading-screen-dot-color);animation:dotPulseBefore var(--vm-loading-screen-pulse-duration) infinite linear;animation-delay:0s}.dotPulse::after{box-shadow:10014px 0 0 calc(calc(var(--vm-loading-screen-dot-size) / 2) * -1) var(--vm-loading-screen-dot-color);animation:dotPulseAfter var(--vm-loading-screen-pulse-duration) infinite linear;animation-delay:calc(var(--vm-loading-screen-pulse-duration) / 3)}@keyframes dotPulseBefore{0%{box-shadow:9984px 0 0 calc(calc(var(--vm-loading-screen-dot-size) / 2) * -1) var(--vm-loading-screen-dot-color)}30%{box-shadow:9984px 0 0 2px var(--vm-loading-screen-dot-color)}60%,100%{box-shadow:9984px 0 0 calc(calc(var(--vm-loading-screen-dot-size) / 2) * -1) var(--vm-loading-screen-dot-color)}}@keyframes dotPulse{0%{box-shadow:9999px 0 0 calc(calc(var(--vm-loading-screen-dot-size) / 2) * -1) var(--vm-loading-screen-dot-color)}30%{box-shadow:9999px 0 0 2px var(--vm-loading-screen-dot-color)}60%,100%{box-shadow:9999px 0 0 calc(calc(var(--vm-loading-screen-dot-size) / 2) * -1) var(--vm-loading-screen-dot-color)}}@keyframes dotPulseAfter{0%{box-shadow:10014px 0 0 calc(calc(var(--vm-loading-screen-dot-size) / 2) * -1) var(--vm-loading-screen-dot-color)}30%{box-shadow:10014px 0 0 2px var(--vm-loading-screen-dot-color)}60%,100%{box-shadow:10014px 0 0 calc(calc(var(--vm-loading-screen-dot-size) / 2) * -1) var(--vm-loading-screen-dot-color)}}";
var LoadingScreen = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    /** @internal */

    this.playbackReady = false;
    /**
     * Whether the loading dots are hidden or not.
     */

    this.hideDots = false;
    withComponentRegistry(this);
    withPlayerContext(this, ['playbackReady']);
  }

  render() {
    return (0, _client.h)("div", {
      class: {
        loadingScreen: true,
        inactive: this.playbackReady
      }
    }, (0, _client.h)("slot", null), !this.hideDots && (0, _client.h)("div", {
      class: "dotPulse"
    }));
  }

  static get style() {
    return loadingScreenCss;
  }

};

function unwrapSubmenu(el) {
  if (el.tagName.toLowerCase() !== 'vm-submenu') return el;
  var submenu = el;
  return submenu.shadowRoot.querySelector('vm-menu-item');
}

function unwrapRadioGroup(el) {
  var _slot$assignedElement;

  if (el.tagName.toLowerCase() !== 'vm-menu-radio-group') return el;
  var radioGroup = el;
  var slot = radioGroup.shadowRoot.querySelector('slot');
  var assignedElements = Array.from((_slot$assignedElement = slot === null || slot === void 0 ? void 0 : slot.assignedElements()) !== null && _slot$assignedElement !== void 0 ? _slot$assignedElement : []);
  return assignedElements.filter(radio => radio.tagName.toLowerCase() === 'vm-menu-radio').map(radio => radio.shadowRoot.querySelector('vm-menu-item'));
}

function menuItemHunter(assignedElements) {
  if (isUndefined(assignedElements)) return [];
  var allowed = ['vm-menu-item', 'vm-menu-radio-group', 'vm-submenu'];
  return Array.from(assignedElements !== null && assignedElements !== void 0 ? assignedElements : []).filter(el => allowed.includes(el.tagName.toLowerCase())).map(el => unwrapSubmenu(el)).map(el => unwrapRadioGroup(el)).reduce((acc, val) => acc.concat(val), []);
}

var menuCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;overflow:hidden;pointer-events:none;z-index:var(--vm-menu-z-index)}:host([active]){pointer-events:auto;z-index:calc(var(--vm-menu-z-index) + 1)}.menu{position:absolute;top:0;left:0;width:100%;height:100%;box-sizing:border-box;transition:var(--vm-menu-transition)}.menu.slideIn{transform:translateX(0)}.menu[aria-hidden='true'].slideInFromLeft{transform:translateX(-100%)}.menu[aria-hidden='true'].slideInFromRight{transform:translateX(100%)}.container{display:flex;flex-direction:column;position:relative;text-align:left;width:100%;height:100%;color:var(--vm-menu-color);background:var(--vm-menu-bg);font-size:var(--vm-menu-font-size);font-weight:var(--vm-menu-font-weight)}.menu:focus{outline:0}";
var Menu = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.vmOpen = (0, _client.createEvent)(this, "vmOpen", 7);
    this.vmClose = (0, _client.createEvent)(this, "vmClose", 7);
    this.vmFocus = (0, _client.createEvent)(this, "vmFocus", 7);
    this.vmBlur = (0, _client.createEvent)(this, "vmBlur", 7);
    this.vmActiveSubmenuChange = (0, _client.createEvent)(this, "vmActiveSubmenuChange", 7);
    this.vmActiveMenuItemChange = (0, _client.createEvent)(this, "vmActiveMenuItemChange", 7);
    this.vmMenuHeightChange = (0, _client.createEvent)(this, "vmMenuHeightChange", 3);
    this.hasDisconnected = false;
    /**
     * Whether the menu is open/visible.
     */

    this.active = false;
    withComponentRegistry(this);
  }

  onActiveMenuitemChange() {
    this.vmActiveMenuItemChange.emit(this.activeMenuItem);
  }

  onActiveSubmenuChange() {
    this.vmActiveSubmenuChange.emit(this.activeSubmenu);
  }

  onActiveChange() {
    var _this$controller;

    if (this.hasDisconnected) return;
    this.active ? this.vmOpen.emit(this.host) : this.vmClose.emit(this.host);

    if (((_this$controller = this.controller) === null || _this$controller === void 0 ? void 0 : _this$controller.tagName.toLowerCase()) === 'vm-menu-item') {
      this.controller.expanded = true;
    }
  }

  connectedCallback() {
    this.hasDisconnected = false;
  }

  componentDidRender() {
    (0, _client.writeTask)(() => {
      if (!this.hasDisconnected) this.calculateHeight();
    });
  }

  disconnectedCallback() {
    this.controller = undefined;
    this.hasDisconnected = true;
  }
  /**
   * Focuses the menu.
   */


  focusMenu() {
    var _this33 = this;

    return _asyncToGenerator(function* () {
      var _this33$menu;

      (_this33$menu = _this33.menu) === null || _this33$menu === void 0 ? void 0 : _this33$menu.focus();
    })();
  }
  /**
   * Removes focus from the menu.
   */


  blurMenu() {
    var _this34 = this;

    return _asyncToGenerator(function* () {
      var _this34$menu;

      (_this34$menu = _this34.menu) === null || _this34$menu === void 0 ? void 0 : _this34$menu.blur();
    })();
  }
  /**
   * Returns the currently focused menu item.
   */


  getActiveMenuItem() {
    var _this35 = this;

    return _asyncToGenerator(function* () {
      return _this35.activeMenuItem;
    })();
  }
  /**
   * Sets the currently focused menu item.
   */


  setActiveMenuItem(item) {
    var _this36 = this;

    return _asyncToGenerator(function* () {
      item === null || item === void 0 ? void 0 : item.focusItem();
      _this36.activeMenuItem = item;
    })();
  }
  /**
   * Calculates the height of the settings menu based on its children.
   */


  calculateHeight() {
    var _this37 = this;

    return _asyncToGenerator(function* () {
      var height = 0;

      if (_this37.activeSubmenu) {
        var _yield$submenu$calcul;

        var submenu = yield _this37.activeSubmenu.getMenu();
        height = (_yield$submenu$calcul = yield submenu === null || submenu === void 0 ? void 0 : submenu.calculateHeight()) !== null && _yield$submenu$calcul !== void 0 ? _yield$submenu$calcul : 0;
        height += yield _this37.activeSubmenu.getControllerHeight();
      } else {
        var _this37$container;

        var children = (_this37$container = _this37.container) === null || _this37$container === void 0 ? void 0 : _this37$container.firstChild.assignedElements({
          flatten: true
        });
        children === null || children === void 0 ? void 0 : children.forEach(child => {
          height += parseFloat(window.getComputedStyle(child).height);
        });
      }

      _this37.vmMenuHeightChange.emit(height);

      return height;
    })();
  }

  onOpenSubmenu(event) {
    event.stopPropagation();
    if (!isUndefined(this.activeSubmenu)) this.activeSubmenu.active = false;
    this.activeSubmenu = event.detail;
    this.getChildren().forEach(child => {
      if (child !== this.activeSubmenu) {
        child.style.opacity = '0';
        child.style.visibility = 'hidden';
      }
    });
    (0, _client.writeTask)(() => {
      this.activeSubmenu.active = true;
    });
  }

  onCloseSubmenu(event) {
    event === null || event === void 0 ? void 0 : event.stopPropagation();
    if (!isUndefined(this.activeSubmenu)) this.activeSubmenu.active = false;
    this.getChildren().forEach(child => {
      if (child !== this.activeSubmenu) {
        child.style.opacity = '';
        child.style.visibility = '';
      }
    });
    (0, _client.writeTask)(() => {
      this.activeSubmenu = undefined;
    });
  }

  onWindowClick() {
    this.onCloseSubmenu();
    this.onClose();
  }

  onWindowKeyDown(event) {
    if (this.active && event.key === 'Escape') {
      this.onCloseSubmenu();
      this.onClose();
      this.focusController();
    }
  }

  getChildren() {
    var _this$host$shadowRoot;

    var assignedElements = (_this$host$shadowRoot = this.host.shadowRoot.querySelector('slot')) === null || _this$host$shadowRoot === void 0 ? void 0 : _this$host$shadowRoot.assignedElements({
      flatten: true
    });
    return assignedElements !== null && assignedElements !== void 0 ? assignedElements : [];
  }

  getMenuItems() {
    var _this$host$shadowRoot2;

    var assignedElements = (_this$host$shadowRoot2 = this.host.shadowRoot.querySelector('slot')) === null || _this$host$shadowRoot2 === void 0 ? void 0 : _this$host$shadowRoot2.assignedElements({
      flatten: true
    });
    return menuItemHunter(assignedElements);
  }

  focusController() {
    var _this$controller2, _this$controller4;

    if (!isUndefined((_this$controller2 = this.controller) === null || _this$controller2 === void 0 ? void 0 : _this$controller2.focusItem)) {
      var _this$controller3;

      (_this$controller3 = this.controller) === null || _this$controller3 === void 0 ? void 0 : _this$controller3.focusItem();
    } else if (!isUndefined((_this$controller4 = this.controller) === null || _this$controller4 === void 0 ? void 0 : _this$controller4.focusControl)) {
      var _this$controller5;

      (_this$controller5 = this.controller) === null || _this$controller5 === void 0 ? void 0 : _this$controller5.focusControl();
    } else {
      var _this$controller6;

      (_this$controller6 = this.controller) === null || _this$controller6 === void 0 ? void 0 : _this$controller6.focus();
    }
  }

  triggerMenuItem() {
    var _this$activeMenuItem$;

    if (isUndefined(this.activeMenuItem)) return;
    this.activeMenuItem.click(); // If it controls a menu then focus it essentially opening it.

    (_this$activeMenuItem$ = this.activeMenuItem.menu) === null || _this$activeMenuItem$ === void 0 ? void 0 : _this$activeMenuItem$.focusMenu();
  }

  onClose() {
    this.activeMenuItem = undefined;
    this.active = false;
  }

  onClick(event) {
    // Stop the event from propagating while playing with menu so that when it is clicked outside
    // the menu we can close it in the `onWindowClick` handler above.
    event.stopPropagation();
  }

  onFocus() {
    var _this$activeMenuItem;

    this.active = true;
    [this.activeMenuItem] = this.getMenuItems();
    (_this$activeMenuItem = this.activeMenuItem) === null || _this$activeMenuItem === void 0 ? void 0 : _this$activeMenuItem.focusItem();
    this.vmFocus.emit();
  }

  onBlur() {
    this.vmBlur.emit();
  }

  foucsMenuItem(items, index) {
    if (index < 0) index = items.length - 1;
    if (index > items.length - 1) index = 0;
    this.activeMenuItem = items[index];
    this.activeMenuItem.focusItem();
  }

  onKeyDown(event) {
    if (!this.active) return;
    event.preventDefault();
    event.stopPropagation();
    var items = this.getMenuItems();
    var index = items.findIndex(item => item === this.activeMenuItem);

    switch (event.key) {
      case 'Escape':
        this.onClose();
        this.focusController();
        break;

      case 'ArrowDown':
      case 'Tab':
        this.foucsMenuItem(items, index += 1);
        break;

      case 'ArrowUp':
        this.foucsMenuItem(items, index -= 1);
        break;

      case 'ArrowLeft':
        this.onClose();
        this.focusController();
        break;

      case 'ArrowRight':
      case 'Enter':
      case ' ':
        this.triggerMenuItem();
        break;

      case 'Home':
      case 'PageUp':
        this.foucsMenuItem(items, 0);
        break;

      case 'End':
      case 'PageDown':
        this.foucsMenuItem(items, items.length - 1);
        break;
    }
  }

  render() {
    var _this$controller$iden, _this$controller7, _this$controller8;

    return (0, _client.h)("div", {
      id: this.identifier,
      class: {
        menu: true,
        slideIn: !isUndefined(this.slideInDirection),
        slideInFromLeft: this.slideInDirection === 'left',
        slideInFromRight: this.slideInDirection === 'right'
      },
      role: "menu",
      tabindex: "-1",
      "aria-labelledby": (_this$controller$iden = (_this$controller7 = this.controller) === null || _this$controller7 === void 0 ? void 0 : _this$controller7.identifier) !== null && _this$controller$iden !== void 0 ? _this$controller$iden : (_this$controller8 = this.controller) === null || _this$controller8 === void 0 ? void 0 : _this$controller8.id,
      "aria-hidden": !this.active ? 'true' : 'false',
      onFocus: this.onFocus.bind(this),
      onBlur: this.onBlur.bind(this),
      onClick: this.onClick.bind(this),
      onKeyDown: this.onKeyDown.bind(this),
      ref: el => {
        this.menu = el;
      }
    }, (0, _client.h)("div", {
      class: "container",
      ref: el => {
        this.container = el;
      }
    }, (0, _client.h)("slot", null)));
  }

  get host() {
    return this;
  }

  static get watchers() {
    return {
      "activeMenuItem": ["onActiveMenuitemChange"],
      "activeSubmenu": ["onActiveSubmenuChange"],
      "active": ["onActiveChange"]
    };
  }

  static get style() {
    return menuCss;
  }

};
var menuItemCss = ":host{display:block}.menuItem{display:flex;position:relative;align-items:center;flex-direction:row;cursor:pointer;color:var(--vm-menu-color);background:var(--vm-menu-bg);font-size:var(--vm-menu-font-size);font-weight:var(--vm-menu-font-weight);padding:var(--vm-menu-item-padding);touch-action:manipulation;box-sizing:border-box}.menuItem:focus{outline:0}.menuItem.hidden{display:none}.menuItem.tapHighlight{background:var(--vm-menu-item-tap-highlight)}.menuItem.showDivider{border-bottom:0.5px solid var(--vm-menu-item-divider-color)}.menuItem.notTouch:hover,.menuItem.notTouch:focus{outline:0;color:var(--vm-menu-item-focus-color);background-color:var(--vm-menu-item-focus-bg)}.menuItem[aria-expanded='true']{position:absolute;z-index:2;top:0;width:100%}.menuItem[aria-hidden='true']{display:none}.menuItem[aria-checked='true'] vm-icon{opacity:1;visibility:visible}vm-icon{display:inline-block}vm-icon{fill:currentColor;pointer-events:none;font-size:var(--vm-menu-item-check-icon-size);margin-right:10px;opacity:0;visibility:hidden;transition:var(--vm-fade-transition)}.hint{display:inline-block;margin-left:auto;overflow:hidden;pointer-events:none;margin-right:6px;font-size:var(--vm-menu-item-hint-font-size);opacity:var(--vm-menu-item-hint-opacity);color:var(--vm-menu-item-hint-color)}.badge{display:inline-block;line-height:1;overflow:hidden;pointer-events:none;margin-left:6px;color:var(--vm-menu-item-badge-color);background:var(--vm-menu-item-badge-bg);font-size:var(--vm-menu-item-badge-font-size)}.spacer{flex:1}.arrow{color:var(--vm-menu-item-arrow-color);border:2px solid;padding:2px;display:inline-block;border-width:0 2px 2px 0}.arrow.left{margin-right:6px;transform:rotate(135deg)}.arrow.right{transform:rotate(-45deg);opacity:0.38}";
var MenuItem = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.vmFocus = (0, _client.createEvent)(this, "vmFocus", 7);
    this.vmBlur = (0, _client.createEvent)(this, "vmBlur", 7);
    this.showTapHighlight = false;
    /**
     * Whether the item is displayed or not.
     */

    this.hidden = false;
    /**
     * The name of the checkmark icon to resolve from the icon library.
     */

    this.checkIcon = 'check';
    /** @internal */

    this.isTouch = false;
    withComponentRegistry(this);
    withPlayerContext(this, ['isTouch']);
  }
  /**
   * Focuses the menu item.
   */


  focusItem() {
    var _this38 = this;

    return _asyncToGenerator(function* () {
      var _this38$menuItem;

      (_this38$menuItem = _this38.menuItem) === null || _this38$menuItem === void 0 ? void 0 : _this38$menuItem.focus();
    })();
  }
  /**
   * Removes focus from the menu item.
   */


  blurItem() {
    var _this39 = this;

    return _asyncToGenerator(function* () {
      var _this39$menuItem;

      (_this39$menuItem = _this39.menuItem) === null || _this39$menuItem === void 0 ? void 0 : _this39$menuItem.blur();
    })();
  }
  /**
   * Returns the height of the menu item.
   */


  getHeight() {
    var _this40 = this;

    return _asyncToGenerator(function* () {
      return parseFloat(_this40.menuItem ? window.getComputedStyle(_this40.menuItem).height : '0');
    })();
  }

  onClick() {
    if (!isNullOrUndefined(this.menu)) this.menu.active = !this.expanded;
  }

  onFocus() {
    this.vmFocus.emit();
  }

  onBlur() {
    this.vmBlur.emit();
  }

  onTouchStart() {
    this.showTapHighlight = true;
  }

  onTouchEnd() {
    setTimeout(() => {
      this.showTapHighlight = false;
    }, 100);
  }

  onMouseLeave() {
    var _this$menuItem;

    (_this$menuItem = this.menuItem) === null || _this$menuItem === void 0 ? void 0 : _this$menuItem.blur();
  }

  render() {
    var _this$expanded, _this$menu$identifier, _this$menu, _this$menu2;

    var isCheckedDefined = !isUndefined(this.checked);
    var isMenuDefined = !isUndefined(this.menu);
    var hasExpanded = this.expanded ? 'true' : 'false';
    var isChecked = this.checked ? 'true' : 'false';
    var showCheckedIcon = isCheckedDefined && !isUndefined(this.checkIcon);
    var showLeftNavArrow = isMenuDefined && this.expanded;
    var showRightNavArrow = isMenuDefined && !this.expanded;
    var showHint = !isUndefined(this.hint) && !isCheckedDefined && (!isMenuDefined || !this.expanded);
    var showBadge = !isUndefined(this.badge) && !showHint && !showRightNavArrow;
    var hasSpacer = showHint || showRightNavArrow;
    return (0, _client.h)("div", {
      class: {
        menuItem: true,
        notTouch: !this.isTouch,
        tapHighlight: this.showTapHighlight,
        showDivider: isMenuDefined && ((_this$expanded = this.expanded) !== null && _this$expanded !== void 0 ? _this$expanded : false)
      },
      id: this.identifier,
      role: isCheckedDefined ? 'menuitemradio' : 'menuitem',
      tabindex: "0",
      "aria-label": this.label,
      "aria-hidden": this.hidden ? 'true' : 'false',
      "aria-haspopup": isMenuDefined ? 'true' : undefined,
      "aria-controls": (_this$menu$identifier = (_this$menu = this.menu) === null || _this$menu === void 0 ? void 0 : _this$menu.identifier) !== null && _this$menu$identifier !== void 0 ? _this$menu$identifier : (_this$menu2 = this.menu) === null || _this$menu2 === void 0 ? void 0 : _this$menu2.id,
      "aria-expanded": isMenuDefined ? hasExpanded : undefined,
      "aria-checked": isCheckedDefined ? isChecked : undefined,
      onClick: this.onClick.bind(this),
      onFocus: this.onFocus.bind(this),
      onBlur: this.onBlur.bind(this),
      onTouchStart: this.onTouchStart.bind(this),
      onTouchEnd: this.onTouchEnd.bind(this),
      onMouseLeave: this.onMouseLeave.bind(this),
      ref: el => {
        this.menuItem = el;
      }
    }, showCheckedIcon && (0, _client.h)("vm-icon", {
      name: this.checkIcon,
      library: this.icons
    }), showLeftNavArrow && (0, _client.h)("span", {
      class: "arrow left"
    }), this.label, hasSpacer && (0, _client.h)("span", {
      class: "spacer"
    }), showHint && (0, _client.h)("span", {
      class: "hint"
    }, this.hint), showBadge && (0, _client.h)("span", {
      class: "badge"
    }, this.badge), showRightNavArrow && (0, _client.h)("span", {
      class: "arrow right"
    }));
  }

  get host() {
    return this;
  }

  static get style() {
    return menuItemCss;
  }

};
var MenuRadio = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.vmCheck = (0, _client.createEvent)(this, "vmCheck", 7);
    /**
     * Whether the radio item is selected or not.
     */

    this.checked = false;
    /**
     * The URL to an SVG element or fragment to load.
     */

    this.checkIcon = 'check';
    withComponentRegistry(this);
  }

  onClick() {
    this.checked = true;
    this.vmCheck.emit();
  }

  render() {
    return (0, _client.h)("vm-menu-item", {
      label: this.label,
      checked: this.checked,
      badge: this.badge,
      checkIcon: this.checkIcon,
      icons: this.icons,
      onClick: this.onClick.bind(this)
    });
  }

};
var MenuRadioGroup = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.vmCheck = (0, _client.createEvent)(this, "vmCheck", 7);
    withComponentRegistry(this);
  }

  onValueChange() {
    var _this$findRadios;

    (_this$findRadios = this.findRadios()) === null || _this$findRadios === void 0 ? void 0 : _this$findRadios.forEach(radio => {
      radio.checked = radio.value === this.value;
    });
  }

  connectedCallback() {
    this.onValueChange();
  }

  componentDidLoad() {
    this.onValueChange();
  }

  onSelectionChange(event) {
    var radio = event.target;
    this.value = radio.value;
  }

  findRadios() {
    var _this$host$shadowRoot3;

    return (_this$host$shadowRoot3 = this.host.shadowRoot.querySelector('slot')) === null || _this$host$shadowRoot3 === void 0 ? void 0 : _this$host$shadowRoot3.assignedElements();
  }

  render() {
    return (0, _client.h)("slot", null);
  }

  get host() {
    return this;
  }

  static get watchers() {
    return {
      "value": ["onValueChange"]
    };
  }

};
var MuteControl = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.vmFocus = (0, _client.createEvent)(this, "vmFocus", 7);
    this.vmBlur = (0, _client.createEvent)(this, "vmBlur", 7);
    /**
     * The name of the low volume icon to resolve from the icon library.
     */

    this.lowVolumeIcon = 'volume-low';
    /**
     * The name of the high volume icon to resolve from the icon library.
     */

    this.highVolumeIcon = 'volume-high';
    /**
     * The name of the muted volume icon to resolve from the icon library.
     */

    this.mutedIcon = 'volume-mute';
    /**
     * Whether the tooltip is positioned above/below the control.
     */

    this.tooltipPosition = 'top';
    /**
     * Whether the tooltip should not be displayed.
     */

    this.hideTooltip = false;
    /** @inheritdoc */

    this.keys = 'm';
    /** @internal */

    this.volume = 50;
    /** @internal */

    this.muted = false;
    /** @internal */

    this.i18n = {};
    withComponentRegistry(this);
    withPlayerContext(this, ['muted', 'volume', 'i18n']);
  }

  connectedCallback() {
    this.dispatch = createDispatcher(this);
  }

  getIcon() {
    var volumeIcon = this.volume < 50 ? this.lowVolumeIcon : this.highVolumeIcon;
    return this.muted || this.volume === 0 ? this.mutedIcon : volumeIcon;
  }

  onClick() {
    this.dispatch('muted', !this.muted);
  }

  render() {
    var tooltip = this.muted ? this.i18n.unmute : this.i18n.mute;
    var tooltipWithHint = !isUndefined(this.keys) ? "".concat(tooltip, " (").concat(this.keys, ")") : tooltip;
    return (0, _client.h)("vm-control", {
      label: this.i18n.mute,
      pressed: this.muted,
      keys: this.keys,
      onClick: this.onClick.bind(this)
    }, (0, _client.h)("vm-icon", {
      name: this.getIcon(),
      library: this.icons
    }), (0, _client.h)("vm-tooltip", {
      hidden: this.hideTooltip,
      position: this.tooltipPosition,
      direction: this.tooltipDirection
    }, tooltipWithHint));
  }

};
var pipControlCss = ":host([hidden]){display:none}";
var PiPControl = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.canSetPiP = false;
    /**
     * The name of the enter pip icon to resolve from the icon library.
     */

    this.enterIcon = 'pip-enter';
    /**
     * The name of the exit pip icon to resolve from the icon library.
     */

    this.exitIcon = 'pip-exit';
    /**
     * Whether the tooltip is positioned above/below the control.
     */

    this.tooltipPosition = 'top';
    /**
     * Whether the tooltip should not be displayed.
     */

    this.hideTooltip = false;
    /** @inheritdoc */

    this.keys = 'p';
    /** @internal */

    this.isPiPActive = false;
    /** @internal */

    this.i18n = {};
    /** @internal */

    this.playbackReady = false;
    withComponentRegistry(this);
    withPlayerContext(this, ['isPiPActive', 'playbackReady', 'i18n']);
  }

  onPlaybackReadyChange() {
    var _this41 = this;

    return _asyncToGenerator(function* () {
      var _yield$player$canSetP;

      var player = getPlayerFromRegistry(_this41);
      _this41.canSetPiP = (_yield$player$canSetP = yield player === null || player === void 0 ? void 0 : player.canSetPiP()) !== null && _yield$player$canSetP !== void 0 ? _yield$player$canSetP : false;
    })();
  }

  componentDidLoad() {
    this.onPlaybackReadyChange();
  }

  onClick() {
    var player = getPlayerFromRegistry(this);
    !this.isPiPActive ? player === null || player === void 0 ? void 0 : player.enterPiP() : player === null || player === void 0 ? void 0 : player.exitPiP();
  }

  render() {
    var tooltip = this.isPiPActive ? this.i18n.exitPiP : this.i18n.enterPiP;
    var tooltipWithHint = !isUndefined(this.keys) ? "".concat(tooltip, " (").concat(this.keys, ")") : tooltip;
    return (0, _client.h)(_client.Host, {
      hidden: !this.canSetPiP
    }, (0, _client.h)("vm-control", {
      label: this.i18n.pip,
      keys: this.keys,
      pressed: this.isPiPActive,
      hidden: !this.canSetPiP,
      onClick: this.onClick.bind(this)
    }, (0, _client.h)("vm-icon", {
      name: this.isPiPActive ? this.exitIcon : this.enterIcon,
      library: this.icons
    }), (0, _client.h)("vm-tooltip", {
      hidden: this.hideTooltip,
      position: this.tooltipPosition,
      direction: this.tooltipDirection
    }, tooltipWithHint)));
  }

  static get watchers() {
    return {
      "playbackReady": ["onPlaybackReadyChange"]
    };
  }

  static get style() {
    return pipControlCss;
  }

};
var PlaybackControl = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    /**
     * The name of the play icon to resolve from the icon library.
     */

    this.playIcon = 'play';
    /**
     * The name of the pause icon to resolve from the icon library.
     */

    this.pauseIcon = 'pause';
    /**
     * Whether the tooltip is positioned above/below the control.
     */

    this.tooltipPosition = 'top';
    /**
     * Whether the tooltip should not be displayed.
     */

    this.hideTooltip = false;
    /** @inheritdoc */

    this.keys = 'k';
    /** @internal */

    this.paused = true;
    /** @internal */

    this.i18n = {};
    withComponentRegistry(this);
    withPlayerContext(this, ['paused', 'i18n']);
  }

  connectedCallback() {
    this.dispatch = createDispatcher(this);
  }

  onClick() {
    this.dispatch('paused', !this.paused);
  }

  render() {
    var tooltip = this.paused ? this.i18n.play : this.i18n.pause;
    var tooltipWithHint = !isUndefined(this.keys) ? "".concat(tooltip, " (").concat(this.keys, ")") : tooltip;
    return (0, _client.h)("vm-control", {
      label: this.i18n.playback,
      keys: this.keys,
      pressed: !this.paused,
      onClick: this.onClick.bind(this)
    }, (0, _client.h)("vm-icon", {
      name: this.paused ? this.playIcon : this.pauseIcon,
      library: this.icons
    }), (0, _client.h)("vm-tooltip", {
      hidden: this.hideTooltip,
      position: this.tooltipPosition,
      direction: this.tooltipDirection
    }, tooltipWithHint));
  }

};
var apiMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror', 'fullscreen'], // WebKit
['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror', '-webkit-full-screen'], // Mozilla
['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror', '-moz-full-screen'], // Microsoft
['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError', '-ms-fullscreen']];
/**
 * Normalizes native fullscreen API differences across browsers.
 *
 * @ref https://github.com/videojs/video.js/blob/7.6.x/src/js/fullscreen-api.js
 */

var getFullscreenApi = () => {
  var api = {
    prefixed: false
  };
  var specApi = apiMap[0];
  var browserApi; // Determine the supported set of functions.

  for (var i = 0; i < apiMap.length; i += 1) {
    // Check for exitFullscreen function.
    if (apiMap[i][1] in document) {
      browserApi = apiMap[i];
      break;
    }
  } // Map the browser API names to the spec API names.


  if (browserApi) {
    for (var _i = 0; _i < browserApi.length; _i += 1) {
      api[specApi[_i]] = browserApi[_i];
    }

    api.prefixed = browserApi[0] !== specApi[0];
  }

  return api;
};

class Fullscreen {
  constructor(el, listener) {
    this.el = el;
    this.listener = listener;
    this.disposal = new Disposal();
    this.api = getFullscreenApi();

    if (this.isSupported) {
      this.disposal.add(listen(this.el, this.api.fullscreenchange, this.onFullscreenChange.bind(this)));
      /* *
       * We have to listen to this on webkit, because no `fullscreenchange` event is fired when the
       * video element enters or exits fullscreen by:
       *
       *  1. Clicking the native Html5 fullscreen video control.
       *  2. Calling requestFullscreen from the video element directly.
       *  3. Calling requestFullscreen inside an iframe.
       * */

      if (document.webkitExitFullscreen) {
        this.disposal.add(listen(this.el, 'webkitfullscreenchange', this.onFullscreenChange.bind(this)));
      } // We listen to this for the same reasons as above except when the browser is Firefox.


      if (document.mozCancelFullScreen) {
        this.disposal.add(listen(this.el, 'mozfullscreenchange', this.onFullscreenChange.bind(this)));
      }
    }
  }

  enterFullscreen(options) {
    var _this42 = this;

    return _asyncToGenerator(function* () {
      if (!_this42.isSupported) throw Error('Fullscreen API is not available.');
      return _this42.el[_this42.api.requestFullscreen](options);
    })();
  }

  exitFullscreen() {
    var _this43 = this;

    return _asyncToGenerator(function* () {
      if (!_this43.isSupported) throw Error('Fullscreen API is not available.');
      if (!_this43.isActive) throw Error('Player is not currently in fullscreen mode to exit.');
      return document[_this43.api.exitFullscreen]();
    })();
  }

  get isActive() {
    if (!this.isSupported) return false;
    var fullscreenEl = document[this.api.fullscreenElement];
    return this.el === fullscreenEl || this.el.matches(":".concat(this.api.fullscreen)) || this.el.contains(fullscreenEl);
  }

  get isSupported() {
    return !isUndefined(this.api.requestFullscreen);
  }

  onFullscreenChange() {
    this.listener(this.isActive);
  }

  destroy() {
    this.disposal.empty();
  }

}

class Logger {
  constructor() {
    this.silent = false;
  }

  log() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    if (!this.silent && !isUndefined(console)) console.log('[Vime tip]:', ...args);
  }

  warn() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    if (!this.silent && !isUndefined(console)) console.error('[Vime warn]:', ...args);
  }

}

var players = new Set();

function withAutopause(player) {
  var el = (0, _client.getElement)(player);
  createStencilHook(player, () => {
    players.add(el);
  }, () => {
    players.delete(el);
  });
}

function autopause(player) {
  var el = (0, _client.getElement)(player);
  players.forEach(p => {
    if (p !== el && p.autopause) p.paused = true;
  });
}
/* eslint-disable func-names */


function withPlayerEvents(player) {
  var el = (0, _client.getElement)(player);
  var cache = new Map();

  function initCache() {
    Object.keys(initialState).forEach(prop => {
      cache.set(prop, player[prop]);
    });
  }

  createStencilHook(player, () => {
    initCache();
  }, () => {
    cache.clear();
  });
  var {
    componentDidRender
  } = player;

  player.componentDidRender = function () {
    componentDidRender === null || componentDidRender === void 0 ? void 0 : componentDidRender();
    var props = Array.from(cache.keys());

    for (var i = 0; i < props.length; i += 1) {
      var prop = props[i];
      var oldValue = cache.get(prop);
      var newValue = player[prop];

      if (oldValue !== newValue) {
        firePlayerEvent(el, prop, newValue, oldValue);
        cache.set(prop, newValue);
      }
    }
  };
}
/* eslint-disable func-names */
// These changes need to be called immediately to avoid the browser blocking the request.


var immediateAdapterCall = new Set(['currentTime', 'paused']);

function withPlayerScheduler(player) {
  var el = (0, _client.getElement)(player);
  var cache = new Map();
  var disposal = new Disposal();

  function initCache() {
    Object.keys(initialState).forEach(prop => {
      cache.set(prop, player[prop]);
    });
  } // Queue of adapter calls to be run when the media is ready for playback.


  var adapterCalls = [];

  function flushAdapterCalls() {
    return _flushAdapterCalls.apply(this, arguments);
  }

  function _flushAdapterCalls() {
    _flushAdapterCalls = _asyncToGenerator(function* () {
      var adapter = yield player.adapter;
      if (isUndefined(adapter)) return;

      for (var i = 0; i < adapterCalls.length; i += 1) {
        // eslint-disable-next-line no-await-in-loop
        yield adapterCalls[i](adapter);
      }

      adapterCalls = [];
    });
    return _flushAdapterCalls.apply(this, arguments);
  }

  var hasMediaChanged = false;

  function onMediaChange(e) {
    e === null || e === void 0 ? void 0 : e.stopImmediatePropagation(); // Don't reset first time otherwise props intialized by the user will be reset.

    if (!hasMediaChanged) {
      hasMediaChanged = true;
      return;
    }

    adapterCalls = [];
    (0, _client.writeTask)(() => {
      Object.keys(initialState).filter(shouldPropResetOnMediaChange).forEach(prop => {
        player[prop] = initialState[prop];
      });
    });
  }

  function onStateChange(_x29) {
    return _onStateChange.apply(this, arguments);
  } // Called by ProviderConnect.


  function _onStateChange() {
    _onStateChange = _asyncToGenerator(function* (event) {
      event.stopImmediatePropagation();
      var {
        by,
        prop,
        value
      } = event.detail;

      if (!isWritableProp(prop)) {
        var _player$logger;

        (_player$logger = player.logger) === null || _player$logger === void 0 ? void 0 : _player$logger.warn("".concat(by.nodeName, " tried to change `").concat(prop, "` but it is readonly."));
        return;
      }

      if (!player.playbackStarted && immediateAdapterCall.has(prop)) {
        var adapter = yield player.adapter;

        if (prop === 'paused' && !value) {
          adapter === null || adapter === void 0 ? void 0 : adapter.play();
        }

        if (prop === 'currentTime') {
          adapter === null || adapter === void 0 ? void 0 : adapter.play();
          adapter === null || adapter === void 0 ? void 0 : adapter.setCurrentTime(value);
        }
      }

      (0, _client.writeTask)(() => {
        player[prop] = value;
      });
    });
    return _onStateChange.apply(this, arguments);
  }

  var {
    onProviderDisconnect
  } = player;

  player.onProviderDisconnect = function () {
    onMediaChange();
    if (onProviderDisconnect) onProviderDisconnect.call(player);
  };

  createStencilHook(player, () => {
    initCache();
    disposal.add(listen(el, LOAD_START_EVENT, onMediaChange));
    disposal.add(listen(el, STATE_CHANGE_EVENT, onStateChange));
  }, () => {
    cache.clear();
    disposal.empty();
  });
  wrapStencilHook(player, 'componentWillRender', /*#__PURE__*/_asyncToGenerator(function* () {
    if (player.playbackReady && adapterCalls.length > 0) yield flushAdapterCalls();
  }));

  function isAdapterCallRequired(prop, value) {
    var _player$PROVIDER_CACH;

    return value !== ((_player$PROVIDER_CACH = player[PROVIDER_CACHE_KEY]) === null || _player$PROVIDER_CACH === void 0 ? void 0 : _player$PROVIDER_CACH.get(prop));
  }

  return /*#__PURE__*/function () {
    var _safeAdapterCall = _asyncToGenerator(function* (prop, method) {
      if (!isAdapterCallRequired(prop, player[prop])) return;
      var value = player[prop];

      var safeCall = /*#__PURE__*/function () {
        var _ref10 = _asyncToGenerator(function* (adapter) {
          try {
            var _adapter$method;

            // @ts-ignore
            yield adapter === null || adapter === void 0 ? void 0 : (_adapter$method = adapter[method]) === null || _adapter$method === void 0 ? void 0 : _adapter$method.call(adapter, value);
          } catch (e) {
            el.dispatchEvent(new CustomEvent('vmError', {
              detail: e
            }));
          }
        });

        return function safeCall(_x32) {
          return _ref10.apply(this, arguments);
        };
      }();

      if (player.playbackReady) {
        yield safeCall(yield player.adapter);
      } else {
        adapterCalls.push(safeCall);
      }
    });

    function safeAdapterCall(_x30, _x31) {
      return _safeAdapterCall.apply(this, arguments);
    }

    return safeAdapterCall;
  }();
}

var playerCss = ".player{box-sizing:border-box;direction:ltr;font-family:var(--vm-player-font-family);-moz-osx-font-smoothing:auto;-webkit-font-smoothing:subpixel-antialiased;-webkit-tap-highlight-color:transparent;font-variant-numeric:tabular-nums;font-weight:500;line-height:1.7;width:100%;display:block;max-width:100%;min-width:275px;min-height:40px;position:relative;text-shadow:none;outline:0;transition:box-shadow 0.3s ease;box-shadow:var(--vm-player-box-shadow);border-radius:var(--vm-player-border-radius)}.player.idle{cursor:none}.player.audio{background-color:transparent !important}.player.video{height:0;overflow:hidden;background-color:var(--vm-player-bg, #000)}.player.fullscreen{margin:0;border-radius:0;width:100%;height:100%;padding-bottom:0 !important}.blocker{position:absolute;top:0;left:0;width:100%;height:100%;display:inline-block;z-index:var(--vm-blocker-z-index)}";
var idCount$1 = 0;
var Player = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.vmThemeChange = (0, _client.createEvent)(this, "vmThemeChange", 7);
    this.vmPausedChange = (0, _client.createEvent)(this, "vmPausedChange", 7);
    this.vmPlay = (0, _client.createEvent)(this, "vmPlay", 7);
    this.vmPlayingChange = (0, _client.createEvent)(this, "vmPlayingChange", 7);
    this.vmSeekingChange = (0, _client.createEvent)(this, "vmSeekingChange", 7);
    this.vmSeeked = (0, _client.createEvent)(this, "vmSeeked", 7);
    this.vmBufferingChange = (0, _client.createEvent)(this, "vmBufferingChange", 7);
    this.vmDurationChange = (0, _client.createEvent)(this, "vmDurationChange", 7);
    this.vmCurrentTimeChange = (0, _client.createEvent)(this, "vmCurrentTimeChange", 7);
    this.vmReady = (0, _client.createEvent)(this, "vmReady", 7);
    this.vmPlaybackReady = (0, _client.createEvent)(this, "vmPlaybackReady", 7);
    this.vmPlaybackStarted = (0, _client.createEvent)(this, "vmPlaybackStarted", 7);
    this.vmPlaybackEnded = (0, _client.createEvent)(this, "vmPlaybackEnded", 7);
    this.vmBufferedChange = (0, _client.createEvent)(this, "vmBufferedChange", 7);
    this.vmError = (0, _client.createEvent)(this, "vmError", 7);
    this.vmLoadStart = (0, _client.createEvent)(this, "vmLoadStart", 7);
    this.vmCurrentProviderChange = (0, _client.createEvent)(this, "vmCurrentProviderChange", 7);
    this.vmCurrentSrcChange = (0, _client.createEvent)(this, "vmCurrentSrcChange", 7);
    this.vmCurrentPosterChange = (0, _client.createEvent)(this, "vmCurrentPosterChange", 7);
    this.vmMediaTitleChange = (0, _client.createEvent)(this, "vmMediaTitleChange", 7);
    this.vmControlsChange = (0, _client.createEvent)(this, "vmControlsChange", 7);
    this.vmPlaybackRateChange = (0, _client.createEvent)(this, "vmPlaybackRateChange", 7);
    this.vmPlaybackRatesChange = (0, _client.createEvent)(this, "vmPlaybackRatesChange", 7);
    this.vmPlaybackQualityChange = (0, _client.createEvent)(this, "vmPlaybackQualityChange", 7);
    this.vmPlaybackQualitiesChange = (0, _client.createEvent)(this, "vmPlaybackQualitiesChange", 7);
    this.vmMutedChange = (0, _client.createEvent)(this, "vmMutedChange", 7);
    this.vmVolumeChange = (0, _client.createEvent)(this, "vmVolumeChange", 7);
    this.vmViewTypeChange = (0, _client.createEvent)(this, "vmViewTypeChange", 7);
    this.vmMediaTypeChange = (0, _client.createEvent)(this, "vmMediaTypeChange", 7);
    this.vmLiveChange = (0, _client.createEvent)(this, "vmLiveChange", 7);
    this.vmTouchChange = (0, _client.createEvent)(this, "vmTouchChange", 7);
    this.vmLanguageChange = (0, _client.createEvent)(this, "vmLanguageChange", 7);
    this.vmI18nChange = (0, _client.createEvent)(this, "vmI18nChange", 7);
    this.vmTranslationsChange = (0, _client.createEvent)(this, "vmTranslationsChange", 7);
    this.vmLanguagesChange = (0, _client.createEvent)(this, "vmLanguagesChange", 7);
    this.vmFullscreenChange = (0, _client.createEvent)(this, "vmFullscreenChange", 7);
    this.vmPiPChange = (0, _client.createEvent)(this, "vmPiPChange", 7);
    this.vmTextTracksChange = (0, _client.createEvent)(this, "vmTextTracksChange", 7);
    this.vmCurrentTextTrackChange = (0, _client.createEvent)(this, "vmCurrentTextTrackChange", 7);
    this.vmTextTrackVisibleChange = (0, _client.createEvent)(this, "vmTextTrackVisibleChange", 7);
    this.vmAudioTracksChange = (0, _client.createEvent)(this, "vmAudioTracksChange", 7);
    this.vmCurrentAudioTrackChange = (0, _client.createEvent)(this, "vmCurrentAudioTrackChange", 7);
    this.disposal = new Disposal();
    /**
     * ------------------------------------------------------
     * Props
     * ------------------------------------------------------
     */

    /** @internal @readonly */

    this.logger = new Logger();
    /** @inheritDoc */

    this.icons = 'vime';
    /** @inheritDoc */

    this.paused = true;
    /** @inheritDoc @readonly */

    this.playing = false;
    /** @inheritDoc @readonly */

    this.duration = -1;
    /** @inheritDoc */

    this.currentTime = 0;
    /** @inheritDoc */

    this.autoplay = false;
    /** @inheritDoc @readonly */

    this.ready = false;
    /** @inheritDoc @readonly */

    this.playbackReady = false;
    /** @inheritDoc */

    this.loop = false;
    /** @inheritDoc */

    this.muted = false;
    /** @inheritDoc @readonly */

    this.buffered = 0;
    /** @inheritDoc */

    this.playbackRate = 1;
    this.lastRateCheck = 1;
    /** @inheritDoc @readonly */

    this.playbackRates = [1];
    /** @inheritDoc @readonly */

    this.playbackQualities = [];
    /** @inheritDoc @readonly */

    this.seeking = false;
    /** @inheritDoc */

    this.debug = false;
    /** @inheritDoc @readonly */

    this.playbackStarted = false;
    /** @inheritDoc @readonly */

    this.playbackEnded = false;
    /** @inheritDoc @readonly */

    this.buffering = false;
    /** @inheritDoc */

    this.controls = false;
    /** @inheritDoc */

    this.isControlsActive = false;
    /** @inheritDoc @readonly */

    this.isSettingsActive = false;
    /** @inheritDoc */

    this.volume = 50;
    /** @inheritDoc @readonly */

    this.isFullscreenActive = false;
    /** @inheritDoc */

    this.aspectRatio = '16:9';
    /** @inheritDoc @readonly */

    this.isAudioView = false;
    /** @inheritDoc @readonly */

    this.isVideoView = false;
    /** @inheritDoc @readonly */

    this.isAudio = false;
    /** @inheritDoc @readonly */

    this.isVideo = false;
    /** @inheritDoc @readonly */

    this.isLive = false;
    /** @inheritDoc @readonly */

    this.isMobile = false;
    /** @inheritDoc @readonly */

    this.isTouch = false;
    /** @inheritDoc @readonly */

    this.isPiPActive = false;
    /** @inheritDoc @readonly */

    this.textTracks = [];
    /** @inheritDoc @readonly */

    this.currentTextTrack = -1;
    /** @inheritDoc @readonly */

    this.isTextTrackVisible = true;
    /** @inheritDoc */

    this.shouldRenderNativeTextTracks = true;
    /** @inheritDoc @readonly */

    this.audioTracks = [];
    /** @inheritDoc @readonly */

    this.currentAudioTrack = -1;
    /** @inheritDoc */

    this.autopause = true;
    /** @inheritDoc */

    this.playsinline = false;
    /** @inheritDoc */

    this.language = 'en';
    /** @inheritDoc */

    this.translations = {
      en
    };
    /** @inheritDoc @readonly */

    this.languages = ['en'];
    /** @inheritDoc @readonly */

    this.i18n = en;
    withFindPlayer(this);
    withComponentRegistrar(this);
    withAutopause(this);
    withProviderHost(this);
    withPlayerEvents(this);
    this.safeAdapterCall = withPlayerScheduler(this);
  }

  get adapter() {
    var _this$provider;

    return (_this$provider = this.provider) === null || _this$provider === void 0 ? void 0 : _this$provider.getAdapter();
  }

  onContainerChange() {
    var _this$fullscreen;

    (_this$fullscreen = this.fullscreen) === null || _this$fullscreen === void 0 ? void 0 : _this$fullscreen.destroy();
    if (isUndefined(this.container)) return;
    this.fullscreen = new Fullscreen(this.container, isActive => {
      this.isFullscreenActive = isActive;
      this.rotateDevice();
    });
  }

  onPausedChange() {
    if (this.paused) {
      this.playing = false;
    } else {
      autopause(this);
    }

    this.safeAdapterCall('paused', !this.paused ? 'play' : 'pause');
  }

  onDurationChange() {
    this.isLive = this.duration === Infinity;
  }

  onCurrentTimeChange() {
    var duration = this.playbackReady ? this.duration : Infinity;
    this.currentTime = Math.max(0, Math.min(this.currentTime, duration));
    this.safeAdapterCall('currentTime', 'setCurrentTime');
  }

  onPlaybackReadyChange() {
    if (!this.ready) this.ready = true;
  }

  onMutedChange() {
    this.safeAdapterCall('muted', 'setMuted');
  }

  onPlaybackRateChange(newRate, prevRate) {
    var _this44 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this44$adapte, _yield$_this44$adapte2;

      if (newRate === _this44.lastRateCheck) return;

      if (!(yield (_yield$_this44$adapte = yield _this44.adapter) === null || _yield$_this44$adapte === void 0 ? void 0 : (_yield$_this44$adapte2 = _yield$_this44$adapte.canSetPlaybackRate) === null || _yield$_this44$adapte2 === void 0 ? void 0 : _yield$_this44$adapte2.call(_yield$_this44$adapte))) {
        _this44.logger.log('provider cannot change `playbackRate`.');

        _this44.lastRateCheck = prevRate;
        _this44.playbackRate = prevRate;
        return;
      }

      if (!_this44.playbackRates.includes(newRate)) {
        _this44.logger.log("invalid `playbackRate` of ".concat(newRate, ", ") + "valid values are [".concat(_this44.playbackRates.join(', '), "]"));

        _this44.lastRateCheck = prevRate;
        _this44.playbackRate = prevRate;
        return;
      }

      _this44.lastRateCheck = newRate;

      _this44.safeAdapterCall('playbackRate', 'setPlaybackRate');
    })();
  }

  onPlaybackQualityChange(newQuality, prevQuality) {
    var _this45 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this45$adapte, _yield$_this45$adapte2;

      if (isUndefined(newQuality) || newQuality === _this45.lastQualityCheck) return;

      if (!(yield (_yield$_this45$adapte = yield _this45.adapter) === null || _yield$_this45$adapte === void 0 ? void 0 : (_yield$_this45$adapte2 = _yield$_this45$adapte.canSetPlaybackQuality) === null || _yield$_this45$adapte2 === void 0 ? void 0 : _yield$_this45$adapte2.call(_yield$_this45$adapte))) {
        _this45.logger.log('provider cannot change `playbackQuality`.');

        _this45.lastQualityCheck = prevQuality;
        _this45.playbackQuality = prevQuality;
        return;
      }

      if (!_this45.playbackQualities.includes(newQuality)) {
        _this45.logger.log("invalid `playbackQuality` of ".concat(newQuality, ", ") + "valid values are [".concat(_this45.playbackQualities.join(', '), "]"));

        _this45.lastQualityCheck = prevQuality;
        _this45.playbackQuality = prevQuality;
        return;
      }

      _this45.lastQualityCheck = newQuality;

      _this45.safeAdapterCall('playbackQuality', 'setPlaybackQuality');
    })();
  }

  onDebugChange() {
    this.logger.silent = !this.debug;
  }

  onVolumeChange() {
    var _this46 = this;

    return _asyncToGenerator(function* () {
      _this46.volume = Math.max(0, Math.min(_this46.volume, 100));

      _this46.safeAdapterCall('volume', 'setVolume');
    })();
  }

  onViewTypeChange() {
    this.isAudioView = this.viewType === ViewType.Audio;
    this.isVideoView = this.viewType === ViewType.Video;
  }

  onMediaTypeChange() {
    this.isAudio = this.mediaType === MediaType.Audio;
    this.isVideo = this.mediaType === MediaType.Video;
  }

  onLanguageChange(_, prevLanguage) {
    if (!this.languages.includes(this.language)) {
      this.logger.log("invalid `language` of ".concat(this.language, ", ") + "valid values are [".concat(this.languages.join(', '), "]"));
      this.language = prevLanguage;
      return;
    }

    this.i18n = this.translations[this.language];
  }

  onTranslationsChange() {
    Object.assign(this.translations, {
      en
    });
    this.languages = Object.keys(this.translations);
    this.i18n = this.translations[this.language];
  }

  onError(event) {
    this.logger.warn(event.detail);
  }
  /**
   * ------------------------------------------------------
   * Methods
   * ------------------------------------------------------
   */

  /** @inheritDoc */


  getProvider() {
    var _this47 = this;

    return _asyncToGenerator(function* () {
      return _this47.provider;
    })();
  }
  /** @internal */


  getAdapter() {
    var _this48 = this;

    return _asyncToGenerator(function* () {
      return _this48.adapter;
    })();
  }
  /** @inheritDoc */


  play() {
    var _this49 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this49$adapte;

      return (_yield$_this49$adapte = yield _this49.adapter) === null || _yield$_this49$adapte === void 0 ? void 0 : _yield$_this49$adapte.play();
    })();
  }
  /** @inheritDoc */


  pause() {
    var _this50 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this50$adapte;

      return (_yield$_this50$adapte = yield _this50.adapter) === null || _yield$_this50$adapte === void 0 ? void 0 : _yield$_this50$adapte.pause();
    })();
  }
  /** @inheritDoc */


  canPlay(type) {
    var _this51 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this51$adapte, _yield$_this51$adapte2;

      return (_yield$_this51$adapte = (_yield$_this51$adapte2 = yield _this51.adapter) === null || _yield$_this51$adapte2 === void 0 ? void 0 : _yield$_this51$adapte2.canPlay(type)) !== null && _yield$_this51$adapte !== void 0 ? _yield$_this51$adapte : false;
    })();
  }
  /** @inheritDoc */


  canAutoplay() {
    return _asyncToGenerator(function* () {
      return canAutoplay();
    })();
  }
  /** @inheritDoc */


  canMutedAutoplay() {
    return _asyncToGenerator(function* () {
      return canAutoplay(true);
    })();
  }
  /** @inheritDoc */


  canSetPlaybackRate() {
    var _this52 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this52$adapte, _yield$_this52$adapte2, _yield$_this52$adapte3;

      return (_yield$_this52$adapte = (_yield$_this52$adapte2 = yield _this52.adapter) === null || _yield$_this52$adapte2 === void 0 ? void 0 : (_yield$_this52$adapte3 = _yield$_this52$adapte2.canSetPlaybackRate) === null || _yield$_this52$adapte3 === void 0 ? void 0 : _yield$_this52$adapte3.call(_yield$_this52$adapte2)) !== null && _yield$_this52$adapte !== void 0 ? _yield$_this52$adapte : false;
    })();
  }
  /** @inheritDoc */


  canSetPlaybackQuality() {
    var _this53 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this53$adapte, _yield$_this53$adapte2, _yield$_this53$adapte3;

      return (_yield$_this53$adapte = (_yield$_this53$adapte2 = yield _this53.adapter) === null || _yield$_this53$adapte2 === void 0 ? void 0 : (_yield$_this53$adapte3 = _yield$_this53$adapte2.canSetPlaybackQuality) === null || _yield$_this53$adapte3 === void 0 ? void 0 : _yield$_this53$adapte3.call(_yield$_this53$adapte2)) !== null && _yield$_this53$adapte !== void 0 ? _yield$_this53$adapte : false;
    })();
  }
  /** @inheritDoc */


  canSetFullscreen() {
    var _this54 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this54$adapte, _yield$_this54$adapte2, _yield$_this54$adapte3;

      return _this54.fullscreen.isSupported || ((_yield$_this54$adapte = (_yield$_this54$adapte2 = yield _this54.adapter) === null || _yield$_this54$adapte2 === void 0 ? void 0 : (_yield$_this54$adapte3 = _yield$_this54$adapte2.canSetFullscreen) === null || _yield$_this54$adapte3 === void 0 ? void 0 : _yield$_this54$adapte3.call(_yield$_this54$adapte2)) !== null && _yield$_this54$adapte !== void 0 ? _yield$_this54$adapte : false);
    })();
  }
  /** @inheritDoc */


  enterFullscreen(options) {
    var _this55 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this55$adapte, _yield$_this55$adapte2;

      if (!_this55.isVideoView) throw Error('Cannot enter fullscreen on an audio player view.');
      if (_this55.fullscreen.isSupported) return _this55.fullscreen.enterFullscreen(options);

      if (yield (_yield$_this55$adapte = yield _this55.adapter) === null || _yield$_this55$adapte === void 0 ? void 0 : (_yield$_this55$adapte2 = _yield$_this55$adapte.canSetFullscreen) === null || _yield$_this55$adapte2 === void 0 ? void 0 : _yield$_this55$adapte2.call(_yield$_this55$adapte)) {
        var _yield$_this55$adapte3, _yield$_this55$adapte4;

        return (_yield$_this55$adapte3 = yield _this55.adapter) === null || _yield$_this55$adapte3 === void 0 ? void 0 : (_yield$_this55$adapte4 = _yield$_this55$adapte3.enterFullscreen) === null || _yield$_this55$adapte4 === void 0 ? void 0 : _yield$_this55$adapte4.call(_yield$_this55$adapte3, options);
      }

      throw Error('Fullscreen API is not available.');
    })();
  }
  /** @inheritDoc */


  exitFullscreen() {
    var _this56 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this56$adapte, _yield$_this56$adapte2;

      if (_this56.fullscreen.isSupported) return _this56.fullscreen.exitFullscreen();
      return (_yield$_this56$adapte = yield _this56.adapter) === null || _yield$_this56$adapte === void 0 ? void 0 : (_yield$_this56$adapte2 = _yield$_this56$adapte.exitFullscreen) === null || _yield$_this56$adapte2 === void 0 ? void 0 : _yield$_this56$adapte2.call(_yield$_this56$adapte);
    })();
  }
  /** @inheritDoc */


  canSetPiP() {
    var _this57 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this57$adapte, _yield$_this57$adapte2, _yield$_this57$adapte3;

      return (_yield$_this57$adapte = (_yield$_this57$adapte2 = yield _this57.adapter) === null || _yield$_this57$adapte2 === void 0 ? void 0 : (_yield$_this57$adapte3 = _yield$_this57$adapte2.canSetPiP) === null || _yield$_this57$adapte3 === void 0 ? void 0 : _yield$_this57$adapte3.call(_yield$_this57$adapte2)) !== null && _yield$_this57$adapte !== void 0 ? _yield$_this57$adapte : false;
    })();
  }
  /** @inheritDoc */


  enterPiP() {
    var _this58 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this58$adapte, _yield$_this58$adapte2;

      if (!_this58.isVideoView) throw Error('Cannot enter PiP mode on an audio player view.');
      if (!(yield _this58.canSetPiP())) throw Error('Picture-in-Picture API is not available.');
      return (_yield$_this58$adapte = yield _this58.adapter) === null || _yield$_this58$adapte === void 0 ? void 0 : (_yield$_this58$adapte2 = _yield$_this58$adapte.enterPiP) === null || _yield$_this58$adapte2 === void 0 ? void 0 : _yield$_this58$adapte2.call(_yield$_this58$adapte);
    })();
  }
  /** @inheritDoc */


  exitPiP() {
    var _this59 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this59$adapte, _yield$_this59$adapte2;

      return (_yield$_this59$adapte = yield _this59.adapter) === null || _yield$_this59$adapte === void 0 ? void 0 : (_yield$_this59$adapte2 = _yield$_this59$adapte.exitPiP) === null || _yield$_this59$adapte2 === void 0 ? void 0 : _yield$_this59$adapte2.call(_yield$_this59$adapte);
    })();
  }
  /** @inheritDoc */


  canSetAudioTrack() {
    var _this60 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this60$adapte;

      return !isUndefined((_yield$_this60$adapte = yield _this60.adapter) === null || _yield$_this60$adapte === void 0 ? void 0 : _yield$_this60$adapte.setCurrentAudioTrack);
    })();
  }
  /** @inheritDoc */


  setCurrentAudioTrack(trackId) {
    var _this61 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this61$adapte, _yield$_this61$adapte2;

      (_yield$_this61$adapte = yield _this61.adapter) === null || _yield$_this61$adapte === void 0 ? void 0 : (_yield$_this61$adapte2 = _yield$_this61$adapte.setCurrentAudioTrack) === null || _yield$_this61$adapte2 === void 0 ? void 0 : _yield$_this61$adapte2.call(_yield$_this61$adapte, trackId);
    })();
  }
  /** @inheritDoc */


  canSetTextTrack() {
    var _this62 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this62$adapte;

      return !isUndefined((_yield$_this62$adapte = yield _this62.adapter) === null || _yield$_this62$adapte === void 0 ? void 0 : _yield$_this62$adapte.setCurrentTextTrack);
    })();
  }
  /** @inheritDoc */


  setCurrentTextTrack(trackId) {
    var _this63 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this63$adapte, _yield$_this63$adapte2;

      (_yield$_this63$adapte = yield _this63.adapter) === null || _yield$_this63$adapte === void 0 ? void 0 : (_yield$_this63$adapte2 = _yield$_this63$adapte.setCurrentTextTrack) === null || _yield$_this63$adapte2 === void 0 ? void 0 : _yield$_this63$adapte2.call(_yield$_this63$adapte, trackId);
    })();
  }
  /** @inheritDoc */


  canSetTextTrackVisibility() {
    var _this64 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this64$adapte;

      return !isUndefined((_yield$_this64$adapte = yield _this64.adapter) === null || _yield$_this64$adapte === void 0 ? void 0 : _yield$_this64$adapte.setTextTrackVisibility);
    })();
  }
  /** @inheritDoc */


  setTextTrackVisibility(isVisible) {
    var _this65 = this;

    return _asyncToGenerator(function* () {
      var _yield$_this65$adapte, _yield$_this65$adapte2;

      (_yield$_this65$adapte = yield _this65.adapter) === null || _yield$_this65$adapte === void 0 ? void 0 : (_yield$_this65$adapte2 = _yield$_this65$adapte.setTextTrackVisibility) === null || _yield$_this65$adapte2 === void 0 ? void 0 : _yield$_this65$adapte2.call(_yield$_this65$adapte, isVisible);
    })();
  }
  /** @inheritDoc */


  extendLanguage(language, translation) {
    var _this66 = this;

    return _asyncToGenerator(function* () {
      var _this66$translations$;

      var translations = _objectSpread(_objectSpread({}, _this66.translations), {}, {
        [language]: _objectSpread(_objectSpread({}, (_this66$translations$ = _this66.translations[language]) !== null && _this66$translations$ !== void 0 ? _this66$translations$ : {}), translation)
      });

      _this66.translations = translations;
    })();
  }

  connectedCallback() {
    this.onPausedChange();
    this.onCurrentTimeChange();
    this.onVolumeChange();
    this.onMutedChange();
    this.onDebugChange();
    this.onContainerChange();
    this.onTranslationsChange();
    this.onLanguageChange(this.language, initialState.language);
    this.disposal.add(onMobileChange(isMobile => {
      this.isMobile = isMobile;
    }));
    this.disposal.add(onTouchInputChange(isTouch => {
      this.isTouch = isTouch;
    }));
  }

  componentWillLoad() {
    Universe.create(this, this.getPlayerState());
  }

  disconnectedCallback() {
    var _this$fullscreen2;

    (_this$fullscreen2 = this.fullscreen) === null || _this$fullscreen2 === void 0 ? void 0 : _this$fullscreen2.destroy();
    this.disposal.empty();
  }

  rotateDevice() {
    var _this67 = this;

    return _asyncToGenerator(function* () {
      if (!_this67.isMobile || !canRotateScreen()) return;

      try {
        if (_this67.isFullscreenActive) {
          yield window.screen.orientation.lock('landscape');
        } else {
          yield window.screen.orientation.unlock();
        }
      } catch (err) {
        _this67.vmError.emit(err);
      }
    })();
  }

  getPlayerState() {
    var state = {};
    var props = Object.keys(initialState);

    for (var i = 0; i < props.length; i += 1) {
      state[props[i]] = this[props[i]];
    }

    return state;
  }

  calcAspectRatio() {
    var [width, height] = /\d{1,2}:\d{1,2}/.test(this.aspectRatio) ? this.aspectRatio.split(':') : [16, 9];
    return 100 / Number(width) * Number(height);
  }
  /**
   * Returns the inner container.
   */


  getContainer() {
    var _this68 = this;

    return _asyncToGenerator(function* () {
      return _this68.container;
    })();
  }
  /** @internal Exposed for E2E testing. */


  callAdapter(method, value) {
    var _this69 = this;

    return _asyncToGenerator(function* () {
      return (yield _this69.adapter)[method](value);
    })();
  }

  hasCustomControls() {
    return isComponentRegistered(this, 'vm-controls');
  }

  genId() {
    var _this$host;

    var id = (_this$host = this.host) === null || _this$host === void 0 ? void 0 : _this$host.id;
    if (isString(id) && id.length > 0) return id;
    idCount$1 += 1;
    return "vm-player-".concat(idCount$1);
  }

  render() {
    var label = "".concat(this.isAudioView ? 'Audio Player' : 'Video Player') + "".concat(!isUndefined(this.mediaTitle) ? " - ".concat(this.mediaTitle) : '');
    var canShowCustomUI = !IS_IOS || !this.isVideoView || this.playsinline && !this.isFullscreenActive;

    if (!canShowCustomUI) {
      this.controls = true;
    }

    var isIdle = canShowCustomUI && this.hasCustomControls() && this.isVideoView && !this.paused && !this.isControlsActive;
    var isBlockerVisible = !this.controls && canShowCustomUI && this.isVideoView;
    return (0, _client.h)(_client.Host, {
      id: this.genId(),
      idle: isIdle,
      mobile: this.isMobile,
      touch: this.isTouch,
      live: this.isLive,
      audio: this.isAudioView,
      video: this.isVideoView,
      pip: this.isPiPActive,
      fullscreen: this.isFullscreenActive
    }, (0, _client.h)("div", {
      "aria-label": label,
      "aria-hidden": !this.ready ? 'true' : 'false',
      "aria-busy": !this.playbackReady ? 'true' : 'false',
      class: {
        player: true,
        idle: isIdle,
        audio: this.isAudioView,
        video: this.isVideoView,
        fullscreen: this.isFullscreenActive
      },
      style: {
        paddingBottom: this.isVideoView ? "".concat(this.calcAspectRatio(), "%") : undefined
      },
      ref: el => {
        (0, _client.writeTask)(() => {
          this.container = el;
        });
      }
    }, isBlockerVisible && (0, _client.h)("div", {
      class: "blocker"
    }), (0, _client.h)(Universe.Provider, {
      state: this.getPlayerState()
    }, (0, _client.h)("slot", null))));
  }

  get host() {
    return this;
  }

  static get watchers() {
    return {
      "container": ["onContainerChange"],
      "paused": ["onPausedChange"],
      "duration": ["onDurationChange"],
      "currentTime": ["onCurrentTimeChange"],
      "playbackReady": ["onPlaybackReadyChange"],
      "muted": ["onMutedChange"],
      "playbackRate": ["onPlaybackRateChange"],
      "playbackQuality": ["onPlaybackQualityChange"],
      "debug": ["onDebugChange"],
      "volume": ["onVolumeChange"],
      "viewType": ["onViewTypeChange"],
      "isAudioView": ["onViewTypeChange"],
      "isVideoView": ["onViewTypeChange"],
      "mediaType": ["onMediaTypeChange"],
      "language": ["onLanguageChange"],
      "translations": ["onTranslationsChange"]
    };
  }

  static get style() {
    return playerCss;
  }

};
var posterCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--vm-poster-z-index)}.poster{width:100%;height:100%;background:#000;opacity:0;visibility:hidden;pointer-events:none;transition:var(--vm-fade-transition)}.poster.hidden{display:none}.poster.active{opacity:1;visibility:visible}img{width:100%;height:100%;pointer-events:none}";
var Poster = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.vmLoaded = (0, _client.createEvent)(this, "vmLoaded", 3);
    this.vmWillShow = (0, _client.createEvent)(this, "vmWillShow", 3);
    this.vmWillHide = (0, _client.createEvent)(this, "vmWillHide", 3);
    this.isHidden = true;
    this.isActive = false;
    this.hasLoaded = false;
    /**
     * How the poster image should be resized to fit the container (sets the `object-fit` property).
     */

    this.fit = 'cover';
    /** @internal */

    this.isVideoView = false;
    /** @internal */

    this.playbackStarted = false;
    /** @internal */

    this.currentTime = 0;
    withComponentRegistry(this);
    withPlayerContext(this, ['mediaTitle', 'currentPoster', 'playbackStarted', 'currentTime', 'isVideoView']);
  }

  onCurrentPosterChange() {
    var _this$lazyLoader2;

    this.hasLoaded = false;
    (_this$lazyLoader2 = this.lazyLoader) === null || _this$lazyLoader2 === void 0 ? void 0 : _this$lazyLoader2.onMutation();
  }

  connectedCallback() {
    this.lazyLoader = new LazyLoader(this.host, ['data-src', 'src'], el => {
      var src = el.getAttribute('data-src');
      el.removeAttribute('src');

      if (!isNull(src)) {
        el.setAttribute('src', src);
      }
    });
    this.onEnabledChange();
    this.onActiveChange();
  }

  disconnectedCallback() {
    this.lazyLoader.destroy();
  }

  onVisibilityChange() {
    !this.isHidden && this.isActive ? this.vmWillShow.emit() : this.vmWillHide.emit();
  }

  onEnabledChange() {
    this.isHidden = !this.isVideoView;
    this.onVisibilityChange();
  }

  onActiveChange() {
    this.isActive = !this.playbackStarted || this.currentTime <= 0.1;
    this.onVisibilityChange();
  }

  onPosterLoad() {
    this.vmLoaded.emit();
    this.hasLoaded = true;
  }

  render() {
    return (0, _client.h)("div", {
      class: {
        poster: true,
        hidden: this.isHidden,
        active: this.isActive && this.hasLoaded
      }
    }, (0, _client.h)("img", {
      class: "lazy",
      "data-src": this.currentPoster,
      alt: !isUndefined(this.mediaTitle) ? "".concat(this.mediaTitle, " Poster") : 'Media Poster',
      style: {
        objectFit: this.fit
      },
      onLoad: this.onPosterLoad.bind(this)
    }));
  }

  get host() {
    return this;
  }

  static get watchers() {
    return {
      "currentPoster": ["onCurrentPosterChange"],
      "isVideoView": ["onEnabledChange"],
      "currentTime": ["onActiveChange"],
      "playbackStarted": ["onActiveChange"]
    };
  }

  static get style() {
    return posterCss;
  }

};
var scrimCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--vm-scrim-z-index)}.scrim{position:absolute;width:100%;background:var(--vm-scrim-bg);display:inline-block;opacity:0;visibility:hidden;transition:var(--vm-fade-transition)}.scrim.gradient{height:258px;background:none;background-position:bottom;background-image:url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAECCAYAAAA/9r2TAAABKklEQVQ4T2XI50cFABiF8dvee++67b33uM17b1MkkSSSSBJJJIkkkkQSSSKJ9Efmeb8cr86HH88JBP4thkfEkiKOFPGkSCCNRE8SKZJJkUIaqZ40UqSTIoMUmaSR5ckmRQ4pckkjz5NPigJSFJKiiDSKPSWkKCVFGWmUeypIUUmKKlJUk0aNJ0iKWlLUkUa9p4EUjaRoIkUzabR4WknRRop20ujwdJKiixTdpOghjV5PHyn6STFAGoOeIVIMk2KEFKOkMeYZJ8UEKUKkMemZIsU0KWZIMUsac54wKSKkiJLGvGeBFIukWCLFMrkCq7AG67ABm7AF27ADu7AH+3AAh3AEx3ACp3AG53ABl3AF13ADt3AH9/AAj/AEz/ACr/AG7/ABn/AF3/ADv39LujSyJPVJ0QAAAABJRU5ErkJggg==\")}.scrim.gradientUp{top:unset;bottom:0}.scrim.gradientDown{transform:rotate(180deg)}.scrim.hidden{display:none}.scrim.active{opacity:1;visibility:visible}";
var Scrim = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    /** @internal */

    this.isVideoView = false;
    /** @internal */

    this.isControlsActive = false;
    withComponentRegistry(this);
    withPlayerContext(this, ['isVideoView', 'isControlsActive']);
  }

  render() {
    return (0, _client.h)("div", {
      class: {
        scrim: true,
        gradient: !isUndefined(this.gradient),
        gradientUp: this.gradient === 'up',
        gradientDown: this.gradient === 'down',
        hidden: !this.isVideoView,
        active: this.isControlsActive
      }
    });
  }

  static get style() {
    return scrimCss;
  }

};

var getHours = value => Math.trunc(value / 60 / 60 % 60);

var getMinutes = value => Math.trunc(value / 60 % 60);

var getSeconds = value => Math.trunc(value % 60);

var formatTime = function formatTime() {
  var seconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var alwaysShowHours = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  // Format time component to add leading zero.
  var format = value => "0".concat(value).slice(-2);

  var hours = getHours(seconds);
  var mins = getMinutes(seconds);
  var secs = getSeconds(seconds);
  return "".concat(alwaysShowHours || hours > 0 ? "".concat(hours, ":") : '').concat(format(mins), ":").concat(format(secs));
};

var scrubberControlCss = ":host{--vm-tooltip-spacing:var(--vm-scrubber-tooltip-spacing);flex:1;position:relative;cursor:pointer;pointer-events:auto;box-sizing:border-box;left:calc(var(--vm-slider-thumb-width) / 2);margin-right:var(--vm-slider-thumb-width);margin-bottom:var(--vm-slider-track-height)}@keyframes progress{to{background-position:var(--vm-scrubber-loading-stripe-size) 0}}.scrubber{position:relative;width:100%}vm-slider,progress{margin-left:calc(calc(var(--vm-slider-thumb-width) / 2) * -1);margin-right:calc(calc(var(--vm-slider-thumb-width) / 2) * -1);width:calc(100% + var(--vm-slider-thumb-width));height:var(--vm-slider-track-height)}vm-slider:hover,progress:hover{cursor:pointer}vm-slider{position:absolute;top:0;left:0;z-index:3}progress{-webkit-appearance:none;background:transparent;border:0;border-radius:100px;position:absolute;left:0;top:50%;padding:0;color:var(--vm-scrubber-buffered-bg);height:var(--vm-slider-track-height)}progress::-webkit-progress-bar{background:transparent}progress::-webkit-progress-value{background:currentColor;border-radius:100px;min-width:var(--vm-slider-track-height);transition:width 0.2s ease}progress::-moz-progress-bar{background:currentColor;border-radius:100px;min-width:var(--vm-slider-track-height);transition:width 0.2s ease}progress::-ms-fill{border-radius:100px;transition:width 0.2s ease}progress.loading{animation:progress 1s linear infinite;background-image:linear-gradient(-45deg,\n  var(--vm-scrubber-loading-stripe-color) 25%,\n  transparent 25%,\n  transparent 50%,\n  var(--vm-scrubber-loading-stripe-color) 50%,\n  var(--vm-scrubber-loading-stripe-color) 75%,\n  transparent 75%,\n  transparent);background-repeat:repeat-x;background-size:var(--vm-scrubber-loading-stripe-size) var(--vm-scrubber-loading-stripe-size);color:transparent;background-color:transparent}";
var ScrubberControl = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.keyboardDisposal = new Disposal();
    this.timestamp = '';
    this.endTime = 0;
    /**
     * Whether the timestamp in the tooltip should show the hours unit, even if the time is less than
     * 1 hour (eg: `20:35` -> `00:20:35`).
     */

    this.alwaysShowHours = false;
    /**
     * Whether the tooltip should not be displayed.
     */

    this.hideTooltip = false;
    /** @internal */

    this.currentTime = 0;
    /** @internal */

    this.duration = -1;
    /**
     * Prevents seeking forward/backward by using the Left/Right arrow keys.
     */

    this.noKeyboard = false;
    /** @internal */

    this.buffering = false;
    /** @internal */

    this.buffered = 0;
    /** @internal */

    this.i18n = {};
    withComponentRegistry(this);
    withPlayerContext(this, ['i18n', 'currentTime', 'duration', 'buffering', 'buffered']);
  }

  onNoKeyboardChange() {
    var _this70 = this;

    return _asyncToGenerator(function* () {
      _this70.keyboardDisposal.empty();

      if (_this70.noKeyboard) return;
      var player = yield findPlayer(_this70);

      var onKeyDown = event => {
        if (event.key !== 'ArrowLeft' && event.key !== 'ArrowRight') return;
        event.preventDefault();
        var isLeftArrow = event.key === 'ArrowLeft';
        var seekTo = isLeftArrow ? Math.max(0, _this70.currentTime - 5) : Math.min(_this70.duration, _this70.currentTime + 5);

        _this70.dispatch('currentTime', seekTo);
      };

      _this70.keyboardDisposal.add(listen(player, 'keydown', onKeyDown));
    })();
  }

  onDurationChange() {
    // Avoid -1.
    this.endTime = Math.max(0, this.duration);
  }

  connectedCallback() {
    this.dispatch = createDispatcher(this);
    this.timestamp = formatTime(this.currentTime, this.alwaysShowHours);
    this.onNoKeyboardChange();
  }

  disconnectedCallback() {
    this.keyboardDisposal.empty();
  }

  setTooltipPosition(value) {
    var tooltipRect = this.tooltip.shadowRoot.querySelector('.tooltip').getBoundingClientRect();
    var bounds = this.slider.getBoundingClientRect();
    var thumbWidth = parseFloat(window.getComputedStyle(this.slider).getPropertyValue('--vm-slider-thumb-width'));
    var leftLimit = tooltipRect.width / 2 - thumbWidth / 2;
    var rightLimit = bounds.width - tooltipRect.width / 2 - thumbWidth / 2;
    var xPos = Math.max(leftLimit, Math.min(value, rightLimit));
    this.tooltip.style = "--vm-tooltip-left: ".concat(xPos, "px");
  }

  onSeek(event) {
    this.dispatch('currentTime', event.detail);
  }

  onSeeking(event) {
    if (this.duration < 0 || this.tooltip.hidden) return;

    if (event.type === 'mouseleave') {
      this.getSliderInput().blur();
      this.tooltip.active = false;
      return;
    }

    var rect = this.host.getBoundingClientRect();
    var percent = Math.max(0, Math.min(100, 100 / rect.width * (event.pageX - rect.left)));
    this.timestamp = formatTime(this.duration / 100 * percent, this.alwaysShowHours);
    this.setTooltipPosition(percent / 100 * rect.width);

    if (!this.tooltip.active) {
      this.getSliderInput().focus();
      this.tooltip.active = true;
    }
  }

  getSliderInput() {
    return this.slider.shadowRoot.querySelector('input');
  }

  render() {
    var sliderValueText = this.i18n.scrubberLabel.replace(/{currentTime}/, formatTime(this.currentTime)).replace(/{duration}/, formatTime(this.endTime));
    return (0, _client.h)("div", {
      class: "scrubber",
      onMouseEnter: this.onSeeking.bind(this),
      onMouseLeave: this.onSeeking.bind(this),
      onMouseMove: this.onSeeking.bind(this),
      onTouchMove: () => {
        this.getSliderInput().focus();
      },
      onTouchEnd: () => {
        this.getSliderInput().blur();
      }
    }, (0, _client.h)("vm-slider", {
      step: 0.01,
      max: this.endTime,
      value: this.currentTime,
      label: this.i18n.scrubber,
      valueText: sliderValueText,
      onVmValueChange: this.onSeek.bind(this),
      ref: el => {
        this.slider = el;
      }
    }), (0, _client.h)("progress", {
      class: {
        loading: this.buffering
      },
      // @ts-ignore
      min: 0,
      max: this.endTime,
      value: this.buffered,
      "aria-label": this.i18n.buffered,
      "aria-valuemin": "0",
      "aria-valuemax": this.endTime,
      "aria-valuenow": this.buffered,
      "aria-valuetext": "".concat((this.endTime > 0 ? this.buffered / this.endTime : 0).toFixed(0), "%")
    }, "% buffered"), (0, _client.h)("vm-tooltip", {
      hidden: this.hideTooltip,
      ref: el => {
        this.tooltip = el;
      }
    }, this.timestamp));
  }

  get host() {
    return this;
  }

  static get watchers() {
    return {
      "noKeyboard": ["onNoKeyboardChange"],
      "duration": ["onDurationChange"]
    };
  }

  static get style() {
    return scrubberControlCss;
  }

};
var settingsCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--vm-menu-z-index)}.settings{position:absolute;opacity:0;pointer-events:auto;overflow-x:hidden;overflow-y:auto;background-color:var(--vm-menu-bg);max-height:var(--vm-settings-max-height);border-radius:var(--vm-settings-border-radius);padding:var(--vm-settings-padding);box-shadow:var(--vm-settings-shadow);box-sizing:border-box;scrollbar-width:thin;scroll-behavior:smooth;scrollbar-color:var(--vm-settings-scroll-thumb-color) var(--vm-settings-scroll-track-color);transform:translateY(8px);transition:var(--vm-settings-transition)}.container{display:block;width:var(--vm-settings-width);height:100%;position:relative;transition:width 0.25s ease-in, height 0.25s ease-in}.settings.hydrated{visibility:hidden !important}.settings::-webkit-scrollbar{width:var(--vm-settings-scroll-width)}.settings::-webkit-scrollbar-track{background:var(--vm-settings-scroll-track-color)}.settings::-webkit-scrollbar-thumb{border-radius:var(--vm-settings-scroll-width);background-color:var(--vm-settings-scroll-thumb-color);border:2px solid var(--vm-menu-bg)}.settings.active{transform:translateY(0);opacity:1;visibility:visible !important}.settings.mobile{position:fixed;top:auto !important;left:0 !important;right:0 !important;bottom:0 !important;width:100%;min-height:56px;max-height:50%;border-radius:0;z-index:2147483647;transform:translateY(100%)}.settings.mobile.active{transform:translateY(0)}.settings.mobile>vm-menu{height:100% !important;overflow:auto !important}";
var idCount$2 = 0;
var Settings = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.disposal = new Disposal();
    this.menuHeight = 0;
    /**
     * Pins the settings to the defined position inside the video player. This has no effect when
     * the view is of type `audio` (always `bottomRight`) and on mobile devices (always bottom sheet).
     */

    this.pin = 'bottomRight';
    /**
     * Whether the settings menu is opened/closed.
     */

    this.active = false;
    /** @internal */

    this.isMobile = false;
    /** @internal */

    this.isAudioView = false;
    withComponentRegistry(this);
    withControlsCollisionDetection(this);
    withPlayerContext(this, ['isMobile', 'isAudioView']);
  }

  onActiveChange() {
    this.dispatch('isSettingsActive', this.active);
    if (isUndefined(this.controller)) return;
    this.controller.expanded = this.active;
  }

  connectedCallback() {
    this.dispatch = createDispatcher(this);
    idCount$2 += 1;
    this.id = "vm-settings-".concat(idCount$2);
  }

  disconnectedCallback() {
    this.disposal.empty();
  }
  /**
   * Sets the controller responsible for opening/closing this settings menu.
   */


  setController(controller) {
    var _this71 = this;

    return _asyncToGenerator(function* () {
      _this71.controller = controller;
      _this71.controller.menu = _this71.id;

      _this71.disposal.empty();

      _this71.disposal.add(listen(_this71.controller, 'click', () => {
        _this71.active = !_this71.active;
      }));

      _this71.disposal.add(listen(_this71.controller, 'keydown', event => {
        if (event.key !== 'Enter') return; // We're looking for !active because the `click` event above will toggle it to active.

        if (!_this71.active) _this71.menu.focusMenu();
      }));
    })();
  }

  getPosition() {
    if (this.isAudioView) {
      return {
        right: '0',
        bottom: 'calc(var(--vm-controls-height, 0) + 4px)'
      };
    } // topLeft => { top: 0, left: 0 }


    var pos = this.pin.split(/(?=[L|R])/).map(s => s.toLowerCase());
    return {
      [pos.includes('top') ? 'top' : 'bottom']: 'var(--vm-controls-height, 0)',
      [pos.includes('left') ? 'left' : 'right']: '8px'
    };
  }

  onOpen(event) {
    var _event$detail;

    if (((_event$detail = event.detail) === null || _event$detail === void 0 ? void 0 : _event$detail.identifier) !== this.id) return;
    this.active = true;
  }

  onClose(event) {
    var _event$detail2;

    if (((_event$detail2 = event.detail) === null || _event$detail2 === void 0 ? void 0 : _event$detail2.identifier) !== this.id) return;
    this.active = false;
  }

  onHeightChange(event) {
    this.menuHeight = event.detail;
  }

  render() {
    return (0, _client.h)("div", {
      style: _objectSpread({}, this.getPosition()),
      class: {
        settings: true,
        active: this.active,
        mobile: this.isMobile
      }
    }, (0, _client.h)("div", {
      class: "container",
      style: {
        height: "".concat(this.menuHeight, "px")
      }
    }, (0, _client.h)("vm-menu", {
      identifier: this.id,
      active: this.active,
      controller: this.controller,
      onVmOpen: this.onOpen.bind(this),
      onVmClose: this.onClose.bind(this),
      onVmMenuHeightChange: this.onHeightChange.bind(this),
      ref: el => {
        this.menu = el;
      }
    }, (0, _client.h)("slot", null))));
  }

  get host() {
    return this;
  }

  static get watchers() {
    return {
      "active": ["onActiveChange"]
    };
  }

  static get style() {
    return settingsCss;
  }

};
var settingsControlCss = ".settingsControl.hidden{display:none}.settingsControl{--vm-icon-transition:transform 0.3s ease}.settingsControl.active{--vm-icon-transform:rotate(90deg)}";
var idCount$3 = 0;
var SettingsControl = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    /**
     * The name of the settings icon to resolve from the icon library.
     */

    this.icon = 'settings';
    /**
     * Whether the tooltip is positioned above/below the control.
     */

    this.tooltipPosition = 'top';
    /**
     * Whether the settings menu this control manages is open.
     */

    this.expanded = false;
    /** @internal */

    this.i18n = {};
    withComponentRegistry(this);
    withPlayerContext(this, ['i18n']);
  }

  onComponentsChange() {
    if (!isUndefined(this.vmSettings)) {
      this.vmSettings.setController(this.host);
    }
  }

  connectedCallback() {
    idCount$3 += 1;
    this.id = "vm-settings-control-".concat(idCount$3);
    watchComponentRegistry(this, 'vm-settings', regs => {
      [this.vmSettings] = regs;
    });
  }
  /**
   * Focuses the control.
   */


  focusControl() {
    var _this72 = this;

    return _asyncToGenerator(function* () {
      var _this72$control;

      (_this72$control = _this72.control) === null || _this72$control === void 0 ? void 0 : _this72$control.focusControl();
    })();
  }
  /**
   * Removes focus from the control.
   */


  blurControl() {
    var _this73 = this;

    return _asyncToGenerator(function* () {
      var _this73$control;

      (_this73$control = _this73.control) === null || _this73$control === void 0 ? void 0 : _this73$control.blurControl();
    })();
  }

  render() {
    var hasSettings = !isUndefined(this.menu);
    return (0, _client.h)("div", {
      class: {
        settingsControl: true,
        hidden: !hasSettings,
        active: hasSettings && this.expanded
      }
    }, (0, _client.h)("vm-control", {
      identifier: this.id,
      menu: this.menu,
      hidden: !hasSettings,
      expanded: this.expanded,
      label: this.i18n.settings,
      ref: control => {
        this.control = control;
      }
    }, (0, _client.h)("vm-icon", {
      name: this.icon,
      library: this.icons
    }), (0, _client.h)("vm-tooltip", {
      hidden: this.expanded,
      position: this.tooltipPosition,
      direction: this.tooltipDirection
    }, this.i18n.settings)));
  }

  get host() {
    return this;
  }

  static get watchers() {
    return {
      "vmSettings": ["onComponentsChange"]
    };
  }

  static get style() {
    return settingsControlCss;
  }

};
var skeletonCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--vm-skeleton-z-index)}@keyframes sheen{0%{background-position:200% 0}to{background-position:-200% 0}}.skeleton{width:100%;height:100%;display:flex;min-height:1rem;pointer-events:auto}.sheen.hidden{opacity:0;visibility:hidden;transition:var(--vm-fade-transition);pointer-events:none}.indicator{flex:1 1 auto;background:var(--vm-skeleton-color)}.skeleton.sheen .indicator{background:linear-gradient(\n    270deg, \n    var(--vm-skeleton-sheen-color), \n    var(--vm-skeleton-color), \n    var(--vm-skeleton-color), \n    var(--vm-skeleton-sheen-color)\n  );background-size:400% 100%;background-size:400% 100%;animation:sheen 8s ease-in-out infinite}";
var Skeleton = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.hidden = false;
    /**
     * Determines which animation effect the skeleton will use.
     * */

    this.effect = 'sheen';
    /** @internal */

    this.ready = false;
    withComponentRegistry(this);
    withPlayerContext(this, ['ready']);
  }

  onReadyChange() {
    if (!this.ready) {
      this.hidden = false;
    } else {
      setTimeout(() => {
        this.hidden = true;
      }, 500);
    }
  }

  render() {
    return (0, _client.h)("div", {
      class: {
        skeleton: true,
        hidden: this.hidden,
        sheen: this.effect === 'sheen'
      }
    }, (0, _client.h)("div", {
      class: "indicator"
    }));
  }

  static get watchers() {
    return {
      "ready": ["onReadyChange"]
    };
  }

  static get style() {
    return skeletonCss;
  }

};
var sliderCss = ":host{width:100%}.slider{width:100%}input{width:100%;-webkit-appearance:none;background:transparent;border:0;outline:0;cursor:pointer;box-sizing:border-box;border-radius:calc(var(--vm-slider-thumb-height) * 2);user-select:none;-webkit-user-select:none;touch-action:manipulation;color:var(--vm-slider-value-color);display:block;height:var(--vm-slider-track-height);margin:0;padding:0;transition:box-shadow 0.3s ease}input::-webkit-slider-runnable-track{background:transparent;border:0;border-radius:calc(var(--vm-slider-track-height) / 2);height:var(--vm-slider-track-height);transition:box-shadow 0.3s ease;user-select:none;background-image:linear-gradient(to right, currentColor var(--vm-value, 0%), transparent var(--vm-value, 0%));background-color:var(--vm-slider-track-color)}input::-webkit-slider-thumb{opacity:0;background:var(--vm-slider-thumb-bg);border:0;border-radius:100%;position:relative;transition:all 0.2s ease;width:var(--vm-slider-thumb-width);height:var(--vm-slider-thumb-height);box-shadow:var(--vm-slider-thumb-shadow);-webkit-appearance:none;margin-top:calc(0px - calc(calc(var(--vm-slider-thumb-height) - var(--vm-slider-track-height)) / 2))}input::-moz-range-track{background:transparent;border:0;border-radius:calc(var(--vm-slider-track-height) / 2);height:var(--vm-slider-track-height);transition:box-shadow 0.3s ease;user-select:none;background-color:var(--vm-slider-track-color)}input::-moz-range-thumb{opacity:0;background:var(--vm-slider-thumb-bg);border:0;border-radius:100%;position:relative;transition:all 0.2s ease;width:var(--vm-slider-thumb-width);height:var(--vm-slider-thumb-height);box-shadow:var(--vm-slider-thumb-shadow)}input::-moz-range-progress{background:currentColor;border-radius:calc(var(--vm-slider-track-height) / 2);height:var(--vm-slider-track-height)}input::-ms-track{border:0;border-radius:calc(var(--vm-slider-track-height) / 2);height:var(--vm-slider-track-height);transition:box-shadow 0.3s ease;user-select:none;color:transparent;background-color:var(--vm-slider-track-color)}input::-ms-fill-upper{background:transparent;border:0;border-radius:calc(var(--vm-slider-track-height) / 2);height:var(--vm-slider-track-height);transition:box-shadow 0.3s ease;user-select:none}input::-ms-fill-lower{border:0;border-radius:calc(var(--vm-slider-track-height) / 2);height:var(--vm-slider-track-height);transition:box-shadow 0.3s ease;user-select:none;background:currentColor}input::-ms-thumb{opacity:0;background:var(--vm-slider-thumb-bg);border:0;border-radius:100%;position:relative;transition:all 0.2s ease;width:var(--vm-slider-thumb-width);height:var(--vm-slider-thumb-height);box-shadow:var(--vm-slider-thumb-shadow);margin-top:0}input::-ms-tooltip{display:none}input:hover::-webkit-slider-runnable-track{height:var(--vm-slider-track-focused-height)}input:hover::-moz-range-track{height:var(--vm-slider-track-focused-height)}input:hover::-ms-track{height:var(--vm-slider-track-focused-height)}input:hover::-ms-fill-upper{height:var(--vm-slider-track-focused-height)}input:hover::-ms-fill-lower{height:var(--vm-slider-track-focused-height)}input:hover::-webkit-slider-thumb{opacity:1}input:hover::-moz-range-thumb{opacity:1}input:hover::-ms-thumb{opacity:1}input:focus{outline:0}input:focus::-webkit-slider-runnable-track{outline:0;height:var(--vm-slider-track-focused-height)}input:focus::-moz-range-track{outline:0;height:var(--vm-slider-track-focused-height)}input:focus::-ms-track{outline:0;height:var(--vm-slider-track-focused-height)}input::-moz-focus-outer{border:0}";
var Slider = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.vmValueChange = (0, _client.createEvent)(this, "vmValueChange", 7);
    this.vmFocus = (0, _client.createEvent)(this, "vmFocus", 7);
    this.vmBlur = (0, _client.createEvent)(this, "vmBlur", 7);
    /**
     * A number that specifies the granularity that the value must adhere to.
     */

    this.step = 1;
    /**
     * The lowest value in the range of permitted values.
     */

    this.min = 0;
    /**
     * The greatest permitted value.
     */

    this.max = 10;
    /**
     * The current value.
     */

    this.value = 5;
    withComponentRegistry(this);
  }

  getPercentage() {
    return "".concat(this.value / this.max * 100, "%");
  }

  onValueChange(event) {
    var _event$target;

    var value = parseFloat((_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.value);
    this.vmValueChange.emit(value);
  }

  calcTouchedValue(event) {
    var input = event.target;
    var touch = event.changedTouches[0];
    var min = parseFloat(input.getAttribute('min'));
    var max = parseFloat(input.getAttribute('max'));
    var step = parseFloat(input.getAttribute('step'));
    var delta = max - min; // Calculate percentage.

    var percent;
    var clientRect = input.getBoundingClientRect();
    var sliderThumbWidth = parseFloat(window.getComputedStyle(this.host).getPropertyValue('--vm-slider-thumb-width'));
    var thumbWidth = 100 / clientRect.width * (sliderThumbWidth / 2) / 100;
    percent = 100 / clientRect.width * (touch.clientX - clientRect.left); // Don't allow outside bounds.

    percent = Math.max(0, Math.min(percent, 100)); // Factor in the thumb offset.

    if (percent < 50) {
      percent -= (100 - percent * 2) * thumbWidth;
    } else if (percent > 50) {
      percent += (percent - 50) * 2 * thumbWidth;
    }

    var position = delta * (percent / 100);

    if (step >= 1) {
      return min + Math.round(position / step) * step;
    }
    /**
     * This part differs from original implementation to save space. Only supports 2 decimal
     * places (0.01) as the step.
     */


    return min + parseFloat(position.toFixed(2));
  }
  /**
   * Basically input[range="type"] on touch devices sucks (particularly iOS), so this helps make it
   * better.
   *
   * @see https://github.com/sampotts/rangetouch
   */


  onTouch(event) {
    var input = event.target;
    if (input.disabled) return;
    event.preventDefault();
    this.value = this.calcTouchedValue(event);
    this.vmValueChange.emit(this.value);
    input.dispatchEvent(new window.Event(event.type === 'touchend' ? 'change' : 'input', {
      bubbles: true
    }));
  }

  render() {
    var _this$valueText;

    return (0, _client.h)("div", {
      class: "slider",
      style: {
        '--vm-value': this.getPercentage()
      }
    }, (0, _client.h)("input", {
      type: "range",
      step: this.step,
      min: this.min,
      max: this.max,
      value: this.value,
      autocomplete: "off",
      "aria-label": this.label,
      "aria-valuemin": this.min,
      "aria-valuemax": this.max,
      "aria-valuenow": this.value,
      "aria-valuetext": (_this$valueText = this.valueText) !== null && _this$valueText !== void 0 ? _this$valueText : this.getPercentage(),
      "aria-orientation": "horizontal",
      onInput: this.onValueChange.bind(this),
      onFocus: () => {
        this.vmFocus.emit();
      },
      onBlur: () => {
        this.vmBlur.emit();
      },
      onTouchStart: this.onTouch.bind(this),
      onTouchMove: this.onTouch.bind(this),
      onTouchEnd: this.onTouch.bind(this)
    }));
  }

  get host() {
    return this;
  }

  static get style() {
    return sliderCss;
  }

};
var spinnerCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--vm-spinner-z-index)}.spinner{width:100%;height:100%;display:flex;justify-content:center;align-items:center;opacity:0;visibility:hidden;pointer-events:none;transition:var(--vm-fade-transition)}.spinner.hidden{display:none}.spinner.active{opacity:1;visibility:visible}@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.spin{background:transparent;margin:60px auto;font-size:10px;position:relative;text-indent:-9999em;pointer-events:none;border-top:var(--vm-spinner-thickness) solid var(--vm-spinner-fill-color);border-left:var(--vm-spinner-thickness) solid var(--vm-spinner-fill-color);border-right:var(--vm-spinner-thickness) solid var(--vm-spinner-track-color);border-bottom:var(--vm-spinner-thickness) solid var(--vm-spinner-track-color);transform:translateZ(0)}.spin.active{animation:spin var(--vm-spinner-spin-duration) infinite var(--vm-spinner-spin-timing-func)}.spin,.spin::after{border-radius:50%;width:var(--vm-spinner-width);height:var(--vm-spinner-height)}";
var Spinner = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.vmWillShow = (0, _client.createEvent)(this, "vmWillShow", 3);
    this.vmWillHide = (0, _client.createEvent)(this, "vmWillHide", 3);
    this.blacklist = [Provider.YouTube];
    this.isHidden = true;
    this.isActive = false;
    /** @internal */

    this.isVideoView = false;
    /**
     * Whether the spinner should be active when the player is booting or media is loading.
     */

    this.showWhenMediaLoading = false;
    /** @internal */

    this.playbackReady = false;
    /** @internal */

    this.buffering = false;
    withComponentRegistry(this);
    withPlayerContext(this, ['isVideoView', 'buffering', 'playbackReady', 'currentProvider']);
  }

  onVideoViewChange() {
    this.isHidden = !this.isVideoView;
    this.onVisiblityChange();
  }

  onActiveChange() {
    this.isActive = this.buffering || this.showWhenMediaLoading && !this.playbackReady;
    this.onVisiblityChange();
  }

  onVisiblityChange() {
    !this.isHidden && this.isActive ? this.vmWillShow.emit() : this.vmWillHide.emit();
  }

  render() {
    return (0, _client.h)("div", {
      class: {
        spinner: true,
        hidden: this.isHidden || this.blacklist.includes(this.currentProvider),
        active: this.isActive
      }
    }, (0, _client.h)("div", {
      class: {
        spin: true,
        active: this.isActive
      }
    }, "Loading..."));
  }

  static get watchers() {
    return {
      "isVideoView": ["onVideoViewChange"],
      "buffering": ["onActiveChange"],
      "playbackReady": ["onActiveChange"]
    };
  }

  static get style() {
    return spinnerCss;
  }

};
var idCount$4 = 0;
var Submenu = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.vmOpenSubmenu = (0, _client.createEvent)(this, "vmOpenSubmenu", 7);
    this.vmCloseSubmenu = (0, _client.createEvent)(this, "vmCloseSubmenu", 7);
    /**
     * The direction the submenu should slide in from.
     */

    this.slideInDirection = 'right';
    /**
     * Whether the submenu is open/closed.
     */

    this.active = false;
    withComponentRegistry(this);
  }

  connectedCallback() {
    this.genId();
  }
  /**
   * Returns the controller (`vm-menu-item`) for this submenu.
   */


  getController() {
    var _this74 = this;

    return _asyncToGenerator(function* () {
      return _this74.controller;
    })();
  }
  /**
   * Returns the menu (`vm-menu`) for this submenu.
   */


  getMenu() {
    var _this75 = this;

    return _asyncToGenerator(function* () {
      return _this75.menu;
    })();
  }
  /**
   * Returns the height of the submenu controller.
   */


  getControllerHeight() {
    var _this76 = this;

    return _asyncToGenerator(function* () {
      var _this76$controller$ge, _this76$controller;

      return (_this76$controller$ge = (_this76$controller = _this76.controller) === null || _this76$controller === void 0 ? void 0 : _this76$controller.getHeight()) !== null && _this76$controller$ge !== void 0 ? _this76$controller$ge : 0;
    })();
  }

  getControllerHeightSync() {
    var _this$controller9;

    var el = (_this$controller9 = this.controller) === null || _this$controller9 === void 0 ? void 0 : _this$controller9.shadowRoot.querySelector("[role='menuitem']");
    return el ? parseFloat(window.getComputedStyle(el).height) : 0;
  }

  onMenuOpen() {
    this.active = true;
    this.vmOpenSubmenu.emit(this.host);
  }

  onMenuClose() {
    this.active = false;
    this.vmCloseSubmenu.emit(this.host);
  }

  genId() {
    idCount$4 += 1;
    this.id = "vm-submenu-".concat(idCount$4);
  }

  getControllerId() {
    return "".concat(this.id, "-controller");
  }

  render() {
    return (0, _client.h)("div", null, (0, _client.h)("vm-menu-item", {
      identifier: this.getControllerId(),
      menu: this.menu,
      label: this.label,
      hint: this.hint,
      expanded: this.active,
      ref: el => {
        (0, _client.writeTask)(() => {
          this.controller = el;
        });
      }
    }), (0, _client.h)("vm-menu", {
      identifier: this.id,
      controller: this.controller,
      active: this.active,
      slideInDirection: this.slideInDirection,
      onVmOpen: this.onMenuOpen.bind(this),
      onVmClose: this.onMenuClose.bind(this),
      ref: el => {
        (0, _client.writeTask)(() => {
          this.menu = el;
        });
      },
      style: {
        top: "".concat(this.getControllerHeightSync() + 1, "px")
      }
    }, (0, _client.h)("slot", null)));
  }

  get host() {
    return this;
  }

};
var timeCss = ".time{display:flex;align-items:center;color:var(--vm-time-color);font-size:var(--vm-time-font-size);font-weight:var(--vm-time-font-weight)}";
var Time = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    /**
     * The length of time in seconds.
     */

    this.seconds = 0;
    /**
     * Whether the time should always show the hours unit, even if the time is less than
     * 1 hour (eg: `20:35` -> `00:20:35`).
     */

    this.alwaysShowHours = false;
    withComponentRegistry(this);
  }

  render() {
    return (0, _client.h)("div", {
      class: "time",
      "aria-label": this.label
    }, formatTime(Math.max(0, this.seconds), this.alwaysShowHours));
  }

  static get style() {
    return timeCss;
  }

};
var timeProgressCss = ".timeProgress{display:flex;width:100%;height:100%;align-items:center;color:var(--vm-time-color)}.separator{margin:0 4px}";
var TimeProgress = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    /**
     * The string used to separate the current time and end time.
     */

    this.separator = '/';
    /**
     * Whether the times should always show the hours unit, even if the time is less than
     * 1 hour (eg: `20:35` -> `00:20:35`).
     */

    this.alwaysShowHours = false;
    withComponentRegistry(this);
  }

  render() {
    return (0, _client.h)("div", {
      class: "timeProgress"
    }, (0, _client.h)("vm-current-time", {
      alwaysShowHours: this.alwaysShowHours
    }), (0, _client.h)("span", {
      class: "separator"
    }, this.separator), (0, _client.h)("vm-end-time", {
      alwaysShowHours: this.alwaysShowHours
    }));
  }

  static get style() {
    return timeProgressCss;
  }

};
var tooltipCss = ":host{display:contents;z-index:var(--vm-tooltip-z-index)}.tooltip{left:var(--vm-tooltip-left, 50%);transform:translateX(-50%);line-height:1.3;pointer-events:none;position:absolute;opacity:0;white-space:nowrap;visibility:hidden;background:var(--vm-tooltip-bg);border-radius:var(--vm-tooltip-border-radius);box-sizing:border-box;box-shadow:var(--vm-tooltip-box-shadow);color:var(--vm-tooltip-color);font-size:var(--vm-tooltip-font-size);padding:var(--vm-tooltip-padding);transition:opacity var(--vm-tooltip-fade-duration) var(--vm-tooltip-fade-timing-func)}.tooltip[aria-hidden='false']{opacity:1;visibility:visible}.tooltip.hidden{display:none}.tooltip.onTop{bottom:100%;margin-bottom:var(--vm-tooltip-spacing)}.tooltip.onBottom{top:100%;margin-top:var(--vm-tooltip-spacing)}.tooltip.growLeft{left:auto;right:0;transform:none}.tooltip.growRight{left:0;transform:none}";
var tooltipIdCount = 0;
var Tooltip = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this); // Avoid tooltips flashing when player initializing.

    this.hasLoaded = false;
    /**
     * Whether the tooltip is displayed or not.
     */

    this.hidden = false;
    /**
     * Whether the tooltip is visible or not.
     */

    this.active = false;
    /**
     * Determines if the tooltip appears on top/bottom of it's parent.
     */

    this.position = 'top';
    /** @internal */

    this.isTouch = false;
    /** @internal */

    this.isMobile = false;
    withComponentRegistry(this);
    withPlayerContext(this, ['isTouch', 'isMobile']);
  }

  componentDidLoad() {
    this.hasLoaded = true;
  }

  getId() {
    // eslint-disable-next-line prefer-destructuring
    var id = this.host.id;
    if (isString(id) && id.length > 0) return id;
    tooltipIdCount += 1;
    return "vm-tooltip-".concat(tooltipIdCount);
  }

  render() {
    return (0, _client.h)("div", {
      id: this.getId(),
      role: "tooltip",
      "aria-hidden": !this.active || this.isTouch || this.isMobile ? 'true' : 'false',
      class: {
        tooltip: true,
        hidden: !this.hasLoaded || this.hidden,
        onTop: this.position === 'top',
        onBottom: this.position === 'bottom',
        growLeft: this.direction === 'left',
        growRight: this.direction === 'right'
      }
    }, (0, _client.h)("slot", null));
  }

  get host() {
    return this;
  }

  static get style() {
    return tooltipCss;
  }

};
var uiCss = ":host{z-index:var(--vm-ui-z-index)}.ui{width:100%;pointer-events:none}.ui.hidden{display:none}.ui.video{position:absolute;top:0;left:0;height:100%}";
var UI = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    /** @internal */

    this.isVideoView = false;
    /** @internal */

    this.playsinline = false;
    /** @internal */

    this.isFullscreenActive = false;
    withComponentRegistry(this);
    withPlayerContext(this, ['isVideoView', 'playsinline', 'isFullscreenActive']);
  }

  render() {
    var canShowCustomUI = !IS_IOS || !this.isVideoView || this.playsinline && !this.isFullscreenActive;
    return (0, _client.h)("div", {
      class: {
        ui: true,
        hidden: !canShowCustomUI,
        video: this.isVideoView
      }
    }, canShowCustomUI && (0, _client.h)("slot", null));
  }

  static get style() {
    return uiCss;
  }

};
var Video = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();
    /**
     * @internal Whether an external SDK will attach itself to the media player and control it.
     */


    this.willAttach = false;
    /**
     * @internal Whether an external SDK will manage the text tracks.
     */

    this.hasCustomTextManager = false;
    /** @inheritdoc */

    this.preload = 'metadata';
    withComponentRegistry(this);
    withProviderConnect(this);
  }

  onProviderConnect(event) {
    if (this.willAttach) event.stopImmediatePropagation();
  }

  onProviderDisconnect(event) {
    if (this.willAttach) event.stopImmediatePropagation();
  }
  /** @internal */


  getAdapter() {
    var _this77 = this;

    return _asyncToGenerator(function* () {
      var _this77$fileProvider;

      return (_this77$fileProvider = _this77.fileProvider) === null || _this77$fileProvider === void 0 ? void 0 : _this77$fileProvider.getAdapter();
    })();
  }

  render() {
    return (// @ts-ignore
      (0, _client.h)("vm-file", {
        noConnect: true,
        willAttach: this.willAttach,
        crossOrigin: this.crossOrigin,
        poster: this.poster,
        preload: this.preload,
        controlsList: this.controlsList,
        autoPiP: this.autoPiP,
        disablePiP: this.disablePiP,
        disableRemotePlayback: this.disableRemotePlayback,
        hasCustomTextManager: this.hasCustomTextManager,
        mediaTitle: this.mediaTitle,
        viewType: ViewType.Video,
        ref: el => {
          this.fileProvider = el;
        }
      }, (0, _client.h)("slot", null))
    );
  }

};
/**
 * @see https://developer.vimeo.com/player/sdk/reference#events-for-playback-controls
 */

var VimeoEvent;

(function (VimeoEvent) {
  VimeoEvent["Play"] = "play";
  VimeoEvent["Pause"] = "pause";
  VimeoEvent["Seeking"] = "seeking";
  VimeoEvent["Seeked"] = "seeked";
  VimeoEvent["TimeUpdate"] = "timeupdate";
  VimeoEvent["VolumeChange"] = "volumechange";
  VimeoEvent["DurationChange"] = "durationchange";
  VimeoEvent["FullscreenChange"] = "fullscreenchange";
  VimeoEvent["CueChange"] = "cuechange";
  VimeoEvent["Progress"] = "progress";
  VimeoEvent["Error"] = "error";
  VimeoEvent["PlaybackRateChange"] = "playbackratechange";
  VimeoEvent["Loaded"] = "loaded";
  VimeoEvent["BufferStart"] = "bufferstart";
  VimeoEvent["BufferEnd"] = "bufferend";
  VimeoEvent["TextTrackChange"] = "texttrackchange";
  VimeoEvent["Waiting"] = "waiting";
  VimeoEvent["Ended"] = "ended";
})(VimeoEvent || (VimeoEvent = {}));

var vimeoCss = ":host{z-index:var(--vm-media-z-index)}vm-embed{position:absolute;top:0;left:0;width:100%;height:100%}vm-embed.hideControls{display:block;width:100%;height:auto;position:relative}";
var videoInfoCache$1 = new Map();
var Vimeo = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.vmLoadStart = (0, _client.createEvent)(this, "vmLoadStart", 7);
    this.vmError = (0, _client.createEvent)(this, "vmError", 7);
    this.defaultInternalState = {};
    this.volume = 50;
    this.hasLoaded = false;
    this.internalState = {
      paused: true,
      playing: false,
      seeking: false,
      currentTime: 0,
      buffered: 0,
      playbackStarted: false,
      playRequest: false
    };
    this.embedSrc = '';
    this.mediaTitle = '';
    /**
     * Whether to display the video owner's name.
     */

    this.byline = true;
    /**
     * Whether to display the video owner's portrait.
     */

    this.portrait = true;
    /**
     * Turns off automatically determining the aspect ratio of the current video.
     */

    this.noAutoAspectRatio = false;
    /**
     * Whether cookies should be enabled on the embed.
     */

    this.cookies = true;
    /** @internal */

    this.language = 'en';
    /** @internal */

    this.aspectRatio = '16:9';
    /** @internal */

    this.autoplay = false;
    /** @internal */

    this.controls = false;
    /** @internal */

    this.loop = false;
    /** @internal */

    this.muted = false;
    /** @internal */

    this.playsinline = false;
    withComponentRegistry(this);
    withProviderConnect(this);
    withProviderContext(this);
  }

  onVideoIdChange() {
    this.cancelTimeUpdates();

    if (!this.videoId) {
      this.embedSrc = '';
      return;
    }

    this.embedSrc = "".concat(this.getOrigin(), "/video/").concat(this.videoId);
    this.pendingDurationCall = deferredPromise();
    this.pendingMediaTitleCall = deferredPromise();
    this.fetchVideoInfo = this.getVideoInfo();
  }

  onCustomPosterChange() {
    this.dispatch('currentPoster', this.poster);
  }

  connectedCallback() {
    this.dispatch = createProviderDispatcher(this);
    this.dispatch('viewType', ViewType.Video);
    this.onVideoIdChange();
    this.initialMuted = this.muted;
    this.defaultInternalState = _objectSpread({}, this.internalState);
  }

  disconnectedCallback() {
    this.cancelTimeUpdates();
    this.pendingPlayRequest = undefined;
  }

  getOrigin() {
    return 'https://player.vimeo.com';
  }

  getPreconnections() {
    return [this.getOrigin(), 'https://i.vimeocdn.com', 'https://f.vimeocdn.com', 'https://fresnel.vimeocdn.com'];
  }

  remoteControl(command, arg) {
    return this.embed.postMessage({
      method: command,
      value: arg
    });
  }

  buildParams() {
    return {
      byline: this.byline,
      color: this.color,
      portrait: this.portrait,
      autopause: false,
      transparent: false,
      autoplay: this.autoplay,
      muted: this.initialMuted,
      playsinline: this.playsinline,
      dnt: !this.cookies
    };
  }

  getVideoInfo() {
    var _this78 = this;

    return _asyncToGenerator(function* () {
      if (videoInfoCache$1.has(_this78.videoId)) return videoInfoCache$1.get(_this78.videoId);
      return window.fetch("https://vimeo.com/api/oembed.json?url=".concat(_this78.embedSrc)).then(response => response.json()).then(data => {
        var thumnailRegex = /vimeocdn\.com\/video\/([0-9]+)/;
        var thumbnailId = data === null || data === void 0 ? void 0 : data.thumbnail_url.match(thumnailRegex)[1];
        var poster = "https://i.vimeocdn.com/video/".concat(thumbnailId, "_1920x1080.jpg");
        var info = {
          poster,
          width: data === null || data === void 0 ? void 0 : data.width,
          height: data === null || data === void 0 ? void 0 : data.height
        };
        videoInfoCache$1.set(_this78.videoId, info);
        return info;
      });
    })();
  }

  onTimeChange(time) {
    if (this.internalState.currentTime === time) return;
    this.dispatch('currentTime', time); // This is how we detect `seeking` early.

    if (Math.abs(this.internalState.currentTime - time) > 1.5) {
      this.internalState.seeking = true;
      this.dispatch('seeking', true);

      if (this.internalState.playing && this.internalState.buffered < time) {
        this.dispatch('buffering', true);
      } // Player doesn't resume playback once seeked.


      window.clearTimeout(this.pendingPlayRequest);

      if (!this.internalState.paused) {
        this.internalState.playRequest = true;
      }

      this.remoteControl(this.internalState.playbackStarted ? "pause"
      /* Pause */
      : "play"
      /* Play */
      );
    }

    this.internalState.currentTime = time;
  }

  cancelTimeUpdates() {
    if (isNumber(this.timeRAF)) window.cancelAnimationFrame(this.timeRAF);
  }

  requestTimeUpdates() {
    this.remoteControl("getCurrentTime"
    /* GetCurrentTime */
    );
    this.timeRAF = window.requestAnimationFrame(() => {
      this.requestTimeUpdates();
    });
  }

  onSeeked() {
    if (!this.internalState.seeking) return;
    this.dispatch('seeking', false);
    this.internalState.seeking = false;

    if (this.internalState.playRequest) {
      window.setTimeout(() => {
        this.remoteControl("play"
        /* Play */
        );
      }, 150);
    }
  }

  onVimeoMethod(method, arg) {
    var _this$pendingDuration, _this$pendingMediaTit3;

    switch (method) {
      case "getCurrentTime"
      /* GetCurrentTime */
      :
        if (!this.internalState.seeking) this.onTimeChange(arg);
        break;

      case "getDuration"
      /* GetDuration */
      :
        (_this$pendingDuration = this.pendingDurationCall) === null || _this$pendingDuration === void 0 ? void 0 : _this$pendingDuration.resolve(arg);
        break;

      case "getVideoTitle"
      /* GetVideoTitle */
      :
        (_this$pendingMediaTit3 = this.pendingMediaTitleCall) === null || _this$pendingMediaTit3 === void 0 ? void 0 : _this$pendingMediaTit3.resolve(arg);
        break;
    }
  }

  onLoaded() {
    var _this$pendingDuration2, _this$pendingMediaTit4;

    if (this.hasLoaded) return;
    this.pendingPlayRequest = undefined;
    this.internalState = _objectSpread({}, this.defaultInternalState);
    this.dispatch('currentSrc', this.embedSrc);
    this.dispatch('mediaType', MediaType.Video);
    this.remoteControl("getDuration"
    /* GetDuration */
    );
    this.remoteControl("getVideoTitle"
    /* GetVideoTitle */
    );
    Promise.all([this.fetchVideoInfo, (_this$pendingDuration2 = this.pendingDurationCall) === null || _this$pendingDuration2 === void 0 ? void 0 : _this$pendingDuration2.promise, (_this$pendingMediaTit4 = this.pendingMediaTitleCall) === null || _this$pendingMediaTit4 === void 0 ? void 0 : _this$pendingMediaTit4.promise]).then((_ref11) => {
      var _info$width, _info$height, _this$poster2;

      var [info, duration, mediaTitle] = _ref11;
      this.requestTimeUpdates();
      this.dispatch('aspectRatio', "".concat((_info$width = info === null || info === void 0 ? void 0 : info.width) !== null && _info$width !== void 0 ? _info$width : 16, ":").concat((_info$height = info === null || info === void 0 ? void 0 : info.height) !== null && _info$height !== void 0 ? _info$height : 9));
      this.dispatch('currentPoster', (_this$poster2 = this.poster) !== null && _this$poster2 !== void 0 ? _this$poster2 : info === null || info === void 0 ? void 0 : info.poster);
      this.dispatch('duration', duration !== null && duration !== void 0 ? duration : -1);
      this.dispatch('mediaTitle', mediaTitle);
      this.dispatch('playbackReady', true);
    });
    this.hasLoaded = true;
  }

  onVimeoEvent(event, payload) {
    switch (event) {
      case "ready"
      /* Ready */
      :
        Object.values(VimeoEvent).forEach(e => {
          this.remoteControl("addEventListener"
          /* AddEventListener */
          , e);
        });
        break;

      case "loaded"
      /* Loaded */
      :
        this.onLoaded();
        break;

      case "play"
      /* Play */
      :
        // Incase of autoplay which might skip `Loaded` event.
        this.onLoaded();
        this.internalState.paused = false;
        this.dispatch('paused', false);
        break;

      case "playProgress"
      /* PlayProgress */
      :
        if (!this.internalState.playing) {
          this.dispatch('playing', true);
          this.internalState.playing = true;
          this.internalState.playbackStarted = true;
          this.pendingPlayRequest = window.setTimeout(() => {
            this.internalState.playRequest = false;
            this.pendingPlayRequest = undefined;
          }, 1000);
        }

        this.dispatch('buffering', false);
        this.onSeeked();
        break;

      case "pause"
      /* Pause */
      :
        this.internalState.paused = true;
        this.internalState.playing = false;
        this.dispatch('paused', true);
        this.dispatch('buffering', false);
        break;

      case "loadProgress"
      /* LoadProgress */
      :
        this.internalState.buffered = payload.seconds;
        this.dispatch('buffered', payload.seconds);
        break;

      case "bufferstart"
      /* BufferStart */
      :
        this.dispatch('buffering', true); // Attempt to detect `play` events early.

        if (this.internalState.paused) {
          this.internalState.paused = false;
          this.dispatch('paused', false);
          this.dispatch('playbackStarted', true);
        }

        break;

      case "bufferend"
      /* BufferEnd */
      :
        this.dispatch('buffering', false);
        if (this.internalState.paused) this.onSeeked();
        break;

      case "volumechange"
      /* VolumeChange */
      :
        if (payload.volume > 0) {
          var newVolume = Math.floor(payload.volume * 100);
          this.dispatch('muted', false);

          if (this.volume !== newVolume) {
            this.volume = newVolume;
            this.dispatch('volume', this.volume);
          }
        } else {
          this.dispatch('muted', true);
        }

        break;

      case "durationchange"
      /* DurationChange */
      :
        this.dispatch('duration', payload.duration);
        break;

      case "playbackratechange"
      /* PlaybackRateChange */
      :
        this.dispatch('playbackRate', payload.playbackRate);
        break;

      case "fullscreenchange"
      /* FullscreenChange */
      :
        this.dispatch('isFullscreenActive', payload.fullscreen);
        break;

      case "finish"
      /* Finish */
      :
        if (this.loop) {
          this.remoteControl("setCurrentTime"
          /* SetCurrentTime */
          , 0);
          setTimeout(() => {
            this.remoteControl("play"
            /* Play */
            );
          }, 200);
        } else {
          this.dispatch('playbackEnded', true);
        }

        break;

      case "error"
      /* Error */
      :
        this.vmError.emit(payload);
        break;
    }
  }

  onEmbedSrcChange() {
    this.hasLoaded = false;
    this.vmLoadStart.emit();
    this.dispatch('viewType', ViewType.Video);
  }

  onEmbedMessage(event) {
    var message = event.detail;
    if (!isUndefined(message.event)) this.onVimeoEvent(message.event, message.data);
    if (!isUndefined(message.method)) this.onVimeoMethod(message.method, message.value);
  }

  adjustPosition() {
    var [aw, ah] = this.aspectRatio.split(':').map(r => parseInt(r, 10));
    var height = 240;
    var padding = 100 / aw * ah;
    var offset = (height - padding) / (height / 50);
    return {
      paddingBottom: "".concat(height, "%"),
      transform: "translateY(-".concat(offset + 0.02, "%)")
    };
  }
  /** @internal */


  getAdapter() {
    var _this79 = this;

    return _asyncToGenerator(function* () {
      var canPlayRegex = /vimeo(?:\.com|)\/([0-9]{9,})/;
      var fileRegex = /vimeo\.com\/external\/[0-9]+\..+/;
      return {
        getInternalPlayer: function () {
          var _getInternalPlayer5 = _asyncToGenerator(function* () {
            return _this79.embed;
          });

          function getInternalPlayer() {
            return _getInternalPlayer5.apply(this, arguments);
          }

          return getInternalPlayer;
        }(),
        play: function () {
          var _play3 = _asyncToGenerator(function* () {
            _this79.remoteControl("play"
            /* Play */
            );
          });

          function play() {
            return _play3.apply(this, arguments);
          }

          return play;
        }(),
        pause: function () {
          var _pause3 = _asyncToGenerator(function* () {
            _this79.remoteControl("pause"
            /* Pause */
            );
          });

          function pause() {
            return _pause3.apply(this, arguments);
          }

          return pause;
        }(),
        canPlay: function () {
          var _canPlay5 = _asyncToGenerator(function* (type) {
            return isString(type) && !fileRegex.test(type) && canPlayRegex.test(type);
          });

          function canPlay(_x33) {
            return _canPlay5.apply(this, arguments);
          }

          return canPlay;
        }(),
        setCurrentTime: function () {
          var _setCurrentTime3 = _asyncToGenerator(function* (time) {
            _this79.remoteControl("setCurrentTime"
            /* SetCurrentTime */
            , time);
          });

          function setCurrentTime(_x34) {
            return _setCurrentTime3.apply(this, arguments);
          }

          return setCurrentTime;
        }(),
        setMuted: function () {
          var _setMuted3 = _asyncToGenerator(function* (muted) {
            if (!muted) _this79.volume = _this79.volume > 0 ? _this79.volume : 30;

            _this79.remoteControl("setVolume"
            /* SetVolume */
            , muted ? 0 : _this79.volume / 100);
          });

          function setMuted(_x35) {
            return _setMuted3.apply(this, arguments);
          }

          return setMuted;
        }(),
        setVolume: function () {
          var _setVolume3 = _asyncToGenerator(function* (volume) {
            if (!_this79.muted) {
              _this79.remoteControl("setVolume"
              /* SetVolume */
              , volume / 100);
            } else {
              // Confirm volume was set.
              _this79.dispatch('volume', volume);
            }
          });

          function setVolume(_x36) {
            return _setVolume3.apply(this, arguments);
          }

          return setVolume;
        }(),
        // @TODO how to check if Vimeo pro?
        canSetPlaybackRate: function () {
          var _canSetPlaybackRate2 = _asyncToGenerator(function* () {
            return false;
          });

          function canSetPlaybackRate() {
            return _canSetPlaybackRate2.apply(this, arguments);
          }

          return canSetPlaybackRate;
        }(),
        setPlaybackRate: function () {
          var _setPlaybackRate2 = _asyncToGenerator(function* (rate) {
            _this79.remoteControl("setPlaybackRate"
            /* SetPlaybackRate */
            , rate);
          });

          function setPlaybackRate(_x37) {
            return _setPlaybackRate2.apply(this, arguments);
          }

          return setPlaybackRate;
        }()
      };
    })();
  }

  render() {
    return (0, _client.h)("vm-embed", {
      class: {
        hideControls: !this.controls
      },
      style: this.adjustPosition(),
      embedSrc: this.embedSrc,
      mediaTitle: this.mediaTitle,
      origin: this.getOrigin(),
      params: this.buildParams(),
      decoder: decodeJSON,
      preconnections: this.getPreconnections(),
      onVmEmbedMessage: this.onEmbedMessage.bind(this),
      onVmEmbedSrcChange: this.onEmbedSrcChange.bind(this),
      ref: el => {
        this.embed = el;
      }
    });
  }

  static get watchers() {
    return {
      "videoId": ["onVideoIdChange"],
      "poster": ["onCustomPosterChange"]
    };
  }

  static get style() {
    return vimeoCss;
  }

};
var volumeControlCss = ".volumeControl{align-items:center;display:flex;position:relative;pointer-events:auto;box-sizing:border-box}vm-slider{width:75px;height:100%;margin:0;max-width:0;position:relative;z-index:3;transition:margin 0.2s cubic-bezier(0.4, 0, 1, 1), max-width 0.2s cubic-bezier(0.4, 0, 1, 1);margin-left:calc(var(--vm-control-spacing) / 2) !important;visibility:hidden}vm-slider:hover{cursor:pointer}vm-slider.hidden{display:none}vm-slider.active{max-width:75px;visibility:visible;margin:0 calc(var(--vm-control-spacing) / 2)}";
var VolumeControl = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.keyboardDisposal = new Disposal();
    this.prevMuted = false;
    this.currentVolume = 50;
    this.isSliderActive = false;
    /**
     * The name of the low volume icon to resolve from the icon library.
     */

    this.lowVolumeIcon = 'volume-low';
    /**
     * The name of the high volume icon to resolve from the icon library.
     */

    this.highVolumeIcon = 'volume-high';
    /**
     * The name of the muted volume icon to resolve from the icon library.
     */

    this.mutedIcon = 'volume-mute';
    /**
     * Whether the tooltip is positioned above/below the control.
     */

    this.tooltipPosition = 'top';
    /**
     * Whether the tooltip should be hidden.
     */

    this.hideTooltip = false;
    /**
     * A pipe (`/`) separated string of JS keyboard keys, that when caught in a `keydown` event, will
     * toggle the muted state of the player.
     */

    this.muteKeys = 'm';
    /**
     * Prevents the volume being changed using the Up/Down arrow keys.
     */

    this.noKeyboard = false;
    /** @internal */

    this.muted = false;
    /** @internal */

    this.volume = 50;
    /** @internal */

    this.isMobile = false;
    /** @internal */

    this.i18n = {};
    withComponentRegistry(this);
    withPlayerContext(this, ['volume', 'muted', 'isMobile', 'i18n']);
  }

  onNoKeyboardChange() {
    var _this80 = this;

    return _asyncToGenerator(function* () {
      _this80.keyboardDisposal.empty();

      if (_this80.noKeyboard) return;
      var player = yield findPlayer(_this80);

      _this80.keyboardDisposal.add(listen(player, 'keydown', event => {
        if (event.key !== 'ArrowUp' && event.key !== 'ArrowDown') return;
        var isUpArrow = event.key === 'ArrowUp';
        var newVolume = isUpArrow ? Math.min(100, _this80.volume + 5) : Math.max(0, _this80.volume - 5);

        _this80.dispatch('volume', parseInt("".concat(newVolume), 10));
      }));
    })();
  }

  onPlayerVolumeChange() {
    this.currentVolume = this.muted ? 0 : this.volume;

    if (!this.muted && this.prevMuted && this.volume === 0) {
      this.dispatch('volume', 30);
    }

    this.prevMuted = this.muted;
  }

  connectedCallback() {
    this.prevMuted = this.muted;
    this.dispatch = createDispatcher(this);
    this.onNoKeyboardChange();
  }

  disconnectedCallback() {
    this.keyboardDisposal.empty();
  }

  onShowSlider() {
    clearTimeout(this.hideSliderTimeout);
    this.isSliderActive = true;
  }

  onHideSlider() {
    this.hideSliderTimeout = setTimeout(() => {
      this.isSliderActive = false;
    }, 100);
  }

  onVolumeChange(event) {
    var newVolume = event.detail;
    this.currentVolume = newVolume;
    this.dispatch('volume', newVolume);
    this.dispatch('muted', newVolume === 0);
  }

  onKeyDown(event) {
    if (event.key !== 'ArrowLeft' && event.key !== 'ArrowRight') return;
    event.stopPropagation();
  }

  render() {
    return (0, _client.h)("div", {
      class: "volumeControl",
      onMouseEnter: this.onShowSlider.bind(this),
      onMouseLeave: this.onHideSlider.bind(this)
    }, (0, _client.h)("vm-mute-control", {
      keys: this.muteKeys,
      lowVolumeIcon: this.lowVolumeIcon,
      highVolumeIcon: this.highVolumeIcon,
      mutedIcon: this.mutedIcon,
      icons: this.icons,
      tooltipPosition: this.tooltipPosition,
      tooltipDirection: this.tooltipDirection,
      hideTooltip: this.hideTooltip,
      onVmFocus: this.onShowSlider.bind(this),
      onVmBlur: this.onHideSlider.bind(this)
    }), (0, _client.h)("vm-slider", {
      class: {
        hidden: this.isMobile,
        active: this.isSliderActive
      },
      step: 5,
      max: 100,
      value: this.currentVolume,
      label: this.i18n.volume,
      onKeyDown: this.onKeyDown.bind(this),
      onVmFocus: this.onShowSlider.bind(this),
      onVmBlur: this.onHideSlider.bind(this),
      onVmValueChange: this.onVolumeChange.bind(this)
    }));
  }

  static get watchers() {
    return {
      "noKeyboard": ["onNoKeyboardChange"],
      "muted": ["onPlayerVolumeChange"],
      "volume": ["onPlayerVolumeChange"]
    };
  }

  static get style() {
    return volumeControlCss;
  }

};

var mapYouTubePlaybackQuality = quality => {
  switch (quality) {
    case "unknown"
    /* Unknown */
    :
      return undefined;

    case "tiny"
    /* Tiny */
    :
      return '144p';

    case "small"
    /* Small */
    :
      return '240p';

    case "medium"
    /* Medium */
    :
      return '360p';

    case "large"
    /* Large */
    :
      return '480p';

    case "hd720"
    /* Hd720 */
    :
      return '720p';

    case "hd1080"
    /* Hd1080 */
    :
      return '1080p';

    case "highres"
    /* Highres */
    :
      return '1440p';

    case "max"
    /* Max */
    :
      return '2160p';

    default:
      return undefined;
  }
};

var youtubeCss = ":host{z-index:var(--vm-media-z-index)}";
var posterCache = new Map();
var YouTube = class extends HTMLElement {
  constructor() {
    super();

    this.__registerHost();

    (0, _client.attachShadow)(this);
    this.vmLoadStart = (0, _client.createEvent)(this, "vmLoadStart", 7);
    this.defaultInternalState = {};
    this.internalState = {
      paused: true,
      duration: 0,
      seeking: false,
      playbackReady: false,
      playbackStarted: false,
      currentTime: 0,
      lastTimeUpdate: 0,
      playbackRate: 1,
      state: -1
    };
    this.embedSrc = '';
    this.mediaTitle = '';
    /**
     * Whether cookies should be enabled on the embed.
     */

    this.cookies = false;
    /**
     * Whether the fullscreen control should be shown.
     */

    this.showFullscreenControl = true;
    /** @internal */

    this.language = 'en';
    /** @internal */

    this.autoplay = false;
    /** @internal */

    this.controls = false;
    /** @internal */

    this.loop = false;
    /** @internal */

    this.muted = false;
    /** @internal */

    this.playsinline = false;
    withComponentRegistry(this);
    withProviderConnect(this);
    withProviderContext(this);
  }

  onVideoIdChange() {
    if (!this.videoId) {
      this.embedSrc = '';
      return;
    }

    this.embedSrc = "".concat(this.getOrigin(), "/embed/").concat(this.videoId);
    this.fetchPosterURL = this.findPosterURL();
  }

  onCustomPosterChange() {
    this.dispatch('currentPoster', this.poster);
  }

  connectedCallback() {
    this.dispatch = createProviderDispatcher(this);
    this.dispatch('viewType', ViewType.Video);
    this.onVideoIdChange();
    this.initialMuted = this.muted;
    this.defaultInternalState = _objectSpread({}, this.internalState);
  }
  /** @internal */


  getAdapter() {
    var _this81 = this;

    return _asyncToGenerator(function* () {
      var canPlayRegex = /(?:youtu\.be|youtube|youtube\.com|youtube-nocookie\.com)\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=|)((?:\w|-){11})/;
      return {
        getInternalPlayer: function () {
          var _getInternalPlayer6 = _asyncToGenerator(function* () {
            return _this81.embed;
          });

          function getInternalPlayer() {
            return _getInternalPlayer6.apply(this, arguments);
          }

          return getInternalPlayer;
        }(),
        play: function () {
          var _play4 = _asyncToGenerator(function* () {
            _this81.remoteControl("playVideo"
            /* Play */
            );
          });

          function play() {
            return _play4.apply(this, arguments);
          }

          return play;
        }(),
        pause: function () {
          var _pause4 = _asyncToGenerator(function* () {
            _this81.remoteControl("pauseVideo"
            /* Pause */
            );
          });

          function pause() {
            return _pause4.apply(this, arguments);
          }

          return pause;
        }(),
        canPlay: function () {
          var _canPlay6 = _asyncToGenerator(function* (type) {
            return isString(type) && canPlayRegex.test(type);
          });

          function canPlay(_x38) {
            return _canPlay6.apply(this, arguments);
          }

          return canPlay;
        }(),
        setCurrentTime: function () {
          var _setCurrentTime4 = _asyncToGenerator(function* (time) {
            _this81.remoteControl("seekTo"
            /* Seek */
            , time);
          });

          function setCurrentTime(_x39) {
            return _setCurrentTime4.apply(this, arguments);
          }

          return setCurrentTime;
        }(),
        setMuted: function () {
          var _setMuted4 = _asyncToGenerator(function* (muted) {
            muted ? _this81.remoteControl("mute"
            /* Mute */
            ) : _this81.remoteControl("unMute"
            /* Unmute */
            );
          });

          function setMuted(_x40) {
            return _setMuted4.apply(this, arguments);
          }

          return setMuted;
        }(),
        setVolume: function () {
          var _setVolume4 = _asyncToGenerator(function* (volume) {
            _this81.remoteControl("setVolume"
            /* SetVolume */
            , volume);
          });

          function setVolume(_x41) {
            return _setVolume4.apply(this, arguments);
          }

          return setVolume;
        }(),
        canSetPlaybackRate: function () {
          var _canSetPlaybackRate3 = _asyncToGenerator(function* () {
            return true;
          });

          function canSetPlaybackRate() {
            return _canSetPlaybackRate3.apply(this, arguments);
          }

          return canSetPlaybackRate;
        }(),
        setPlaybackRate: function () {
          var _setPlaybackRate3 = _asyncToGenerator(function* (rate) {
            _this81.remoteControl("setPlaybackRate"
            /* SetPlaybackRate */
            , rate);
          });

          function setPlaybackRate(_x42) {
            return _setPlaybackRate3.apply(this, arguments);
          }

          return setPlaybackRate;
        }()
      };
    })();
  }

  getOrigin() {
    return !this.cookies ? 'https://www.youtube-nocookie.com' : 'https://www.youtube.com';
  }

  getPreconnections() {
    return [this.getOrigin(), 'https://www.google.com', 'https://googleads.g.doubleclick.net', 'https://static.doubleclick.net', 'https://s.ytimg.com', 'https://i.ytimg.com'];
  }

  remoteControl(command, arg) {
    return this.embed.postMessage({
      event: 'command',
      func: command,
      args: arg ? [arg] : undefined
    });
  }

  buildParams() {
    return {
      enablejsapi: 1,
      cc_lang_pref: this.language,
      hl: this.language,
      fs: this.showFullscreenControl ? 1 : 0,
      controls: this.controls ? 1 : 0,
      disablekb: !this.controls ? 1 : 0,
      iv_load_policy: this.controls ? 1 : 3,
      mute: this.initialMuted ? 1 : 0,
      playsinline: this.playsinline ? 1 : 0,
      autoplay: this.autoplay ? 1 : 0
    };
  }

  onEmbedSrcChange() {
    this.vmLoadStart.emit();
    this.dispatch('viewType', ViewType.Video);
  }

  onEmbedLoaded() {
    // Seems like we have to wait a random small delay or else YT player isn't ready.
    window.setTimeout(() => this.embed.postMessage({
      event: 'listening'
    }), 100);
  }

  findPosterURL() {
    var _this82 = this;

    return _asyncToGenerator(function* () {
      if (posterCache.has(_this82.videoId)) return posterCache.get(_this82.videoId);

      var posterURL = quality => "https://i.ytimg.com/vi/".concat(_this82.videoId, "/").concat(quality, ".jpg");
      /**
       * We are testing a that the image has a min-width of 121px because if the thumbnail does not
       * exist YouTube returns a blank/error image that is 120px wide.
       */


      return loadImage(posterURL('maxresdefault'), 121) // 1080p (no padding)
      .catch(() => loadImage(posterURL('sddefault'), 121)) // 640p (padded 4:3)
      .catch(() => loadImage(posterURL('hqdefault'), 121)) // 480p (padded 4:3)
      .then(img => {
        var poster = img.src;
        posterCache.set(_this82.videoId, poster);
        return poster;
      });
    })();
  }

  onCued() {
    if (this.internalState.playbackReady) return;
    this.internalState = _objectSpread({}, this.defaultInternalState);
    this.dispatch('currentSrc', this.embedSrc);
    this.dispatch('mediaType', MediaType.Video);
    this.fetchPosterURL.then(poster => {
      var _this$poster3;

      this.dispatch('currentPoster', (_this$poster3 = this.poster) !== null && _this$poster3 !== void 0 ? _this$poster3 : poster);
      this.dispatch('playbackReady', true);
    });
    this.internalState.playbackReady = true;
  }

  onPlayerStateChange(state) {
    // Sometimes the embed falls back to an unstarted state for some unknown reason, this will
    // make sure the player is configured to the right starting state.
    if (this.internalState.playbackReady && state === -1
    /* Unstarted */
    ) {
        this.internalState.paused = true;
        this.internalState.playbackStarted = false;
        this.dispatch('buffering', false);
        this.dispatch('paused', true);
        this.dispatch('playbackStarted', false);
        return;
      }

    var isPlaying = state === 1
    /* Playing */
    ;
    var isBuffering = state === 3
    /* Buffering */
    ;
    this.dispatch('buffering', isBuffering); // Attempt to detect `play` events early.

    if (this.internalState.paused && (isBuffering || isPlaying)) {
      this.internalState.paused = false;
      this.dispatch('paused', false);

      if (!this.internalState.playbackStarted) {
        this.dispatch('playbackStarted', true);
        this.internalState.playbackStarted = true;
      }
    }

    switch (state) {
      case 5
      /* Cued */
      :
        this.onCued();
        break;

      case 1
      /* Playing */
      :
        // Incase of autoplay which might skip `Cued` event.
        this.onCued();
        this.dispatch('playing', true);
        break;

      case 2
      /* Paused */
      :
        this.internalState.paused = true;
        this.dispatch('paused', true);
        break;

      case 0
      /* Ended */
      :
        if (this.loop) {
          window.setTimeout(() => {
            this.remoteControl("playVideo"
            /* Play */
            );
          }, 150);
        } else {
          this.dispatch('playbackEnded', true);
          this.internalState.paused = true;
          this.dispatch('paused', true);
        }

        break;
    }

    this.internalState.state = state;
  }

  calcCurrentTime(time) {
    var currentTime = time;

    if (this.internalState.state === 0
    /* Ended */
    ) {
        return this.internalState.duration;
      }

    if (this.internalState.state === 1
    /* Playing */
    ) {
        var elapsedTime = (Date.now() / 1e3 - this.defaultInternalState.lastTimeUpdate) * this.internalState.playbackRate;
        if (elapsedTime > 0) currentTime += Math.min(elapsedTime, 1);
      }

    return currentTime;
  }

  onTimeChange(time) {
    var currentTime = this.calcCurrentTime(time);
    this.dispatch('currentTime', currentTime); // This is the only way to detect `seeking`.

    if (Math.abs(this.internalState.currentTime - currentTime) > 1.5) {
      this.internalState.seeking = true;
      this.dispatch('seeking', true);
    }

    this.internalState.currentTime = currentTime;
  }

  onBufferedChange(buffered) {
    this.dispatch('buffered', buffered);
    /**
     * This is the only way to detect `seeked`. Unfortunately while the player is `paused` `seeking`
     * and `seeked` will fire at the same time, there are no updates inbetween -_-. We need an
     * artifical delay between the two events.
     */

    if (this.internalState.seeking && buffered > this.internalState.currentTime) {
      window.setTimeout(() => {
        this.internalState.seeking = false;
        this.dispatch('seeking', false);
      }, this.internalState.paused ? 100 : 0);
    }
  }

  onEmbedMessage(event) {
    var message = event.detail;
    var {
      info
    } = message;
    if (!info) return;
    if (isObject(info.videoData)) this.dispatch('mediaTitle', info.videoData.title);

    if (isNumber(info.duration)) {
      this.internalState.duration = info.duration;
      this.dispatch('duration', info.duration);
    }

    if (isArray(info.availablePlaybackRates)) {
      this.dispatch('playbackRates', info.availablePlaybackRates);
    }

    if (isNumber(info.playbackRate)) {
      this.internalState.playbackRate = info.playbackRate;
      this.dispatch('playbackRate', info.playbackRate);
    }

    if (isNumber(info.currentTime)) this.onTimeChange(info.currentTime);

    if (isNumber(info.currentTimeLastUpdated)) {
      this.internalState.lastTimeUpdate = info.currentTimeLastUpdated;
    }

    if (isNumber(info.videoLoadedFraction)) {
      this.onBufferedChange(info.videoLoadedFraction * this.internalState.duration);
    }

    if (isNumber(info.volume)) this.dispatch('volume', info.volume);
    if (isBoolean(info.muted)) this.dispatch('muted', info.muted);

    if (isArray(info.availableQualityLevels)) {
      this.dispatch('playbackQualities', info.availableQualityLevels.map(q => mapYouTubePlaybackQuality(q)));
    }

    if (isString(info.playbackQuality)) {
      this.dispatch('playbackQuality', mapYouTubePlaybackQuality(info.playbackQuality));
    }

    if (isNumber(info.playerState)) this.onPlayerStateChange(info.playerState);
  }

  render() {
    return (0, _client.h)("vm-embed", {
      embedSrc: this.embedSrc,
      mediaTitle: this.mediaTitle,
      origin: this.getOrigin(),
      params: this.buildParams(),
      decoder: decodeJSON,
      preconnections: this.getPreconnections(),
      onVmEmbedLoaded: this.onEmbedLoaded.bind(this),
      onVmEmbedMessage: this.onEmbedMessage.bind(this),
      onVmEmbedSrcChange: this.onEmbedSrcChange.bind(this),
      ref: el => {
        this.embed = el;
      }
    });
  }

  static get watchers() {
    return {
      "cookies": ["onVideoIdChange"],
      "videoId": ["onVideoIdChange"],
      "poster": ["onCustomPosterChange"]
    };
  }

  static get style() {
    return youtubeCss;
  }

};
var VmAudio = /*@__PURE__*/(0, _client.proxyCustomElement)(Audio, [4, "vm-audio", {
  "willAttach": [4, "will-attach"],
  "crossOrigin": [1, "cross-origin"],
  "preload": [1],
  "disableRemotePlayback": [4, "disable-remote-playback"],
  "mediaTitle": [1, "media-title"]
}]);
exports.VmAudio = VmAudio;
var VmCaptionControl = /*@__PURE__*/(0, _client.proxyCustomElement)(CaptionControl, [1, "vm-caption-control", {
  "showIcon": [1, "show-icon"],
  "hideIcon": [1, "hide-icon"],
  "tooltipPosition": [1, "tooltip-position"],
  "tooltipDirection": [1, "tooltip-direction"],
  "hideTooltip": [4, "hide-tooltip"],
  "icons": [1],
  "keys": [1],
  "i18n": [16],
  "playbackReady": [4, "playback-ready"],
  "textTracks": [16],
  "isTextTrackVisible": [4, "is-text-track-visible"],
  "canToggleCaptionVisibility": [32]
}]);
exports.VmCaptionControl = VmCaptionControl;
var VmCaptions = /*@__PURE__*/(0, _client.proxyCustomElement)(Captions, [1, "vm-captions", {
  "hidden": [4],
  "isControlsActive": [4, "is-controls-active"],
  "isVideoView": [4, "is-video-view"],
  "playbackStarted": [4, "playback-started"],
  "textTracks": [16],
  "currentTextTrack": [2, "current-text-track"],
  "isTextTrackVisible": [4, "is-text-track-visible"],
  "isEnabled": [32],
  "cue": [32],
  "fontSize": [32]
}]);
exports.VmCaptions = VmCaptions;
var VmClickToPlay = /*@__PURE__*/(0, _client.proxyCustomElement)(ClickToPlay, [1, "vm-click-to-play", {
  "useOnMobile": [4, "use-on-mobile"],
  "paused": [4],
  "isVideoView": [4, "is-video-view"],
  "isMobile": [4, "is-mobile"]
}]);
exports.VmClickToPlay = VmClickToPlay;
var VmControl = /*@__PURE__*/(0, _client.proxyCustomElement)(Control, [1, "vm-control", {
  "keys": [1],
  "identifier": [1],
  "hidden": [4],
  "label": [1],
  "menu": [1],
  "expanded": [4],
  "pressed": [4],
  "isTouch": [4, "is-touch"],
  "describedBy": [32],
  "showTapHighlight": [32]
}]);
exports.VmControl = VmControl;
var VmControlGroup = /*@__PURE__*/(0, _client.proxyCustomElement)(ControlNewLine, [1, "vm-control-group", {
  "space": [1]
}]);
exports.VmControlGroup = VmControlGroup;
var VmControlSpacer = /*@__PURE__*/(0, _client.proxyCustomElement)(ControlSpacer, [1, "vm-control-spacer"]);
exports.VmControlSpacer = VmControlSpacer;
var VmControls = /*@__PURE__*/(0, _client.proxyCustomElement)(Controls, [1, "vm-controls", {
  "hidden": [4],
  "fullWidth": [4, "full-width"],
  "fullHeight": [4, "full-height"],
  "direction": [1],
  "align": [1],
  "justify": [1],
  "pin": [513],
  "activeDuration": [2, "active-duration"],
  "waitForPlaybackStart": [4, "wait-for-playback-start"],
  "hideWhenPaused": [4, "hide-when-paused"],
  "hideOnMouseLeave": [4, "hide-on-mouse-leave"],
  "isAudioView": [4, "is-audio-view"],
  "isSettingsActive": [4, "is-settings-active"],
  "playbackReady": [4, "playback-ready"],
  "isControlsActive": [4, "is-controls-active"],
  "paused": [4],
  "playbackStarted": [4, "playback-started"],
  "isInteracting": [32]
}]);
exports.VmControls = VmControls;
var VmCurrentTime = /*@__PURE__*/(0, _client.proxyCustomElement)(CurrentTime, [1, "vm-current-time", {
  "currentTime": [2, "current-time"],
  "i18n": [16],
  "alwaysShowHours": [4, "always-show-hours"]
}]);
exports.VmCurrentTime = VmCurrentTime;
var VmDailymotion = /*@__PURE__*/(0, _client.proxyCustomElement)(Dailymotion, [1, "vm-dailymotion", {
  "videoId": [1, "video-id"],
  "shouldAutoplayQueue": [4, "should-autoplay-queue"],
  "showUpNextQueue": [4, "show-up-next-queue"],
  "showShareButtons": [4, "show-share-buttons"],
  "color": [1],
  "syndication": [1],
  "showDailymotionLogo": [4, "show-dailymotion-logo"],
  "showVideoInfo": [4, "show-video-info"],
  "language": [1],
  "autoplay": [4],
  "controls": [4],
  "poster": [1],
  "logger": [16],
  "loop": [4],
  "muted": [4],
  "playsinline": [4],
  "embedSrc": [32],
  "mediaTitle": [32]
}]);
exports.VmDailymotion = VmDailymotion;
var VmDash = /*@__PURE__*/(0, _client.proxyCustomElement)(Dash, [1, "vm-dash", {
  "src": [1],
  "version": [1],
  "libSrc": [1, "lib-src"],
  "config": [16],
  "autoplay": [4],
  "crossOrigin": [1, "cross-origin"],
  "preload": [1],
  "poster": [1],
  "controlsList": [1, "controls-list"],
  "autoPiP": [4, "auto-pip"],
  "disablePiP": [4, "disable-pip"],
  "disableRemotePlayback": [4, "disable-remote-playback"],
  "mediaTitle": [1, "media-title"],
  "enableTextTracksByDefault": [4, "enable-text-tracks-by-default"],
  "shouldRenderNativeTextTracks": [4, "should-render-native-text-tracks"],
  "isTextTrackVisible": [4, "is-text-track-visible"],
  "currentTextTrack": [2, "current-text-track"],
  "hasAttached": [32]
}, [[0, "vmMediaElChange", "onMediaElChange"]]]);
exports.VmDash = VmDash;
var VmDblClickFullscreen = /*@__PURE__*/(0, _client.proxyCustomElement)(DblClickFullscreen, [1, "vm-dbl-click-fullscreen", {
  "useOnMobile": [4, "use-on-mobile"],
  "isFullscreenActive": [4, "is-fullscreen-active"],
  "isVideoView": [4, "is-video-view"],
  "playbackReady": [4, "playback-ready"],
  "isMobile": [4, "is-mobile"],
  "canSetFullscreen": [32]
}]);
exports.VmDblClickFullscreen = VmDblClickFullscreen;
var VmDefaultControls = /*@__PURE__*/(0, _client.proxyCustomElement)(DefaultControls, [1, "vm-default-controls", {
  "activeDuration": [2, "active-duration"],
  "waitForPlaybackStart": [4, "wait-for-playback-start"],
  "hideWhenPaused": [4, "hide-when-paused"],
  "hideOnMouseLeave": [4, "hide-on-mouse-leave"],
  "theme": [1],
  "isMobile": [4, "is-mobile"],
  "isLive": [4, "is-live"],
  "isAudioView": [4, "is-audio-view"],
  "isVideoView": [4, "is-video-view"]
}]);
exports.VmDefaultControls = VmDefaultControls;
var VmDefaultSettings = /*@__PURE__*/(0, _client.proxyCustomElement)(DefaultSettings, [1, "vm-default-settings", {
  "pin": [513],
  "i18n": [16],
  "playbackReady": [4, "playback-ready"],
  "playbackRate": [2, "playback-rate"],
  "playbackRates": [16],
  "isVideoView": [4, "is-video-view"],
  "playbackQuality": [1, "playback-quality"],
  "playbackQualities": [16],
  "textTracks": [16],
  "currentTextTrack": [2, "current-text-track"],
  "audioTracks": [16],
  "currentAudioTrack": [2, "current-audio-track"],
  "isTextTrackVisible": [4, "is-text-track-visible"],
  "canSetPlaybackRate": [32],
  "canSetPlaybackQuality": [32],
  "canSetTextTrack": [32],
  "canSetAudioTrack": [32]
}]);
exports.VmDefaultSettings = VmDefaultSettings;
var VmDefaultUi = /*@__PURE__*/(0, _client.proxyCustomElement)(DefaultUI, [1, "vm-default-ui", {
  "noClickToPlay": [4, "no-click-to-play"],
  "noDblClickFullscreen": [4, "no-dbl-click-fullscreen"],
  "noCaptions": [4, "no-captions"],
  "noPoster": [4, "no-poster"],
  "noSpinner": [4, "no-spinner"],
  "noControls": [4, "no-controls"],
  "noSettings": [4, "no-settings"],
  "noLoadingScreen": [4, "no-loading-screen"]
}]);
exports.VmDefaultUi = VmDefaultUi;
var VmEmbed = /*@__PURE__*/(0, _client.proxyCustomElement)(Embed, [1, "vm-embed", {
  "embedSrc": [1, "embed-src"],
  "mediaTitle": [1, "media-title"],
  "params": [1],
  "origin": [1],
  "preconnections": [16],
  "decoder": [16],
  "srcWithParams": [32],
  "hasEnteredViewport": [32]
}, [[8, "message", "onWindowMessage"]]]);
exports.VmEmbed = VmEmbed;
var VmEndTime = /*@__PURE__*/(0, _client.proxyCustomElement)(EndTime, [1, "vm-end-time", {
  "duration": [2],
  "i18n": [16],
  "alwaysShowHours": [4, "always-show-hours"]
}]);
exports.VmEndTime = VmEndTime;
var VmFile = /*@__PURE__*/(0, _client.proxyCustomElement)(File, [6, "vm-file", {
  "willAttach": [4, "will-attach"],
  "crossOrigin": [1, "cross-origin"],
  "preload": [1],
  "poster": [1],
  "mediaTitle": [1, "media-title"],
  "controlsList": [1, "controls-list"],
  "autoPiP": [4, "auto-pip"],
  "disablePiP": [4, "disable-pip"],
  "disableRemotePlayback": [4, "disable-remote-playback"],
  "viewType": [1, "view-type"],
  "playbackRates": [16],
  "language": [1],
  "autoplay": [4],
  "controls": [4],
  "logger": [16],
  "loop": [4],
  "muted": [4],
  "playsinline": [4],
  "noConnect": [4, "no-connect"],
  "paused": [4],
  "currentTime": [2, "current-time"],
  "volume": [2],
  "playbackReady": [4, "playback-ready"],
  "playbackStarted": [4, "playback-started"],
  "currentTextTrack": [2, "current-text-track"],
  "hasCustomTextManager": [4, "has-custom-text-manager"],
  "isTextTrackVisible": [4, "is-text-track-visible"],
  "shouldRenderNativeTextTracks": [4, "should-render-native-text-tracks"],
  "vmPoster": [32]
}, [[0, "vmMediaProviderConnect", "onProviderConnect"], [0, "vmMediaProviderDisconnect", "onProviderDisconnect"]]]);
exports.VmFile = VmFile;
var VmFullscreenControl = /*@__PURE__*/(0, _client.proxyCustomElement)(FullscreenControl, [1, "vm-fullscreen-control", {
  "enterIcon": [1, "enter-icon"],
  "exitIcon": [1, "exit-icon"],
  "icons": [1],
  "tooltipPosition": [1, "tooltip-position"],
  "tooltipDirection": [1, "tooltip-direction"],
  "hideTooltip": [4, "hide-tooltip"],
  "keys": [1],
  "isFullscreenActive": [4, "is-fullscreen-active"],
  "i18n": [16],
  "playbackReady": [4, "playback-ready"],
  "canSetFullscreen": [32]
}]);
exports.VmFullscreenControl = VmFullscreenControl;
var VmHls = /*@__PURE__*/(0, _client.proxyCustomElement)(HLS, [4, "vm-hls", {
  "version": [1],
  "libSrc": [1, "lib-src"],
  "config": [8],
  "crossOrigin": [1, "cross-origin"],
  "preload": [1],
  "poster": [1],
  "controlsList": [1, "controls-list"],
  "autoPiP": [4, "auto-pip"],
  "disablePiP": [4, "disable-pip"],
  "disableRemotePlayback": [4, "disable-remote-playback"],
  "playbackReady": [4, "playback-ready"],
  "mediaTitle": [1, "media-title"],
  "hasAttached": [32]
}, [[0, "vmMediaElChange", "onMediaElChange"], [0, "vmSrcSetChange", "onSrcChange"]]]);
exports.VmHls = VmHls;
var VmIcon = /*@__PURE__*/(0, _client.proxyCustomElement)(Icon, [1, "vm-icon", {
  "name": [1],
  "src": [1],
  "label": [1],
  "library": [1],
  "icons": [1],
  "svg": [32]
}]);
exports.VmIcon = VmIcon;
var VmIconLibrary = /*@__PURE__*/(0, _client.proxyCustomElement)(IconLibrary, [1, "vm-icon-library", {
  "name": [1],
  "resolver": [16],
  "icons": [1]
}]);
exports.VmIconLibrary = VmIconLibrary;
var VmLiveIndicator = /*@__PURE__*/(0, _client.proxyCustomElement)(LiveIndicator, [1, "vm-live-indicator", {
  "isLive": [4, "is-live"],
  "i18n": [16]
}]);
exports.VmLiveIndicator = VmLiveIndicator;
var VmLoadingScreen = /*@__PURE__*/(0, _client.proxyCustomElement)(LoadingScreen, [1, "vm-loading-screen", {
  "playbackReady": [4, "playback-ready"],
  "hideDots": [4, "hide-dots"]
}]);
exports.VmLoadingScreen = VmLoadingScreen;
var VmMenu = /*@__PURE__*/(0, _client.proxyCustomElement)(Menu, [1, "vm-menu", {
  "active": [1540],
  "identifier": [1],
  "controller": [16],
  "slideInDirection": [1, "slide-in-direction"],
  "activeMenuItem": [32],
  "activeSubmenu": [32]
}, [[0, "vmOpenSubmenu", "onOpenSubmenu"], [0, "vmCloseSubmenu", "onCloseSubmenu"], [8, "click", "onWindowClick"], [8, "keydown", "onWindowKeyDown"]]]);
exports.VmMenu = VmMenu;
var VmMenuItem = /*@__PURE__*/(0, _client.proxyCustomElement)(MenuItem, [1, "vm-menu-item", {
  "identifier": [1],
  "hidden": [4],
  "label": [1],
  "menu": [16],
  "expanded": [4],
  "checked": [4],
  "hint": [1],
  "badge": [1],
  "checkIcon": [1, "check-icon"],
  "icons": [1],
  "isTouch": [4, "is-touch"],
  "showTapHighlight": [32]
}]);
exports.VmMenuItem = VmMenuItem;
var VmMenuRadio = /*@__PURE__*/(0, _client.proxyCustomElement)(MenuRadio, [1, "vm-menu-radio", {
  "label": [1],
  "value": [1],
  "checked": [1028],
  "badge": [1],
  "checkIcon": [1, "check-icon"],
  "icons": [1]
}]);
exports.VmMenuRadio = VmMenuRadio;
var VmMenuRadioGroup = /*@__PURE__*/(0, _client.proxyCustomElement)(MenuRadioGroup, [1, "vm-menu-radio-group", {
  "value": [1025]
}, [[0, "vmCheck", "onSelectionChange"]]]);
exports.VmMenuRadioGroup = VmMenuRadioGroup;
var VmMuteControl = /*@__PURE__*/(0, _client.proxyCustomElement)(MuteControl, [1, "vm-mute-control", {
  "lowVolumeIcon": [1, "low-volume-icon"],
  "highVolumeIcon": [1, "high-volume-icon"],
  "mutedIcon": [1, "muted-icon"],
  "icons": [1],
  "tooltipPosition": [1, "tooltip-position"],
  "tooltipDirection": [1, "tooltip-direction"],
  "hideTooltip": [4, "hide-tooltip"],
  "keys": [1],
  "volume": [2],
  "muted": [4],
  "i18n": [16]
}]);
exports.VmMuteControl = VmMuteControl;
var VmPipControl = /*@__PURE__*/(0, _client.proxyCustomElement)(PiPControl, [1, "vm-pip-control", {
  "enterIcon": [1, "enter-icon"],
  "exitIcon": [1, "exit-icon"],
  "icons": [1],
  "tooltipPosition": [1, "tooltip-position"],
  "tooltipDirection": [1, "tooltip-direction"],
  "hideTooltip": [4, "hide-tooltip"],
  "keys": [1],
  "isPiPActive": [4, "is-pi-p-active"],
  "i18n": [16],
  "playbackReady": [4, "playback-ready"],
  "canSetPiP": [32]
}]);
exports.VmPipControl = VmPipControl;
var VmPlaybackControl = /*@__PURE__*/(0, _client.proxyCustomElement)(PlaybackControl, [1, "vm-playback-control", {
  "playIcon": [1, "play-icon"],
  "pauseIcon": [1, "pause-icon"],
  "icons": [1],
  "tooltipPosition": [1, "tooltip-position"],
  "tooltipDirection": [1, "tooltip-direction"],
  "hideTooltip": [4, "hide-tooltip"],
  "keys": [1],
  "paused": [4],
  "i18n": [16]
}]);
exports.VmPlaybackControl = VmPlaybackControl;
var VmPlayer = /*@__PURE__*/(0, _client.proxyCustomElement)(Player, [1, "vm-player", {
  "logger": [16],
  "theme": [513],
  "icons": [513],
  "paused": [1028],
  "playing": [1028],
  "duration": [1026],
  "mediaTitle": [1025, "media-title"],
  "currentProvider": [1025, "current-provider"],
  "currentSrc": [1025, "current-src"],
  "currentPoster": [1025, "current-poster"],
  "currentTime": [1026, "current-time"],
  "autoplay": [4],
  "ready": [1540],
  "playbackReady": [1028, "playback-ready"],
  "loop": [4],
  "muted": [1028],
  "buffered": [1026],
  "playbackRate": [1026, "playback-rate"],
  "playbackRates": [1040],
  "playbackQuality": [1025, "playback-quality"],
  "playbackQualities": [1040],
  "seeking": [1028],
  "debug": [4],
  "playbackStarted": [1028, "playback-started"],
  "playbackEnded": [1028, "playback-ended"],
  "buffering": [1028],
  "controls": [4],
  "isControlsActive": [4, "is-controls-active"],
  "isSettingsActive": [1028, "is-settings-active"],
  "volume": [1026],
  "isFullscreenActive": [1028, "is-fullscreen-active"],
  "aspectRatio": [1025, "aspect-ratio"],
  "viewType": [1025, "view-type"],
  "isAudioView": [1028, "is-audio-view"],
  "isVideoView": [1028, "is-video-view"],
  "mediaType": [1025, "media-type"],
  "isAudio": [1028, "is-audio"],
  "isVideo": [1028, "is-video"],
  "isLive": [1028, "is-live"],
  "isMobile": [1028, "is-mobile"],
  "isTouch": [1028, "is-touch"],
  "isPiPActive": [1028, "is-pi-p-active"],
  "textTracks": [16],
  "currentTextTrack": [2, "current-text-track"],
  "isTextTrackVisible": [4, "is-text-track-visible"],
  "shouldRenderNativeTextTracks": [4, "should-render-native-text-tracks"],
  "audioTracks": [16],
  "currentAudioTrack": [2, "current-audio-track"],
  "autopause": [4],
  "playsinline": [4],
  "language": [1025],
  "translations": [1040],
  "languages": [1040],
  "i18n": [1040],
  "container": [32]
}, [[0, "vmError", "onError"]]]);
exports.VmPlayer = VmPlayer;
var VmPoster = /*@__PURE__*/(0, _client.proxyCustomElement)(Poster, [1, "vm-poster", {
  "fit": [1],
  "isVideoView": [4, "is-video-view"],
  "currentPoster": [1, "current-poster"],
  "mediaTitle": [1, "media-title"],
  "playbackStarted": [4, "playback-started"],
  "currentTime": [2, "current-time"],
  "isHidden": [32],
  "isActive": [32],
  "hasLoaded": [32]
}]);
exports.VmPoster = VmPoster;
var VmScrim = /*@__PURE__*/(0, _client.proxyCustomElement)(Scrim, [1, "vm-scrim", {
  "gradient": [1],
  "isVideoView": [4, "is-video-view"],
  "isControlsActive": [4, "is-controls-active"]
}]);
exports.VmScrim = VmScrim;
var VmScrubberControl = /*@__PURE__*/(0, _client.proxyCustomElement)(ScrubberControl, [1, "vm-scrubber-control", {
  "alwaysShowHours": [4, "always-show-hours"],
  "hideTooltip": [4, "hide-tooltip"],
  "currentTime": [2, "current-time"],
  "duration": [2],
  "noKeyboard": [4, "no-keyboard"],
  "buffering": [4],
  "buffered": [2],
  "i18n": [16],
  "timestamp": [32],
  "endTime": [32]
}]);
exports.VmScrubberControl = VmScrubberControl;
var VmSettings = /*@__PURE__*/(0, _client.proxyCustomElement)(Settings, [1, "vm-settings", {
  "pin": [513],
  "active": [1540],
  "isMobile": [4, "is-mobile"],
  "isAudioView": [4, "is-audio-view"],
  "menuHeight": [32]
}]);
exports.VmSettings = VmSettings;
var VmSettingsControl = /*@__PURE__*/(0, _client.proxyCustomElement)(SettingsControl, [1, "vm-settings-control", {
  "icon": [1],
  "icons": [1],
  "tooltipPosition": [1, "tooltip-position"],
  "tooltipDirection": [1, "tooltip-direction"],
  "menu": [1],
  "expanded": [4],
  "i18n": [16],
  "vmSettings": [32]
}]);
exports.VmSettingsControl = VmSettingsControl;
var VmSkeleton = /*@__PURE__*/(0, _client.proxyCustomElement)(Skeleton, [1, "vm-skeleton", {
  "effect": [1],
  "ready": [4],
  "hidden": [32]
}]);
exports.VmSkeleton = VmSkeleton;
var VmSlider = /*@__PURE__*/(0, _client.proxyCustomElement)(Slider, [1, "vm-slider", {
  "step": [2],
  "min": [2],
  "max": [2],
  "value": [2],
  "valueText": [1, "value-text"],
  "label": [1]
}]);
exports.VmSlider = VmSlider;
var VmSpinner = /*@__PURE__*/(0, _client.proxyCustomElement)(Spinner, [1, "vm-spinner", {
  "isVideoView": [4, "is-video-view"],
  "currentProvider": [1, "current-provider"],
  "showWhenMediaLoading": [4, "show-when-media-loading"],
  "playbackReady": [4, "playback-ready"],
  "buffering": [4],
  "isHidden": [32],
  "isActive": [32]
}]);
exports.VmSpinner = VmSpinner;
var VmSubmenu = /*@__PURE__*/(0, _client.proxyCustomElement)(Submenu, [1, "vm-submenu", {
  "label": [1],
  "hint": [1],
  "slideInDirection": [1, "slide-in-direction"],
  "active": [1540],
  "menu": [32],
  "controller": [32]
}]);
exports.VmSubmenu = VmSubmenu;
var VmTime = /*@__PURE__*/(0, _client.proxyCustomElement)(Time, [1, "vm-time", {
  "label": [1],
  "seconds": [2],
  "alwaysShowHours": [4, "always-show-hours"]
}]);
exports.VmTime = VmTime;
var VmTimeProgress = /*@__PURE__*/(0, _client.proxyCustomElement)(TimeProgress, [1, "vm-time-progress", {
  "separator": [1],
  "alwaysShowHours": [4, "always-show-hours"]
}]);
exports.VmTimeProgress = VmTimeProgress;
var VmTooltip = /*@__PURE__*/(0, _client.proxyCustomElement)(Tooltip, [1, "vm-tooltip", {
  "hidden": [4],
  "active": [4],
  "position": [1],
  "direction": [1],
  "isTouch": [4, "is-touch"],
  "isMobile": [4, "is-mobile"]
}]);
exports.VmTooltip = VmTooltip;
var VmUi = /*@__PURE__*/(0, _client.proxyCustomElement)(UI, [1, "vm-ui", {
  "isVideoView": [4, "is-video-view"],
  "playsinline": [4],
  "isFullscreenActive": [4, "is-fullscreen-active"]
}]);
exports.VmUi = VmUi;
var VmVideo = /*@__PURE__*/(0, _client.proxyCustomElement)(Video, [4, "vm-video", {
  "willAttach": [4, "will-attach"],
  "hasCustomTextManager": [4, "has-custom-text-manager"],
  "crossOrigin": [1, "cross-origin"],
  "preload": [1],
  "poster": [1],
  "controlsList": [1, "controls-list"],
  "autoPiP": [4, "auto-pip"],
  "disablePiP": [4, "disable-pip"],
  "disableRemotePlayback": [4, "disable-remote-playback"],
  "mediaTitle": [1, "media-title"]
}, [[0, "vmMediaProviderConnect", "onProviderConnect"], [0, "vmMediaProviderDisconnect", "onProviderDisconnect"]]]);
exports.VmVideo = VmVideo;
var VmVimeo = /*@__PURE__*/(0, _client.proxyCustomElement)(Vimeo, [1, "vm-vimeo", {
  "videoId": [1, "video-id"],
  "byline": [4],
  "color": [1],
  "portrait": [4],
  "noAutoAspectRatio": [4, "no-auto-aspect-ratio"],
  "poster": [1],
  "cookies": [4],
  "language": [1],
  "aspectRatio": [1, "aspect-ratio"],
  "autoplay": [4],
  "controls": [4],
  "logger": [16],
  "loop": [4],
  "muted": [4],
  "playsinline": [4],
  "embedSrc": [32],
  "mediaTitle": [32]
}]);
exports.VmVimeo = VmVimeo;
var VmVolumeControl = /*@__PURE__*/(0, _client.proxyCustomElement)(VolumeControl, [1, "vm-volume-control", {
  "lowVolumeIcon": [1, "low-volume-icon"],
  "highVolumeIcon": [1, "high-volume-icon"],
  "mutedIcon": [1, "muted-icon"],
  "icons": [1],
  "tooltipPosition": [1, "tooltip-position"],
  "tooltipDirection": [1, "tooltip-direction"],
  "hideTooltip": [4, "hide-tooltip"],
  "muteKeys": [1, "mute-keys"],
  "noKeyboard": [4, "no-keyboard"],
  "muted": [4],
  "volume": [2],
  "isMobile": [4, "is-mobile"],
  "i18n": [16],
  "currentVolume": [32],
  "isSliderActive": [32]
}]);
exports.VmVolumeControl = VmVolumeControl;
var VmYoutube = /*@__PURE__*/(0, _client.proxyCustomElement)(YouTube, [1, "vm-youtube", {
  "cookies": [4],
  "videoId": [1, "video-id"],
  "showFullscreenControl": [4, "show-fullscreen-control"],
  "poster": [1],
  "language": [1],
  "autoplay": [4],
  "controls": [4],
  "logger": [16],
  "loop": [4],
  "muted": [4],
  "playsinline": [4],
  "embedSrc": [32],
  "mediaTitle": [32]
}]);
exports.VmYoutube = VmYoutube;

var defineCustomElements = opts => {
  if (typeof customElements !== 'undefined') {
    [VmAudio, VmCaptionControl, VmCaptions, VmClickToPlay, VmControl, VmControlGroup, VmControlSpacer, VmControls, VmCurrentTime, VmDailymotion, VmDash, VmDblClickFullscreen, VmDefaultControls, VmDefaultSettings, VmDefaultUi, VmEmbed, VmEndTime, VmFile, VmFullscreenControl, VmHls, VmIcon, VmIconLibrary, VmLiveIndicator, VmLoadingScreen, VmMenu, VmMenuItem, VmMenuRadio, VmMenuRadioGroup, VmMuteControl, VmPipControl, VmPlaybackControl, VmPlayer, VmPoster, VmScrim, VmScrubberControl, VmSettings, VmSettingsControl, VmSkeleton, VmSlider, VmSpinner, VmSubmenu, VmTime, VmTimeProgress, VmTooltip, VmUi, VmVideo, VmVimeo, VmVolumeControl, VmYoutube].forEach(cmp => {
      if (!customElements.get(cmp.is)) {
        customElements.define(cmp.is, cmp, opts);
      }
    });
  }
};

exports.defineCustomElements = defineCustomElements;
