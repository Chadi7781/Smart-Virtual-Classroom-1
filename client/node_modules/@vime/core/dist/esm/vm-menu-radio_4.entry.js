import { r as registerInstance, c as createEvent, h, g as getElement, w as writeTask } from './index-d8f97135.js';
import { w as withComponentRegistry, D as Disposal, o as isUndefined, l as listen } from './withComponentRegistry-892f231d.js';
import { c as createDispatcher } from './PlayerDispatcher-4fcbdce9.js';
import { w as withPlayerContext } from './withPlayerContext-9c30712f.js';
import './PlayerEvents-c74733e6.js';
import { w as withControlsCollisionDetection } from './withControlsCollisionDetection-4caf07d4.js';

const MenuRadio = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.vmCheck = createEvent(this, "vmCheck", 7);
    /**
     * Whether the radio item is selected or not.
     */
    this.checked = false;
    /**
     * The URL to an SVG element or fragment to load.
     */
    this.checkIcon = 'check';
    withComponentRegistry(this);
  }
  onClick() {
    this.checked = true;
    this.vmCheck.emit();
  }
  render() {
    return (h("vm-menu-item", { label: this.label, checked: this.checked, badge: this.badge, checkIcon: this.checkIcon, icons: this.icons, onClick: this.onClick.bind(this) }));
  }
};

const MenuRadioGroup = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.vmCheck = createEvent(this, "vmCheck", 7);
    withComponentRegistry(this);
  }
  onValueChange() {
    this.findRadios()?.forEach((radio) => {
      radio.checked = radio.value === this.value;
    });
  }
  connectedCallback() {
    this.onValueChange();
  }
  componentDidLoad() {
    this.onValueChange();
  }
  onSelectionChange(event) {
    const radio = event.target;
    this.value = radio.value;
  }
  findRadios() {
    return this.host
      .shadowRoot.querySelector('slot')
      ?.assignedElements();
  }
  render() {
    return h("slot", null);
  }
  get host() { return getElement(this); }
  static get watchers() { return {
    "value": ["onValueChange"]
  }; }
};

const settingsCss = ":host{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:var(--vm-menu-z-index)}.settings{position:absolute;opacity:0;pointer-events:auto;overflow-x:hidden;overflow-y:auto;background-color:var(--vm-menu-bg);max-height:var(--vm-settings-max-height);border-radius:var(--vm-settings-border-radius);padding:var(--vm-settings-padding);box-shadow:var(--vm-settings-shadow);box-sizing:border-box;scrollbar-width:thin;scroll-behavior:smooth;scrollbar-color:var(--vm-settings-scroll-thumb-color) var(--vm-settings-scroll-track-color);transform:translateY(8px);transition:var(--vm-settings-transition)}.container{display:block;width:var(--vm-settings-width);height:100%;position:relative;transition:width 0.25s ease-in, height 0.25s ease-in}.settings.hydrated{visibility:hidden !important}.settings::-webkit-scrollbar{width:var(--vm-settings-scroll-width)}.settings::-webkit-scrollbar-track{background:var(--vm-settings-scroll-track-color)}.settings::-webkit-scrollbar-thumb{border-radius:var(--vm-settings-scroll-width);background-color:var(--vm-settings-scroll-thumb-color);border:2px solid var(--vm-menu-bg)}.settings.active{transform:translateY(0);opacity:1;visibility:visible !important}.settings.mobile{position:fixed;top:auto !important;left:0 !important;right:0 !important;bottom:0 !important;width:100%;min-height:56px;max-height:50%;border-radius:0;z-index:2147483647;transform:translateY(100%)}.settings.mobile.active{transform:translateY(0)}.settings.mobile>vm-menu{height:100% !important;overflow:auto !important}";

let idCount = 0;
const Settings = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.disposal = new Disposal();
    this.menuHeight = 0;
    /**
     * Pins the settings to the defined position inside the video player. This has no effect when
     * the view is of type `audio` (always `bottomRight`) and on mobile devices (always bottom sheet).
     */
    this.pin = 'bottomRight';
    /**
     * Whether the settings menu is opened/closed.
     */
    this.active = false;
    /** @internal */
    this.isMobile = false;
    /** @internal */
    this.isAudioView = false;
    withComponentRegistry(this);
    withControlsCollisionDetection(this);
    withPlayerContext(this, ['isMobile', 'isAudioView']);
  }
  onActiveChange() {
    this.dispatch('isSettingsActive', this.active);
    if (isUndefined(this.controller))
      return;
    this.controller.expanded = this.active;
  }
  connectedCallback() {
    this.dispatch = createDispatcher(this);
    idCount += 1;
    this.id = `vm-settings-${idCount}`;
  }
  disconnectedCallback() {
    this.disposal.empty();
  }
  /**
   * Sets the controller responsible for opening/closing this settings menu.
   */
  async setController(controller) {
    this.controller = controller;
    this.controller.menu = this.id;
    this.disposal.empty();
    this.disposal.add(listen(this.controller, 'click', () => {
      this.active = !this.active;
    }));
    this.disposal.add(listen(this.controller, 'keydown', (event) => {
      if (event.key !== 'Enter')
        return;
      // We're looking for !active because the `click` event above will toggle it to active.
      if (!this.active)
        this.menu.focusMenu();
    }));
  }
  getPosition() {
    if (this.isAudioView) {
      return {
        right: '0',
        bottom: 'calc(var(--vm-controls-height, 0) + 4px)',
      };
    }
    // topLeft => { top: 0, left: 0 }
    const pos = this.pin.split(/(?=[L|R])/).map((s) => s.toLowerCase());
    return {
      [pos.includes('top') ? 'top' : 'bottom']: 'var(--vm-controls-height, 0)',
      [pos.includes('left') ? 'left' : 'right']: '8px',
    };
  }
  onOpen(event) {
    if (event.detail?.identifier !== this.id)
      return;
    this.active = true;
  }
  onClose(event) {
    if (event.detail?.identifier !== this.id)
      return;
    this.active = false;
  }
  onHeightChange(event) {
    this.menuHeight = event.detail;
  }
  render() {
    return (h("div", { style: {
        ...this.getPosition(),
      }, class: {
        settings: true,
        active: this.active,
        mobile: this.isMobile,
      } }, h("div", { class: "container", style: { height: `${this.menuHeight}px` } }, h("vm-menu", { identifier: this.id, active: this.active, controller: this.controller, onVmOpen: this.onOpen.bind(this), onVmClose: this.onClose.bind(this), onVmMenuHeightChange: this.onHeightChange.bind(this), ref: (el) => {
        this.menu = el;
      } }, h("slot", null)))));
  }
  get host() { return getElement(this); }
  static get watchers() { return {
    "active": ["onActiveChange"]
  }; }
};
Settings.style = settingsCss;

let idCount$1 = 0;
const Submenu = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.vmOpenSubmenu = createEvent(this, "vmOpenSubmenu", 7);
    this.vmCloseSubmenu = createEvent(this, "vmCloseSubmenu", 7);
    /**
     * The direction the submenu should slide in from.
     */
    this.slideInDirection = 'right';
    /**
     * Whether the submenu is open/closed.
     */
    this.active = false;
    withComponentRegistry(this);
  }
  connectedCallback() {
    this.genId();
  }
  /**
   * Returns the controller (`vm-menu-item`) for this submenu.
   */
  async getController() {
    return this.controller;
  }
  /**
   * Returns the menu (`vm-menu`) for this submenu.
   */
  async getMenu() {
    return this.menu;
  }
  /**
   * Returns the height of the submenu controller.
   */
  async getControllerHeight() {
    return this.controller?.getHeight() ?? 0;
  }
  getControllerHeightSync() {
    const el = this.controller?.shadowRoot.querySelector("[role='menuitem']");
    return el ? parseFloat(window.getComputedStyle(el).height) : 0;
  }
  onMenuOpen() {
    this.active = true;
    this.vmOpenSubmenu.emit(this.host);
  }
  onMenuClose() {
    this.active = false;
    this.vmCloseSubmenu.emit(this.host);
  }
  genId() {
    idCount$1 += 1;
    this.id = `vm-submenu-${idCount$1}`;
  }
  getControllerId() {
    return `${this.id}-controller`;
  }
  render() {
    return (h("div", null, h("vm-menu-item", { identifier: this.getControllerId(), menu: this.menu, label: this.label, hint: this.hint, expanded: this.active, ref: (el) => {
        writeTask(() => {
          this.controller = el;
        });
      } }), h("vm-menu", { identifier: this.id, controller: this.controller, active: this.active, slideInDirection: this.slideInDirection, onVmOpen: this.onMenuOpen.bind(this), onVmClose: this.onMenuClose.bind(this), ref: (el) => {
        writeTask(() => {
          this.menu = el;
        });
      }, style: { top: `${this.getControllerHeightSync() + 1}px` } }, h("slot", null))));
  }
  get host() { return getElement(this); }
};

export { MenuRadio as vm_menu_radio, MenuRadioGroup as vm_menu_radio_group, Settings as vm_settings, Submenu as vm_submenu };
