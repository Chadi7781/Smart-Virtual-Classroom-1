import { r as registerInstance, c as createEvent, h } from './index-d8f97135.js';
import './PlayerProps-2c57fcea.js';
import { w as withComponentRegistry, m as isNullOrUndefined, o as isUndefined, e as isString } from './withComponentRegistry-892f231d.js';
import { w as withPlayerContext } from './withPlayerContext-9c30712f.js';
import './PlayerEvents-c74733e6.js';
import { M as MediaType } from './MediaType-aec4c150.js';
import './Provider-2e7e8366.js';
import { h as hlsRegex, b as hlsTypeRegex } from './utils-7dc44688.js';
import { w as withProviderConnect, c as createProviderDispatcher } from './ProviderConnect-e344bf51.js';
import './support-cbf90a90.js';
import { l as loadSDK } from './network-a8b10802.js';

const HLS = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.vmLoadStart = createEvent(this, "vmLoadStart", 7);
    this.vmError = createEvent(this, "vmError", 7);
    this.hasAttached = false;
    /**
     * The NPM package version of the `hls.js` library to download and use if HLS is not natively
     * supported.
     */
    this.version = 'latest';
    /** @inheritdoc */
    this.preload = 'metadata';
    /** @internal */
    this.playbackReady = false;
    withComponentRegistry(this);
    withProviderConnect(this);
    withPlayerContext(this, ['playbackReady']);
  }
  connectedCallback() {
    this.dispatch = createProviderDispatcher(this);
    if (this.mediaEl)
      this.setupHls();
  }
  disconnectedCallback() {
    this.destroyHls();
  }
  get src() {
    if (isNullOrUndefined(this.videoProvider))
      return undefined;
    const sources = this.videoProvider.querySelectorAll('source');
    const currSource = Array.from(sources).find((source) => hlsRegex.test(source.src) || hlsTypeRegex.test(source.type));
    return currSource?.src;
  }
  async setupHls() {
    if (!isUndefined(this.hls))
      return;
    try {
      const url = this.libSrc ||
        `https://cdn.jsdelivr.net/npm/hls.js@${this.version}/dist/hls.min.js`;
      const Hls = await loadSDK(url, 'Hls');
      if (!Hls.isSupported()) {
        this.vmError.emit('hls.js is not supported');
        return;
      }
      this.hls = new Hls(this.config);
      this.hls.on(Hls.Events.MEDIA_ATTACHED, () => {
        this.hasAttached = true;
        this.onSrcChange();
      });
      this.hls.on(Hls.Events.AUDIO_TRACKS_UPDATED, () => {
        this.dispatch('audioTracks', this.hls.audioTracks);
        this.dispatch('currentAudioTrack', this.hls.audioTrack);
      });
      this.hls.on(Hls.Events.AUDIO_TRACK_SWITCHED, () => {
        this.dispatch('currentAudioTrack', this.hls.audioTrack);
      });
      this.hls.on(Hls.Events.ERROR, (event, data) => {
        if (data.fatal) {
          switch (data.type) {
            case Hls.ErrorTypes.NETWORK_ERROR:
              this.hls.startLoad();
              break;
            case Hls.ErrorTypes.MEDIA_ERROR:
              this.hls.recoverMediaError();
              break;
            default:
              this.destroyHls();
              break;
          }
        }
        this.vmError.emit({ event, data });
      });
      this.hls.on(Hls.Events.MANIFEST_PARSED, () => {
        this.dispatch('mediaType', MediaType.Video);
        this.dispatch('currentSrc', this.src);
        this.dispatchLevels();
      });
      this.hls.on(Hls.Events.LEVEL_LOADED, (_, data) => {
        if (!this.playbackReady) {
          this.dispatch('duration', data.details.totalduration);
          this.dispatch('playbackReady', true);
        }
      });
      this.hls.attachMedia(this.mediaEl);
    }
    catch (e) {
      this.vmError.emit(e);
    }
  }
  dispatchLevels() {
    if (!this.hls.levels || this.hls.levels.length === 0)
      return;
    this.dispatch('playbackQualities', [
      'Auto',
      ...this.hls.levels.map(this.levelToPlaybackQuality),
    ]);
    this.dispatch('playbackQuality', 'Auto');
  }
  levelToPlaybackQuality(level) {
    return level === -1 ? 'Auto' : `${level.height}p`;
  }
  findLevelIndexFromQuality(quality) {
    return this.hls.levels.findIndex((level) => this.levelToPlaybackQuality(level) === quality);
  }
  destroyHls() {
    this.hls?.destroy();
    this.hasAttached = false;
  }
  async onMediaElChange(event) {
    this.destroyHls();
    if (isUndefined(event.detail))
      return;
    this.mediaEl = event.detail;
    // Need a small delay incase the media element changes rapidly and Hls.js can't reattach.
    setTimeout(async () => {
      await this.setupHls();
    }, 50);
  }
  async onSrcChange() {
    if (this.hasAttached && this.hls.url !== this.src) {
      this.vmLoadStart.emit();
      this.hls.loadSource(this.src);
    }
  }
  /** @internal */
  async getAdapter() {
    const adapter = (await this.videoProvider?.getAdapter()) ?? {};
    const canVideoProviderPlay = adapter.canPlay;
    return {
      ...adapter,
      getInternalPlayer: async () => this.hls,
      canPlay: async (type) => (isString(type) && hlsRegex.test(type)) ||
        (canVideoProviderPlay?.(type) ?? false),
      canSetPlaybackQuality: async () => this.hls?.levels?.length > 0,
      setPlaybackQuality: async (quality) => {
        if (!isUndefined(this.hls)) {
          this.hls.currentLevel = this.findLevelIndexFromQuality(quality);
          // Update the provider cache.
          this.dispatch('playbackQuality', quality);
        }
      },
      setCurrentAudioTrack: async (trackId) => {
        if (!isUndefined(this.hls)) {
          this.hls.audioTrack = trackId;
        }
      },
    };
  }
  render() {
    return (h("vm-video", { willAttach: true, crossOrigin: this.crossOrigin, preload: this.preload, poster: this.poster, controlsList: this.controlsList, autoPiP: this.autoPiP, disablePiP: this.disablePiP, disableRemotePlayback: this.disableRemotePlayback, mediaTitle: this.mediaTitle, ref: (el) => {
        this.videoProvider = el;
      } }, h("slot", null)));
  }
};

export { HLS as vm_hls };
