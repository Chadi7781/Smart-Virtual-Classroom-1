import { r as registerInstance, c as createEvent, h, g as getElement } from './index-d8f97135.js';
import './PlayerProps-2c57fcea.js';
import { D as Disposal, w as withComponentRegistry, b as watchComponentRegistry, m as isNullOrUndefined, v as isNull, o as isUndefined, t as isNumber, e as isString, l as listen } from './withComponentRegistry-892f231d.js';
import './withPlayerContext-9c30712f.js';
import './PlayerEvents-c74733e6.js';
import { V as ViewType } from './ViewType-6da43616.js';
import { M as MediaType } from './MediaType-aec4c150.js';
import './Provider-2e7e8366.js';
import { a as audioRegex, v as videoRegex, h as hlsRegex } from './utils-7dc44688.js';
import { w as withProviderConnect, c as createProviderDispatcher } from './ProviderConnect-e344bf51.js';
import { d as IS_IOS, e as canUsePiPInChrome, f as canUsePiPInSafari, g as canUsePiP, h as canFullscreenVideo } from './support-cbf90a90.js';
import { w as withProviderContext } from './withProviderContext-d3353de4.js';
import { L as LazyLoader } from './LazyLoader-6a189087.js';

const fileCss = "audio.sc-vm-file,video.sc-vm-file{border-radius:inherit;vertical-align:middle;width:100%;outline:0}video.sc-vm-file{position:absolute;top:0;left:0;border:0;height:100%;user-select:none}";

const File = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.vmLoadStart = createEvent(this, "vmLoadStart", 7);
    this.vmError = createEvent(this, "vmError", 7);
    this.vmMediaElChange = createEvent(this, "vmMediaElChange", 7);
    this.vmSrcSetChange = createEvent(this, "vmSrcSetChange", 7);
    this.textTracksDisposal = new Disposal();
    this.wasPausedBeforeSeeking = true;
    this.currentSrcSet = [];
    this.mediaQueryDisposal = new Disposal();
    /** @internal Whether an external SDK will attach itself to the media player and control it. */
    this.willAttach = false;
    /** @inheritdoc */
    this.preload = 'metadata';
    /**
     * The playback rates that are available for this media.
     */
    this.playbackRates = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 2];
    /** @internal */
    this.language = 'en';
    /** @internal */
    this.autoplay = false;
    /** @internal */
    this.controls = false;
    /** @internal */
    this.loop = false;
    /** @internal */
    this.muted = false;
    /** @internal */
    this.playsinline = false;
    /** @internal */
    this.noConnect = false;
    /** @internal */
    this.paused = true;
    /** @internal */
    this.currentTime = 0;
    /** @internal */
    this.volume = 0;
    /** @internal */
    this.playbackReady = false;
    /** @internal */
    this.playbackStarted = false;
    /** @internal */
    this.currentTextTrack = -1;
    /** @internal */
    this.hasCustomTextManager = false;
    /** @internal */
    this.isTextTrackVisible = true;
    /** @internal */
    this.shouldRenderNativeTextTracks = true;
    withComponentRegistry(this);
    withProviderConnect(this);
    withProviderContext(this, [
      'playbackReady',
      'playbackStarted',
      'currentTime',
      'volume',
      'paused',
      'currentTextTrack',
      'isTextTrackVisible',
      'shouldRenderNativeTextTracks',
    ]);
    watchComponentRegistry(this, 'vm-poster', (regs) => {
      [this.vmPoster] = regs;
    });
  }
  onMediaTitleChange() {
    this.dispatch('mediaTitle', this.mediaTitle);
  }
  onPosterChange() {
    if (!this.playbackStarted)
      this.mediaEl?.load();
  }
  onViewTypeChange() {
    this.dispatch('viewType', this.viewType);
  }
  connectedCallback() {
    this.initLazyLoader();
    this.dispatch = createProviderDispatcher(this);
    this.onViewTypeChange();
    this.onPosterChange();
    this.onMediaTitleChange();
  }
  componentDidRender() {
    if (this.prevMediaEl !== this.mediaEl) {
      this.prevMediaEl = this.mediaEl;
      this.vmMediaElChange.emit(this.mediaEl);
    }
  }
  componentDidLoad() {
    this.onViewTypeChange();
  }
  disconnectedCallback() {
    this.mediaQueryDisposal.empty();
    this.textTracksDisposal.empty();
    this.cancelTimeUpdates();
    this.lazyLoader?.destroy();
    this.wasPausedBeforeSeeking = true;
  }
  initLazyLoader() {
    this.lazyLoader = new LazyLoader(this.host, ['data-src', 'data-poster'], () => {
      if (isNullOrUndefined(this.mediaEl))
        return;
      const poster = this.mediaEl.getAttribute('data-poster');
      if (!isNull(poster))
        this.mediaEl.setAttribute('poster', poster);
      this.refresh();
      this.didSrcSetChange();
    });
  }
  refresh() {
    if (isNullOrUndefined(this.mediaEl))
      return;
    const { children } = this.mediaEl;
    for (let i = 0; i <= children.length - 1; i += 1) {
      const child = children[i];
      const src = child.getAttribute('data-src') ||
        child.getAttribute('src') ||
        child.getAttribute('data-vs');
      child.removeAttribute('src');
      if (isNull(src))
        continue;
      child.setAttribute('data-vs', src);
      child.setAttribute('src', src);
    }
  }
  didSrcSetChange() {
    if (isNullOrUndefined(this.mediaEl))
      return;
    const sources = Array.from(this.mediaEl.querySelectorAll('source'));
    const srcSet = sources.map((source) => ({
      src: source.getAttribute('data-vs'),
      media: source.getAttribute('data-media') ?? undefined,
      ref: source,
    }));
    const didChange = this.currentSrcSet.length !== srcSet.length ||
      srcSet.some((resource, i) => this.currentSrcSet[i].src !== resource.src);
    if (didChange) {
      this.currentSrcSet = srcSet;
      this.onSrcSetChange();
    }
  }
  onSrcSetChange() {
    this.textTracksDisposal.empty();
    this.mediaQueryDisposal.empty();
    this.vmLoadStart.emit();
    this.vmSrcSetChange.emit(this.currentSrcSet);
    if (!this.willAttach)
      this.mediaEl?.load();
  }
  hasCustomPoster() {
    return !IS_IOS && !isUndefined(this.vmPoster);
  }
  cancelTimeUpdates() {
    if (isNumber(this.timeRAF))
      window.cancelAnimationFrame(this.timeRAF);
    this.timeRAF = undefined;
  }
  requestTimeUpdates() {
    this.dispatch('currentTime', this.mediaEl?.currentTime ?? 0);
    this.timeRAF = window.requestAnimationFrame(() => {
      this.requestTimeUpdates();
    });
  }
  getMediaType() {
    const { currentSrc } = this.mediaEl;
    if (audioRegex.test(currentSrc))
      return MediaType.Audio;
    if (videoRegex.test(currentSrc) || hlsRegex.test(currentSrc))
      return MediaType.Video;
    return undefined;
  }
  onLoadedMetadata() {
    this.mediaEl.volume = this.volume / 100;
    this.listenToTextTracksForChanges();
    this.onTextTracksChange();
    this.onProgress();
    this.dispatch('currentPoster', this.poster);
    this.dispatch('duration', this.mediaEl.duration);
    this.dispatch('playbackRates', this.playbackRates);
    if (!this.willAttach) {
      this.dispatch('currentSrc', this.mediaEl.currentSrc);
      this.dispatch('mediaType', this.getMediaType());
      this.dispatch('playbackReady', true);
    }
  }
  onProgress() {
    const { buffered, duration } = this.mediaEl;
    const end = buffered.length === 0 ? 0 : buffered.end(buffered.length - 1);
    this.dispatch('buffered', end > duration ? duration : end);
  }
  onPlay() {
    this.requestTimeUpdates();
    this.dispatch('paused', false);
    if (!this.playbackStarted)
      this.dispatch('playbackStarted', true);
  }
  onPause() {
    this.cancelTimeUpdates();
    this.dispatch('paused', true);
    this.dispatch('buffering', false);
  }
  onPlaying() {
    this.dispatch('playing', true);
    this.dispatch('buffering', false);
  }
  onSeeking() {
    if (!this.wasPausedBeforeSeeking)
      this.wasPausedBeforeSeeking = this.mediaEl.paused;
    this.dispatch('currentTime', this.mediaEl.currentTime);
    this.dispatch('seeking', true);
  }
  onSeeked() {
    // Avoid calling `attemptToPlay` if seeking to 0 on 0.
    if (this.currentTime === 0 && !this.playbackStarted)
      return;
    this.dispatch('seeking', false);
    if (!this.playbackStarted || !this.wasPausedBeforeSeeking)
      this.attemptToPlay();
    this.wasPausedBeforeSeeking = true;
  }
  onRateChange() {
    this.dispatch('playbackRate', this.mediaEl.playbackRate);
  }
  onVolumeChange() {
    this.dispatch('muted', this.mediaEl.muted);
    this.dispatch('volume', this.mediaEl.volume * 100);
  }
  onDurationChange() {
    this.dispatch('duration', this.mediaEl.duration);
  }
  onWaiting() {
    this.dispatch('buffering', true);
  }
  onSuspend() {
    this.dispatch('buffering', false);
  }
  onEnded() {
    if (!this.loop)
      this.dispatch('playbackEnded', true);
  }
  onError() {
    this.vmError.emit(this.mediaEl.error);
  }
  attemptToPlay() {
    try {
      this.mediaEl?.play();
    }
    catch (e) {
      this.vmError.emit(e);
    }
  }
  togglePiPInChrome(toggle) {
    return toggle
      ? this.mediaEl?.requestPictureInPicture()
      : document.exitPictureInPicture();
  }
  togglePiPInSafari(toggle) {
    const mode = toggle
      ? "picture-in-picture" /* PiP */
      : "inline" /* Inline */;
    if (!this.mediaEl?.webkitSupportsPresentationMode(mode)) {
      throw new Error('PiP API is not available.');
    }
    return this.mediaEl?.webkitSetPresentationMode(mode);
  }
  async togglePiP(toggle) {
    if (canUsePiPInChrome())
      return this.togglePiPInChrome(toggle);
    if (canUsePiPInSafari())
      return this.togglePiPInSafari(toggle);
    throw new Error('PiP API is not available.');
  }
  async toggleFullscreen(toggle) {
    if (!this.mediaEl?.webkitSupportsFullscreen) {
      throw new Error('Fullscreen API is not available.');
    }
    return toggle
      ? this.mediaEl?.webkitEnterFullscreen()
      : this.mediaEl?.webkitExitFullscreen();
  }
  onPresentationModeChange() {
    const mode = this.mediaEl?.webkitPresentationMode;
    this.dispatch('isPiPActive', mode === "picture-in-picture" /* PiP */);
    this.dispatch('isFullscreenActive', mode === "fullscreen" /* Fullscreen */);
  }
  onEnterPiP() {
    this.dispatch('isPiPActive', true);
  }
  onLeavePiP() {
    this.dispatch('isPiPActive', false);
  }
  /** @internal */
  async getAdapter() {
    return {
      getInternalPlayer: async () => this.mediaEl,
      play: async () => this.mediaEl?.play(),
      pause: async () => this.mediaEl?.pause(),
      canPlay: async (type) => isString(type) && (audioRegex.test(type) || videoRegex.test(type)),
      setCurrentTime: async (time) => {
        if (this.mediaEl)
          this.mediaEl.currentTime = time;
      },
      setMuted: async (muted) => {
        if (this.mediaEl)
          this.mediaEl.muted = muted;
      },
      setVolume: async (volume) => {
        if (this.mediaEl)
          this.mediaEl.volume = volume / 100;
      },
      canSetPlaybackRate: async () => true,
      setPlaybackRate: async (rate) => {
        if (this.mediaEl)
          this.mediaEl.playbackRate = rate;
      },
      canSetPiP: async () => canUsePiP(),
      enterPiP: () => this.togglePiP(true),
      exitPiP: () => this.togglePiP(false),
      canSetFullscreen: async () => canFullscreenVideo(),
      enterFullscreen: () => this.toggleFullscreen(true),
      exitFullscreen: () => this.toggleFullscreen(false),
      setCurrentTextTrack: async (trackId) => {
        if (trackId !== this.currentTextTrack)
          this.toggleTextTrackModes(trackId);
      },
      setTextTrackVisibility: async (isVisible) => {
        this.isTextTrackVisible = isVisible;
        this.toggleTextTrackModes(this.currentTextTrack);
      },
    };
  }
  onHasCustomTextManagerChange() {
    if (this.hasCustomTextManager) {
      this.textTracksDisposal.empty();
    }
    else if (this.playbackReady) {
      this.listenToTextTracksForChanges();
    }
  }
  onShouldRenderNativeTextTracksChange() {
    if (this.hasCustomTextManager)
      return;
    this.toggleTextTrackModes(this.currentTextTrack);
  }
  onProviderConnect(event) {
    if (this.noConnect)
      event.stopImmediatePropagation();
  }
  onProviderDisconnect(event) {
    if (this.noConnect)
      event.stopImmediatePropagation();
  }
  getFilteredTextTracks() {
    const tracks = [];
    const textTrackList = Array.from(this.mediaEl.textTracks);
    for (let i = 0; i < textTrackList.length; i += 1) {
      const track = textTrackList[i];
      // Edge adds a track without a label; we don't want to use it.
      if ((track.kind === 'subtitles' || track.kind === 'captions') &&
        track.label) {
        tracks.push(textTrackList[i]);
      }
    }
    return tracks;
  }
  listenToTextTracksForChanges() {
    if (this.hasCustomTextManager)
      return;
    this.textTracksDisposal.empty();
    if (isUndefined(this.mediaEl))
      return;
    this.textTracksDisposal.add(listen(this.mediaEl.textTracks, 'change', this.onTextTracksChange.bind(this)));
  }
  onTextTracksChange() {
    const tracks = this.getFilteredTextTracks();
    let trackId = -1;
    for (let id = 0; id < tracks.length; id += 1) {
      if (tracks[id].mode === 'hidden') {
        // Do not break in case there is a following track with showing.
        trackId = id;
      }
      else if (tracks[id].mode === 'showing') {
        trackId = id;
        break;
      }
    }
    if (!this.shouldRenderNativeTextTracks &&
      tracks[trackId]?.mode === 'showing') {
      tracks[trackId].mode = 'hidden';
      return;
    }
    if (this.shouldRenderNativeTextTracks) {
      this.isTextTrackVisible =
        trackId !== -1 && tracks[trackId].mode === 'showing';
      this.dispatch('isTextTrackVisible', this.isTextTrackVisible);
    }
    this.dispatch('textTracks', tracks);
    this.dispatch('currentTextTrack', this.shouldRenderNativeTextTracks && !this.isTextTrackVisible
      ? -1
      : trackId);
  }
  toggleTextTrackModes(newTrackId) {
    if (isNullOrUndefined(this.mediaEl))
      return;
    const { textTracks } = this.mediaEl;
    if (newTrackId === -1) {
      Array.from(textTracks).forEach((track) => {
        track.mode = 'disabled';
      });
    }
    else {
      const oldTrack = textTracks[this.currentTextTrack];
      if (oldTrack)
        oldTrack.mode = 'disabled';
    }
    const nextTrack = textTracks[newTrackId];
    if (nextTrack) {
      nextTrack.mode =
        this.isTextTrackVisible && this.shouldRenderNativeTextTracks
          ? 'showing'
          : 'hidden';
    }
    this.dispatch('currentTextTrack', this.shouldRenderNativeTextTracks && !this.isTextTrackVisible
      ? -1
      : newTrackId);
    this.dispatch('isTextTrackVisible', this.isTextTrackVisible);
  }
  render() {
    const mediaProps = {
      autoplay: this.autoplay,
      muted: this.muted,
      playsinline: this.playsinline,
      playsInline: this.playsinline,
      'x5-playsinline': this.playsinline,
      'webkit-playsinline': this.playsinline,
      controls: this.controls,
      crossorigin: this.crossOrigin === '' ? 'anonymous' : this.crossOrigin,
      controlslist: this.controlsList,
      'data-poster': !this.hasCustomPoster() ? this.poster : undefined,
      loop: this.loop,
      preload: this.preload,
      disablePictureInPicture: this.disablePiP,
      autoPictureInPicture: this.autoPiP,
      disableRemotePlayback: this.disableRemotePlayback,
      'x-webkit-airplay': this.disableRemotePlayback ? 'deny' : 'allow',
      ref: (el) => {
        this.mediaEl = el;
      },
      onLoadedMetadata: this.onLoadedMetadata.bind(this),
      onProgress: this.onProgress.bind(this),
      onPlay: this.onPlay.bind(this),
      onPause: this.onPause.bind(this),
      onPlaying: this.onPlaying.bind(this),
      onSeeking: this.onSeeking.bind(this),
      onSeeked: this.onSeeked.bind(this),
      onRateChange: this.onRateChange.bind(this),
      onVolumeChange: this.onVolumeChange.bind(this),
      onDurationChange: this.onDurationChange.bind(this),
      onWaiting: this.onWaiting.bind(this),
      onSuspend: this.onSuspend.bind(this),
      onEnded: this.onEnded.bind(this),
      onError: this.onError.bind(this),
    };
    const audio = (h("audio", Object.assign({ class: "lazy" }, mediaProps), h("slot", null), "Your browser does not support the", h("code", null, "audio"), "element."));
    const video = (h("video", Object.assign({ class: "lazy" }, mediaProps, {
      // @ts-ignore
      onwebkitpresentationmodechanged: this.onPresentationModeChange.bind(this), onenterpictureinpicture: this.onEnterPiP.bind(this), onleavepictureinpicture: this.onLeavePiP.bind(this)
    }), h("slot", null), "Your browser does not support the", h("code", null, "video"), "element."));
    return this.viewType === ViewType.Audio ? audio : video;
  }
  get host() { return getElement(this); }
  static get watchers() { return {
    "mediaTitle": ["onMediaTitleChange"],
    "poster": ["onPosterChange"],
    "viewType": ["onViewTypeChange"],
    "hasCustomTextManager": ["onHasCustomTextManagerChange"],
    "shouldRenderNativeTextTracks": ["onShouldRenderNativeTextTracksChange"]
  }; }
};
File.style = fileCss;

export { File as vm_file };
