'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-9e4d61ac.js');
require('./PlayerProps-4bbfc16a.js');
const withComponentRegistry = require('./withComponentRegistry-50d191fe.js');
const withPlayerContext = require('./withPlayerContext-460e142f.js');
require('./PlayerEvents-58225f02.js');
const MediaType = require('./MediaType-abb6d107.js');
require('./Provider-0e71f5a4.js');
const utils = require('./utils-b8b7354f.js');
const ProviderConnect = require('./ProviderConnect-3c00ee3c.js');
require('./support-4718bf00.js');
const network = require('./network-55de9370.js');

const dashCss = ":host{z-index:var(--vm-media-z-index)}";

const Dash = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.vmLoadStart = index.createEvent(this, "vmLoadStart", 7);
    this.vmError = index.createEvent(this, "vmError", 7);
    this.textTracksDisposal = new withComponentRegistry.Disposal();
    this.hasAttached = false;
    /**
     * The NPM package version of the `dashjs` library to download and use.
     */
    this.version = 'latest';
    /**
     * The `dashjs` configuration.
     */
    this.config = {};
    /** @internal */
    this.autoplay = false;
    /** @inheritdoc */
    this.preload = 'metadata';
    /**
     * Are text tracks enabled by default.
     */
    this.enableTextTracksByDefault = true;
    /** @internal */
    this.shouldRenderNativeTextTracks = true;
    /** @internal */
    this.isTextTrackVisible = true;
    /** @internal */
    this.currentTextTrack = -1;
    withComponentRegistry.withComponentRegistry(this);
    ProviderConnect.withProviderConnect(this);
    withPlayerContext.withPlayerContext(this, [
      'autoplay',
      'shouldRenderNativeTextTracks',
      'isTextTrackVisible',
      'currentTextTrack',
    ]);
  }
  onSrcChange() {
    if (!this.hasAttached)
      return;
    this.vmLoadStart.emit();
    this.dash.attachSource(this.src);
  }
  onShouldRenderNativeTextTracks() {
    if (this.shouldRenderNativeTextTracks) {
      this.textTracksDisposal.empty();
    }
    else {
      this.hideCurrentTextTrack();
    }
    this.dash?.enableForcedTextStreaming(!this.shouldRenderNativeTextTracks);
  }
  onTextTrackChange() {
    if (!this.shouldRenderNativeTextTracks || withComponentRegistry.isUndefined(this.dash))
      return;
    this.dash.setTextTrack(!this.isTextTrackVisible ? -1 : this.currentTextTrack);
    if (!this.isTextTrackVisible) {
      const track = Array.from(this.mediaEl?.textTracks ?? [])[this.currentTextTrack];
      if (track?.mode === 'hidden')
        this.dispatch('currentTextTrack', -1);
    }
  }
  connectedCallback() {
    this.dispatch = ProviderConnect.createProviderDispatcher(this);
    if (this.mediaEl)
      this.setupDash();
  }
  disconnectedCallback() {
    this.textTracksDisposal.empty();
    this.destroyDash();
  }
  async setupDash() {
    try {
      const url = this.libSrc ||
        `https://cdn.jsdelivr.net/npm/dashjs@${this.version}/dist/dash.all.min.js`;
      // eslint-disable-next-line no-shadow
      const DashSDK = await network.loadSDK(url, 'dashjs');
      this.dash = DashSDK.MediaPlayer(this.config).create();
      this.dash.initialize(this.mediaEl, null, this.autoplay);
      this.dash.setTextDefaultEnabled(this.enableTextTracksByDefault);
      this.dash.enableForcedTextStreaming(!this.shouldRenderNativeTextTracks);
      this.dash.on(DashSDK.MediaPlayer.events.PLAYBACK_METADATA_LOADED, () => {
        this.dispatch('mediaType', MediaType.MediaType.Video);
        this.dispatch('currentSrc', this.src);
        this.dispatchLevels();
        this.listenToTextTracksForChanges();
        this.dispatch('playbackReady', true);
      });
      this.dash.on(DashSDK.MediaPlayer.events.TRACK_CHANGE_RENDERED, () => {
        if (!this.shouldRenderNativeTextTracks)
          this.hideCurrentTextTrack();
      });
      this.dash.on(DashSDK.MediaPlayer.events.ERROR, (e) => {
        this.vmError.emit(e);
      });
      this.hasAttached = true;
    }
    catch (e) {
      this.vmError.emit(e);
    }
  }
  async destroyDash() {
    this.dash?.reset();
    this.hasAttached = false;
  }
  async onMediaElChange(event) {
    this.destroyDash();
    if (withComponentRegistry.isUndefined(event.detail))
      return;
    this.mediaEl = event.detail;
    await this.setupDash();
  }
  levelToPlaybackQuality(level) {
    return level === -1 ? 'Auto' : `${level.height}p`;
  }
  findLevelIndexFromQuality(quality) {
    return this.dash
      .getBitrateInfoListFor('video')
      .findIndex((level) => this.levelToPlaybackQuality(level) === quality);
  }
  dispatchLevels() {
    try {
      const levels = this.dash.getBitrateInfoListFor('video');
      if (levels?.length > 0) {
        this.dispatch('playbackQualities', [
          'Auto',
          ...levels.map(this.levelToPlaybackQuality),
        ]);
        this.dispatch('playbackQuality', 'Auto');
      }
    }
    catch (e) {
      this.vmError.emit(e);
    }
  }
  listenToTextTracksForChanges() {
    this.textTracksDisposal.empty();
    if (withComponentRegistry.isUndefined(this.mediaEl) || this.shouldRenderNativeTextTracks)
      return;
    // Init current track.
    const currentTrack = this.dash?.getCurrentTrackFor('text')?.index - 1 ?? -1;
    this.currentTextTrack = currentTrack;
    this.dispatch('currentTextTrack', currentTrack);
    this.textTracksDisposal.add(withComponentRegistry.listen(this.mediaEl.textTracks, 'change', this.onTextTracksChange.bind(this)));
  }
  getTextTracks() {
    return Array.from(this.mediaEl?.textTracks ?? []);
  }
  hideCurrentTextTrack() {
    const textTracks = this.getTextTracks();
    if (textTracks[this.currentTextTrack] && this.isTextTrackVisible) {
      textTracks[this.currentTextTrack].mode = 'hidden';
    }
  }
  onTextTracksChange() {
    this.hideCurrentTextTrack();
    this.dispatch('textTracks', this.getTextTracks());
    this.dispatch('isTextTrackVisible', this.isTextTrackVisible);
    this.dispatch('currentTextTrack', this.currentTextTrack);
  }
  /** @internal */
  async getAdapter() {
    const adapter = (await this.videoProvider?.getAdapter()) ?? {};
    const canVideoProviderPlay = adapter.canPlay;
    return {
      ...adapter,
      getInternalPlayer: async () => this.dash,
      canPlay: async (type) => (withComponentRegistry.isString(type) && utils.dashRegex.test(type)) ||
        (canVideoProviderPlay?.(type) ?? false),
      canSetPlaybackQuality: async () => {
        try {
          return this.dash?.getBitrateInfoListFor('video')?.length > 0;
        }
        catch (e) {
          this.vmError.emit(e);
          return false;
        }
      },
      setPlaybackQuality: async (quality) => {
        if (!withComponentRegistry.isUndefined(this.dash)) {
          const index = this.findLevelIndexFromQuality(quality);
          this.dash.updateSettings({
            streaming: {
              abr: {
                autoSwitchBitrate: {
                  video: index === -1,
                },
              },
            },
          });
          if (index >= 0)
            this.dash.setQualityFor('video', index);
          // Update the provider cache.
          this.dispatch('playbackQuality', quality);
        }
      },
      setCurrentTextTrack: async (trackId) => {
        if (this.shouldRenderNativeTextTracks) {
          adapter.setCurrentTextTrack(trackId);
        }
        else {
          this.currentTextTrack = trackId;
          this.dash?.setTextTrack(trackId);
          this.onTextTracksChange();
        }
      },
      setTextTrackVisibility: async (isVisible) => {
        if (this.shouldRenderNativeTextTracks) {
          adapter.setTextTrackVisibility(isVisible);
        }
        else {
          this.isTextTrackVisible = isVisible;
          this.dash?.enableText(isVisible);
          this.onTextTracksChange();
        }
      },
    };
  }
  render() {
    return (index.h("vm-video", { willAttach: true, crossOrigin: this.crossOrigin, preload: this.preload, poster: this.poster, controlsList: this.controlsList, autoPiP: this.autoPiP, disablePiP: this.disablePiP, hasCustomTextManager: !this.shouldRenderNativeTextTracks, disableRemotePlayback: this.disableRemotePlayback, mediaTitle: this.mediaTitle, ref: (el) => {
        this.videoProvider = el;
      } }));
  }
  static get watchers() { return {
    "src": ["onSrcChange"],
    "hasAttached": ["onSrcChange"],
    "shouldRenderNativeTextTracks": ["onShouldRenderNativeTextTracks"],
    "isTextTrackVisible": ["onTextTrackChange"],
    "currentTextTrack": ["onTextTrackChange"]
  }; }
};
Dash.style = dashCss;

exports.vm_dash = Dash;
