'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-9e4d61ac.js');
require('./PlayerProps-4bbfc16a.js');
const withComponentRegistry = require('./withComponentRegistry-50d191fe.js');
require('./withPlayerContext-460e142f.js');
require('./PlayerEvents-58225f02.js');
const ViewType = require('./ViewType-435b01ff.js');
const MediaType = require('./MediaType-abb6d107.js');
require('./Provider-0e71f5a4.js');
const ProviderConnect = require('./ProviderConnect-3c00ee3c.js');
require('./support-4718bf00.js');
const network = require('./network-55de9370.js');
const withProviderContext = require('./withProviderContext-43586e81.js');

const dailymotionCss = ":host{z-index:var(--vm-media-z-index)}";

const videoInfoCache = new Map();
const Dailymotion = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.vmLoadStart = index.createEvent(this, "vmLoadStart", 7);
    this.vmError = index.createEvent(this, "vmError", 7);
    this.defaultInternalState = {};
    this.internalState = {
      currentTime: 0,
      volume: 0,
      muted: false,
      isAdsPlaying: false,
      playbackReady: false,
    };
    this.embedSrc = '';
    this.mediaTitle = '';
    /**
     * Whether to automatically play the next video in the queue.
     */
    this.shouldAutoplayQueue = false;
    /**
     * Whether to show the 'Up Next' queue.
     */
    this.showUpNextQueue = false;
    /**
     * Whether to show buttons for sharing the video.
     */
    this.showShareButtons = false;
    /**
     * Whether to display the Dailymotion logo.
     */
    this.showDailymotionLogo = false;
    /**
     * Whether to show video information (title and owner) on the start screen.
     */
    this.showVideoInfo = true;
    /** @internal */
    this.language = 'en';
    /** @internal */
    this.autoplay = false;
    /** @internal */
    this.controls = false;
    /** @internal */
    this.loop = false;
    /** @internal */
    this.muted = false;
    /** @internal */
    this.playsinline = false;
    withComponentRegistry.withComponentRegistry(this);
    ProviderConnect.withProviderConnect(this);
    withProviderContext.withProviderContext(this);
  }
  onVideoIdChange() {
    this.internalState = { ...this.defaultInternalState };
    if (!this.videoId) {
      this.embedSrc = '';
      return;
    }
    this.embedSrc = `${this.getOrigin()}/embed/video/${this.videoId}?api=1`;
    this.fetchVideoInfo = this.getVideoInfo();
    this.pendingMediaTitleCall = withComponentRegistry.deferredPromise();
  }
  onControlsChange() {
    if (this.internalState.playbackReady) {
      this.remoteControl("controls" /* Controls */, this.controls);
    }
  }
  onCustomPosterChange() {
    this.dispatch('currentPoster', this.poster);
  }
  connectedCallback() {
    this.dispatch = ProviderConnect.createProviderDispatcher(this);
    this.dispatch('viewType', ViewType.ViewType.Video);
    this.onVideoIdChange();
    this.initialMuted = this.muted;
    this.internalState.muted = this.muted;
    this.defaultInternalState = { ...this.internalState };
  }
  getOrigin() {
    return 'https://www.dailymotion.com';
  }
  getPreconnections() {
    return [this.getOrigin(), 'https://static1.dmcdn.net'];
  }
  remoteControl(command, arg) {
    return this.embed.postMessage({
      command,
      parameters: arg ? [arg] : [],
    });
  }
  buildParams() {
    return {
      autoplay: this.autoplay,
      mute: this.initialMuted,
      'queue-autoplay-next': this.shouldAutoplayQueue,
      'queue-enable': this.showUpNextQueue,
      'sharing-enable': this.showShareButtons,
      syndication: this.syndication,
      'ui-highlight': this.color,
      'ui-logo': this.showDailymotionLogo,
      'ui-start-screen-info': this.showVideoInfo,
    };
  }
  async getVideoInfo() {
    if (videoInfoCache.has(this.videoId))
      return videoInfoCache.get(this.videoId);
    const apiEndpoint = 'https://api.dailymotion.com';
    return window
      .fetch(`${apiEndpoint}/video/${this.videoId}?fields=duration,thumbnail_1080_url`)
      .then((response) => response.json())
      .then((data) => {
      const poster = data.thumbnail_1080_url;
      const duration = parseFloat(data.duration);
      videoInfoCache.set(this.videoId, { poster, duration });
      return { poster, duration };
    });
  }
  onEmbedSrcChange() {
    this.vmLoadStart.emit();
    this.dispatch('viewType', ViewType.ViewType.Video);
  }
  onEmbedMessage(event) {
    const msg = event.detail;
    switch (msg.event) {
      case "playback_ready" /* PlaybackReady */:
        this.onControlsChange();
        this.dispatch('currentSrc', this.embedSrc);
        this.dispatch('mediaType', MediaType.MediaType.Video);
        Promise.all([
          this.fetchVideoInfo,
          this.pendingMediaTitleCall?.promise,
        ]).then(([info, mediaTitle]) => {
          this.dispatch('duration', info?.duration ?? -1);
          this.dispatch('currentPoster', this.poster ?? info?.poster);
          this.dispatch('mediaTitle', mediaTitle);
          this.dispatch('playbackReady', true);
        });
        break;
      case "videochange" /* VideoChange */:
        this.pendingMediaTitleCall?.resolve(msg.title);
        break;
      case "start" /* Start */:
        this.dispatch('paused', false);
        this.dispatch('playbackStarted', true);
        this.dispatch('buffering', true);
        break;
      case "video_start" /* VideoStart */:
        // Commands don't go through until ads have finished, so we store them and then replay them
        // once the video starts.
        this.remoteControl("muted" /* Muted */, this.internalState.muted);
        this.remoteControl("volume" /* Volume */, this.internalState.volume);
        if (this.internalState.currentTime > 0) {
          this.remoteControl("seek" /* Seek */, this.internalState.currentTime);
        }
        break;
      case "play" /* Play */:
        this.dispatch('paused', false);
        break;
      case "pause" /* Pause */:
        this.dispatch('paused', true);
        this.dispatch('playing', false);
        this.dispatch('buffering', false);
        break;
      case "playing" /* Playing */:
        this.dispatch('playing', true);
        this.dispatch('buffering', false);
        break;
      case "video_end" /* VideoEnd */:
        if (this.loop) {
          setTimeout(() => {
            this.remoteControl("play" /* Play */);
          }, 300);
        }
        else {
          this.dispatch('playbackEnded', true);
        }
        break;
      case "timeupdate" /* TimeUpdate */:
        this.dispatch('currentTime', parseFloat(msg.time));
        break;
      case "volumechange" /* VolumeChange */:
        this.dispatch('muted', msg.muted === 'true');
        this.dispatch('volume', Math.floor(parseFloat(msg.volume) * 100));
        break;
      case "seeking" /* Seeking */:
        this.dispatch('currentTime', parseFloat(msg.time));
        this.dispatch('seeking', true);
        break;
      case "seeked" /* Seeked */:
        this.dispatch('currentTime', parseFloat(msg.time));
        this.dispatch('seeking', false);
        break;
      case "waiting" /* Waiting */:
        this.dispatch('buffering', true);
        break;
      case "progress" /* Progress */:
        this.dispatch('buffered', parseFloat(msg.time));
        break;
      case "durationchange" /* DurationChange */:
        this.dispatch('duration', parseFloat(msg.duration));
        break;
      case "qualitiesavailable" /* QualitiesAvailable */:
        this.dispatch('playbackQualities', msg.qualities.map((q) => `${q}p`));
        break;
      case "qualitychange" /* QualityChange */:
        this.dispatch('playbackQuality', `${msg.quality}p`);
        break;
      case "fullscreenchange" /* FullscreenChange */:
        this.dispatch('isFullscreenActive', msg.fullscreen === 'true');
        break;
      case "error" /* Error */:
        this.vmError.emit(msg.error);
        break;
    }
  }
  /** @internal */
  async getAdapter() {
    const canPlayRegex = /(?:dai\.ly|dailymotion|dailymotion\.com)\/(?:video\/|embed\/|)(?:video\/|)((?:\w)+)/;
    return {
      getInternalPlayer: async () => this.embed,
      play: async () => {
        this.remoteControl("play" /* Play */);
      },
      pause: async () => {
        this.remoteControl("pause" /* Pause */);
      },
      canPlay: async (type) => withComponentRegistry.isString(type) && canPlayRegex.test(type),
      setCurrentTime: async (time) => {
        this.internalState.currentTime = time;
        this.remoteControl("seek" /* Seek */, time);
      },
      setMuted: async (muted) => {
        this.internalState.muted = muted;
        this.remoteControl("muted" /* Muted */, muted);
      },
      setVolume: async (volume) => {
        this.internalState.volume = volume / 100;
        this.dispatch('volume', volume);
        this.remoteControl("volume" /* Volume */, volume / 100);
      },
      canSetPlaybackQuality: async () => true,
      setPlaybackQuality: async (quality) => {
        this.remoteControl("quality" /* Quality */, quality.slice(0, -1));
      },
      canSetFullscreen: async () => true,
      enterFullscreen: async () => {
        this.remoteControl("fullscreen" /* Fullscreen */, true);
      },
      exitFullscreen: async () => {
        this.remoteControl("fullscreen" /* Fullscreen */, false);
      },
    };
  }
  render() {
    return (index.h("vm-embed", { embedSrc: this.embedSrc, mediaTitle: this.mediaTitle, origin: this.getOrigin(), params: this.buildParams(), decoder: network.decodeQueryString, preconnections: this.getPreconnections(), onVmEmbedMessage: this.onEmbedMessage.bind(this), onVmEmbedSrcChange: this.onEmbedSrcChange.bind(this), ref: (el) => {
        this.embed = el;
      } }));
  }
  static get watchers() { return {
    "videoId": ["onVideoIdChange"],
    "controls": ["onControlsChange"],
    "poster": ["onCustomPosterChange"]
  }; }
};
Dailymotion.style = dailymotionCss;

exports.vm_dailymotion = Dailymotion;
