'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-9e4d61ac.js');
require('./PlayerProps-4bbfc16a.js');
const withComponentRegistry = require('./withComponentRegistry-50d191fe.js');
const withPlayerContext = require('./withPlayerContext-460e142f.js');
require('./PlayerEvents-58225f02.js');
const MediaType = require('./MediaType-abb6d107.js');
require('./Provider-0e71f5a4.js');
const utils = require('./utils-b8b7354f.js');
const ProviderConnect = require('./ProviderConnect-3c00ee3c.js');
require('./support-4718bf00.js');
const network = require('./network-55de9370.js');

const HLS = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.vmLoadStart = index.createEvent(this, "vmLoadStart", 7);
    this.vmError = index.createEvent(this, "vmError", 7);
    this.hasAttached = false;
    /**
     * The NPM package version of the `hls.js` library to download and use if HLS is not natively
     * supported.
     */
    this.version = 'latest';
    /** @inheritdoc */
    this.preload = 'metadata';
    /** @internal */
    this.playbackReady = false;
    withComponentRegistry.withComponentRegistry(this);
    ProviderConnect.withProviderConnect(this);
    withPlayerContext.withPlayerContext(this, ['playbackReady']);
  }
  connectedCallback() {
    this.dispatch = ProviderConnect.createProviderDispatcher(this);
    if (this.mediaEl)
      this.setupHls();
  }
  disconnectedCallback() {
    this.destroyHls();
  }
  get src() {
    if (withComponentRegistry.isNullOrUndefined(this.videoProvider))
      return undefined;
    const sources = this.videoProvider.querySelectorAll('source');
    const currSource = Array.from(sources).find((source) => utils.hlsRegex.test(source.src) || utils.hlsTypeRegex.test(source.type));
    return currSource?.src;
  }
  async setupHls() {
    if (!withComponentRegistry.isUndefined(this.hls))
      return;
    try {
      const url = this.libSrc ||
        `https://cdn.jsdelivr.net/npm/hls.js@${this.version}/dist/hls.min.js`;
      const Hls = await network.loadSDK(url, 'Hls');
      if (!Hls.isSupported()) {
        this.vmError.emit('hls.js is not supported');
        return;
      }
      this.hls = new Hls(this.config);
      this.hls.on(Hls.Events.MEDIA_ATTACHED, () => {
        this.hasAttached = true;
        this.onSrcChange();
      });
      this.hls.on(Hls.Events.AUDIO_TRACKS_UPDATED, () => {
        this.dispatch('audioTracks', this.hls.audioTracks);
        this.dispatch('currentAudioTrack', this.hls.audioTrack);
      });
      this.hls.on(Hls.Events.AUDIO_TRACK_SWITCHED, () => {
        this.dispatch('currentAudioTrack', this.hls.audioTrack);
      });
      this.hls.on(Hls.Events.ERROR, (event, data) => {
        if (data.fatal) {
          switch (data.type) {
            case Hls.ErrorTypes.NETWORK_ERROR:
              this.hls.startLoad();
              break;
            case Hls.ErrorTypes.MEDIA_ERROR:
              this.hls.recoverMediaError();
              break;
            default:
              this.destroyHls();
              break;
          }
        }
        this.vmError.emit({ event, data });
      });
      this.hls.on(Hls.Events.MANIFEST_PARSED, () => {
        this.dispatch('mediaType', MediaType.MediaType.Video);
        this.dispatch('currentSrc', this.src);
        this.dispatchLevels();
      });
      this.hls.on(Hls.Events.LEVEL_LOADED, (_, data) => {
        if (!this.playbackReady) {
          this.dispatch('duration', data.details.totalduration);
          this.dispatch('playbackReady', true);
        }
      });
      this.hls.attachMedia(this.mediaEl);
    }
    catch (e) {
      this.vmError.emit(e);
    }
  }
  dispatchLevels() {
    if (!this.hls.levels || this.hls.levels.length === 0)
      return;
    this.dispatch('playbackQualities', [
      'Auto',
      ...this.hls.levels.map(this.levelToPlaybackQuality),
    ]);
    this.dispatch('playbackQuality', 'Auto');
  }
  levelToPlaybackQuality(level) {
    return level === -1 ? 'Auto' : `${level.height}p`;
  }
  findLevelIndexFromQuality(quality) {
    return this.hls.levels.findIndex((level) => this.levelToPlaybackQuality(level) === quality);
  }
  destroyHls() {
    this.hls?.destroy();
    this.hasAttached = false;
  }
  async onMediaElChange(event) {
    this.destroyHls();
    if (withComponentRegistry.isUndefined(event.detail))
      return;
    this.mediaEl = event.detail;
    // Need a small delay incase the media element changes rapidly and Hls.js can't reattach.
    setTimeout(async () => {
      await this.setupHls();
    }, 50);
  }
  async onSrcChange() {
    if (this.hasAttached && this.hls.url !== this.src) {
      this.vmLoadStart.emit();
      this.hls.loadSource(this.src);
    }
  }
  /** @internal */
  async getAdapter() {
    const adapter = (await this.videoProvider?.getAdapter()) ?? {};
    const canVideoProviderPlay = adapter.canPlay;
    return {
      ...adapter,
      getInternalPlayer: async () => this.hls,
      canPlay: async (type) => (withComponentRegistry.isString(type) && utils.hlsRegex.test(type)) ||
        (canVideoProviderPlay?.(type) ?? false),
      canSetPlaybackQuality: async () => this.hls?.levels?.length > 0,
      setPlaybackQuality: async (quality) => {
        if (!withComponentRegistry.isUndefined(this.hls)) {
          this.hls.currentLevel = this.findLevelIndexFromQuality(quality);
          // Update the provider cache.
          this.dispatch('playbackQuality', quality);
        }
      },
      setCurrentAudioTrack: async (trackId) => {
        if (!withComponentRegistry.isUndefined(this.hls)) {
          this.hls.audioTrack = trackId;
        }
      },
    };
  }
  render() {
    return (index.h("vm-video", { willAttach: true, crossOrigin: this.crossOrigin, preload: this.preload, poster: this.poster, controlsList: this.controlsList, autoPiP: this.autoPiP, disablePiP: this.disablePiP, disableRemotePlayback: this.disableRemotePlayback, mediaTitle: this.mediaTitle, ref: (el) => {
        this.videoProvider = el;
      } }, index.h("slot", null)));
  }
};

exports.vm_hls = HLS;
