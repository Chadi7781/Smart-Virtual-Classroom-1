/* eslint-disable func-names */
import { getElement, writeTask } from '@stencil/core';
import { initialState, isWritableProp, shouldPropResetOnMediaChange, } from './PlayerProps';
import { createStencilHook, wrapStencilHook } from '../../../utils/stencil';
import { Disposal } from '../../../utils/Disposal';
import { listen } from '../../../utils/dom';
import { isUndefined } from '../../../utils/unit';
import { LOAD_START_EVENT } from './PlayerEvents';
import { STATE_CHANGE_EVENT } from './PlayerDispatcher';
import { PROVIDER_CACHE_KEY } from '../../providers/ProviderConnect';
// These changes need to be called immediately to avoid the browser blocking the request.
const immediateAdapterCall = new Set(['currentTime', 'paused']);
export function withPlayerScheduler(player) {
  const el = getElement(player);
  const cache = new Map();
  const disposal = new Disposal();
  function initCache() {
    Object.keys(initialState).forEach((prop) => {
      cache.set(prop, player[prop]);
    });
  }
  // Queue of adapter calls to be run when the media is ready for playback.
  let adapterCalls = [];
  async function flushAdapterCalls() {
    const adapter = await player.adapter;
    if (isUndefined(adapter))
      return;
    for (let i = 0; i < adapterCalls.length; i += 1) {
      // eslint-disable-next-line no-await-in-loop
      await adapterCalls[i](adapter);
    }
    adapterCalls = [];
  }
  let hasMediaChanged = false;
  function onMediaChange(e) {
    e?.stopImmediatePropagation();
    // Don't reset first time otherwise props intialized by the user will be reset.
    if (!hasMediaChanged) {
      hasMediaChanged = true;
      return;
    }
    adapterCalls = [];
    writeTask(() => {
      Object.keys(initialState)
        .filter(shouldPropResetOnMediaChange)
        .forEach((prop) => {
        player[prop] = initialState[prop];
      });
    });
  }
  async function onStateChange(event) {
    event.stopImmediatePropagation();
    const { by, prop, value } = event.detail;
    if (!isWritableProp(prop)) {
      player.logger?.warn(`${by.nodeName} tried to change \`${prop}\` but it is readonly.`);
      return;
    }
    if (!player.playbackStarted && immediateAdapterCall.has(prop)) {
      const adapter = await player.adapter;
      if (prop === 'paused' && !value) {
        adapter?.play();
      }
      if (prop === 'currentTime') {
        adapter?.play();
        adapter?.setCurrentTime(value);
      }
    }
    writeTask(() => {
      player[prop] = value;
    });
  }
  // Called by ProviderConnect.
  const { onProviderDisconnect } = player;
  player.onProviderDisconnect = function () {
    onMediaChange();
    if (onProviderDisconnect)
      onProviderDisconnect.call(player);
  };
  createStencilHook(player, () => {
    initCache();
    disposal.add(listen(el, LOAD_START_EVENT, onMediaChange));
    disposal.add(listen(el, STATE_CHANGE_EVENT, onStateChange));
  }, () => {
    cache.clear();
    disposal.empty();
  });
  wrapStencilHook(player, 'componentWillRender', async () => {
    if (player.playbackReady && adapterCalls.length > 0)
      await flushAdapterCalls();
  });
  function isAdapterCallRequired(prop, value) {
    return value !== player[PROVIDER_CACHE_KEY]?.get(prop);
  }
  return async function safeAdapterCall(prop, method) {
    if (!isAdapterCallRequired(prop, player[prop]))
      return;
    const value = player[prop];
    const safeCall = async (adapter) => {
      try {
        // @ts-ignore
        await adapter?.[method]?.(value);
      }
      catch (e) {
        el.dispatchEvent(new CustomEvent('vmError', { detail: e }));
      }
    };
    if (player.playbackReady) {
      await safeCall(await player.adapter);
    }
    else {
      adapterCalls.push(safeCall);
    }
  };
}
